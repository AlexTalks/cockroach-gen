// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kv/kvserver/kvserverpb/raft.proto

package kvserverpb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_cockroachdb_cockroach_pkg_kv_kvpb "github.com/cockroachdb/cockroach/pkg/kv/kvpb"
	kvpb "github.com/cockroachdb/cockroach/pkg/kv/kvpb"
	kvflowcontrolpb "github.com/cockroachdb/cockroach/pkg/kv/kvserver/kvflowcontrol/kvflowcontrolpb"
	livenesspb "github.com/cockroachdb/cockroach/pkg/kv/kvserver/liveness/livenesspb"
	raftpb "github.com/cockroachdb/cockroach/pkg/raft/raftpb"
	github_com_cockroachdb_cockroach_pkg_roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	tracingpb "github.com/cockroachdb/cockroach/pkg/util/tracing/tracingpb"
	github_com_cockroachdb_cockroach_pkg_util_uuid "github.com/cockroachdb/cockroach/pkg/util/uuid"
	errorspb "github.com/cockroachdb/errors/errorspb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueueName indicates the source of the snapshot. Snapshots are prioritized
// within a queue and round-robin selected between queues for both the sending
// and receiving side.
type SnapshotRequest_QueueName int32

const (
	SnapshotRequest_OTHER               SnapshotRequest_QueueName = 0
	SnapshotRequest_REPLICATE_QUEUE     SnapshotRequest_QueueName = 1
	SnapshotRequest_RAFT_SNAPSHOT_QUEUE SnapshotRequest_QueueName = 2
)

var SnapshotRequest_QueueName_name = map[int32]string{
	0: "OTHER",
	1: "REPLICATE_QUEUE",
	2: "RAFT_SNAPSHOT_QUEUE",
}

var SnapshotRequest_QueueName_value = map[string]int32{
	"OTHER":               0,
	"REPLICATE_QUEUE":     1,
	"RAFT_SNAPSHOT_QUEUE": 2,
}

func (x SnapshotRequest_QueueName) String() string {
	return proto.EnumName(SnapshotRequest_QueueName_name, int32(x))
}

func (SnapshotRequest_QueueName) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_755441ac72dfaa3b, []int{5, 0}
}

type SnapshotResponse_Status int32

const (
	SnapshotResponse_UNKNOWN  SnapshotResponse_Status = 0
	SnapshotResponse_ACCEPTED SnapshotResponse_Status = 1
	SnapshotResponse_APPLIED  SnapshotResponse_Status = 2
	SnapshotResponse_ERROR    SnapshotResponse_Status = 3
)

var SnapshotResponse_Status_name = map[int32]string{
	0: "UNKNOWN",
	1: "ACCEPTED",
	2: "APPLIED",
	3: "ERROR",
}

var SnapshotResponse_Status_value = map[string]int32{
	"UNKNOWN":  0,
	"ACCEPTED": 1,
	"APPLIED":  2,
	"ERROR":    3,
}

func (x SnapshotResponse_Status) String() string {
	return proto.EnumName(SnapshotResponse_Status_name, int32(x))
}

func (SnapshotResponse_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_755441ac72dfaa3b, []int{6, 0}
}

type DelegateSnapshotResponse_Status int32

const (
	DelegateSnapshotResponse_ERROR   DelegateSnapshotResponse_Status = 0
	DelegateSnapshotResponse_APPLIED DelegateSnapshotResponse_Status = 1
)

var DelegateSnapshotResponse_Status_name = map[int32]string{
	0: "ERROR",
	1: "APPLIED",
}

var DelegateSnapshotResponse_Status_value = map[string]int32{
	"ERROR":   0,
	"APPLIED": 1,
}

func (x DelegateSnapshotResponse_Status) String() string {
	return proto.EnumName(DelegateSnapshotResponse_Status_name, int32(x))
}

func (DelegateSnapshotResponse_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_755441ac72dfaa3b, []int{9, 0}
}

// RaftHeartbeat is a request that contains the barebones information for a
// raftpb.MsgHeartbeat raftpb.Message. RaftHeartbeats are coalesced and sent
// in a RaftMessageRequest, and reconstructed by the receiver into individual
// raftpb.Message protos.
type RaftHeartbeat struct {
	RangeID                   github_com_cockroachdb_cockroach_pkg_roachpb.RangeID   `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty"`
	FromReplicaID             github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID `protobuf:"varint,2,opt,name=from_replica_id,json=fromReplicaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.ReplicaID" json:"from_replica_id,omitempty"`
	ToReplicaID               github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID `protobuf:"varint,3,opt,name=to_replica_id,json=toReplicaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.ReplicaID" json:"to_replica_id,omitempty"`
	Term                      github_com_cockroachdb_cockroach_pkg_kv_kvpb.RaftTerm  `protobuf:"varint,4,opt,name=term,proto3,casttype=github.com/cockroachdb/cockroach/pkg/kv/kvpb.RaftTerm" json:"term,omitempty"`
	Commit                    github_com_cockroachdb_cockroach_pkg_kv_kvpb.RaftIndex `protobuf:"varint,5,opt,name=commit,proto3,casttype=github.com/cockroachdb/cockroach/pkg/kv/kvpb.RaftIndex" json:"commit,omitempty"`
	Quiesce                   bool                                                   `protobuf:"varint,6,opt,name=quiesce,proto3" json:"quiesce,omitempty"`
	LaggingFollowersOnQuiesce []livenesspb.Liveness                                  `protobuf:"bytes,8,rep,name=lagging_followers_on_quiesce,json=laggingFollowersOnQuiesce,proto3" json:"lagging_followers_on_quiesce"`
	// This field helps migrate in the lagging_followers_on_quiesce field. For
	// messages sent by versions of Cockroach that do not know about the
	// lagging_followers_on_quiesce field (i.e. v20.1), we need to assume that all
	// replicas are lagging, not that none of them are.
	//
	// TODO(nvanbenschoten): Migration path:
	// v20.2: Add this field. Always set to true when quiesce == true.
	//        Consult field on receiver. Consider all replicas "lagging"
	//        if not set to true on liveness change.
	// v22.1: Keep sending. Stop consulting.
	// v22.2: Remove field.
	LaggingFollowersOnQuiesceAccurate bool `protobuf:"varint,10,opt,name=lagging_followers_on_quiesce_accurate,json=laggingFollowersOnQuiesceAccurate,proto3" json:"lagging_followers_on_quiesce_accurate,omitempty"`
}

func (m *RaftHeartbeat) Reset()         { *m = RaftHeartbeat{} }
func (m *RaftHeartbeat) String() string { return proto.CompactTextString(m) }
func (*RaftHeartbeat) ProtoMessage()    {}
func (*RaftHeartbeat) Descriptor() ([]byte, []int) {
	return fileDescriptor_755441ac72dfaa3b, []int{0}
}
func (m *RaftHeartbeat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftHeartbeat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RaftHeartbeat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftHeartbeat.Merge(m, src)
}
func (m *RaftHeartbeat) XXX_Size() int {
	return m.Size()
}
func (m *RaftHeartbeat) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftHeartbeat.DiscardUnknown(m)
}

var xxx_messageInfo_RaftHeartbeat proto.InternalMessageInfo

// RaftMessageRequest is the request used to send raft messages using our
// protobuf-based RPC codec. If a RaftMessageRequest has a non-empty number of
// heartbeats or heartbeat_resps, the contents of the message field is treated
// as a dummy message and discarded. A coalesced heartbeat request's replica
// descriptor's range ID must be zero.
type RaftMessageRequest struct {
	RangeID github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty"`
	// Optionally, the start key of the sending replica. This is only populated
	// as a "hint" under certain conditions.
	RangeStartKey github_com_cockroachdb_cockroach_pkg_roachpb.RKey `protobuf:"bytes,8,opt,name=range_start_key,json=rangeStartKey,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RKey" json:"range_start_key,omitempty"`
	FromReplica   roachpb.ReplicaDescriptor                         `protobuf:"bytes,2,opt,name=from_replica,json=fromReplica,proto3" json:"from_replica"`
	ToReplica     roachpb.ReplicaDescriptor                         `protobuf:"bytes,3,opt,name=to_replica,json=toReplica,proto3" json:"to_replica"`
	Message       raftpb.Message                                    `protobuf:"bytes,4,opt,name=message,proto3" json:"message"`
	// Is this a quiesce request? A quiesce request is a MsgHeartbeat
	// which is requesting the recipient to stop ticking its local
	// replica as long as the current Raft state matches the heartbeat
	// Term/Commit. If the Term/Commit match, the recipient is marked as
	// quiescent. If they don't match, the message is passed along to
	// Raft which will generate a MsgHeartbeatResp that will unquiesce
	// the sender.
	Quiesce bool `protobuf:"varint,5,opt,name=quiesce,proto3" json:"quiesce,omitempty"`
	// If quiesce is true, this set contains liveness information about
	// the replicas that were dead when the leader decided to quiesce and
	// were lagging behind the quiescence log index (meaning they would
	// have prevented quiescence had they been alive). If any replica
	// (leader or follower) becomes aware that a replica in this set has
	// become live, it should unquiesce the range so that the replica can
	// be caught back up.
	LaggingFollowersOnQuiesce []livenesspb.Liveness `protobuf:"bytes,9,rep,name=lagging_followers_on_quiesce,json=laggingFollowersOnQuiesce,proto3" json:"lagging_followers_on_quiesce"`
	// A coalesced heartbeat request is any RaftMessageRequest with a nonzero number of
	// heartbeats or heartbeat_resps.
	Heartbeats     []RaftHeartbeat `protobuf:"bytes,6,rep,name=heartbeats,proto3" json:"heartbeats"`
	HeartbeatResps []RaftHeartbeat `protobuf:"bytes,7,rep,name=heartbeat_resps,json=heartbeatResps,proto3" json:"heartbeat_resps"`
	// AdmittedRaftLogEntries is coalesced information about all raft log entries
	// that were admitted below raft.
	AdmittedRaftLogEntries []kvflowcontrolpb.AdmittedRaftLogEntries `protobuf:"bytes,11,rep,name=admitted_raft_log_entries,json=admittedRaftLogEntries,proto3" json:"admitted_raft_log_entries"`
}

func (m *RaftMessageRequest) Reset()         { *m = RaftMessageRequest{} }
func (m *RaftMessageRequest) String() string { return proto.CompactTextString(m) }
func (*RaftMessageRequest) ProtoMessage()    {}
func (*RaftMessageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_755441ac72dfaa3b, []int{1}
}
func (m *RaftMessageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftMessageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RaftMessageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftMessageRequest.Merge(m, src)
}
func (m *RaftMessageRequest) XXX_Size() int {
	return m.Size()
}
func (m *RaftMessageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftMessageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RaftMessageRequest proto.InternalMessageInfo

type RaftMessageRequestBatch struct {
	Requests []RaftMessageRequest `protobuf:"bytes,1,rep,name=requests,proto3" json:"requests"`
	// StoreIDs identifies all the stores on the client node. It's populated on
	// the first RaftMessageRequestBatch sent along MultiRaft.RaftMessageBatch
	// gRPC stream identifying at least one store, and the populated once more
	// if any additional stores have been initialized[^1]. This data is used by
	// the kvflowcontrol machinery to track the exact set of stores on the client
	// node. It uses this information to react to the gRPC streams breaking. Since
	// these streams are used to piggy information about which log entries were
	// admitted below raft[^2] in order for the server-side to free up flow
	// tokens, if the stream breaks we possibly risk leaking these tokens. So
	// when these streams break, we use information about the client's stores to
	// release all held tokens[^3].
	//
	// [^1]: This two-step process is because of how and when we allocate
	//       StoreIDs. Ignoring nodes that are bootstrapping the cluster (which
	//       just picks the initial set of StoreIDs -- see
	//       pkg/server.bootstrapCluster), whenever a new node is added, it's
	//       assigned a node ID and store ID by an existing node in CRDB (see
	//       kvpb.JoinNodeResponse). Subsequent store IDs, for multi-store nodes,
	//       are generated by the joining node by incrementing a sequence ID
	//       generator (see pkg/server.(*Node).initializeAdditionalStores). All of
	//       which is to say that the very first time we issue a
	//       RaftMessageRequestBatch, we might not have all the StoreIDs. But we
	//       will very shortly after, and certainly before and replicas get
	//       allocated to the additional store.
	// [^2]: See kvflowcontrolpb.AdmittedRaftLogEntries and its use in
	//       RaftMessageRequest.
	// [^3]: See I1 from kvflowcontrol/doc.go.
	StoreIDs []github_com_cockroachdb_cockroach_pkg_roachpb.StoreID `protobuf:"varint,2,rep,packed,name=store_ids,json=storeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"store_ids,omitempty"`
}

func (m *RaftMessageRequestBatch) Reset()         { *m = RaftMessageRequestBatch{} }
func (m *RaftMessageRequestBatch) String() string { return proto.CompactTextString(m) }
func (*RaftMessageRequestBatch) ProtoMessage()    {}
func (*RaftMessageRequestBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_755441ac72dfaa3b, []int{2}
}
func (m *RaftMessageRequestBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftMessageRequestBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RaftMessageRequestBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftMessageRequestBatch.Merge(m, src)
}
func (m *RaftMessageRequestBatch) XXX_Size() int {
	return m.Size()
}
func (m *RaftMessageRequestBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftMessageRequestBatch.DiscardUnknown(m)
}

var xxx_messageInfo_RaftMessageRequestBatch proto.InternalMessageInfo

type RaftMessageResponseUnion struct {
	Error *kvpb.Error `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *RaftMessageResponseUnion) Reset()         { *m = RaftMessageResponseUnion{} }
func (m *RaftMessageResponseUnion) String() string { return proto.CompactTextString(m) }
func (*RaftMessageResponseUnion) ProtoMessage()    {}
func (*RaftMessageResponseUnion) Descriptor() ([]byte, []int) {
	return fileDescriptor_755441ac72dfaa3b, []int{3}
}
func (m *RaftMessageResponseUnion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftMessageResponseUnion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RaftMessageResponseUnion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftMessageResponseUnion.Merge(m, src)
}
func (m *RaftMessageResponseUnion) XXX_Size() int {
	return m.Size()
}
func (m *RaftMessageResponseUnion) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftMessageResponseUnion.DiscardUnknown(m)
}

var xxx_messageInfo_RaftMessageResponseUnion proto.InternalMessageInfo

// RaftMessageResponse may be sent to the sender of a
// RaftMessageRequest. RaftMessage does not use the usual
// request/response pattern; it is primarily modeled as a one-way
// stream of requests. Normal 'responses' are usually sent as new
// requests on a separate stream in the other direction.
// RaftMessageResponse is not sent for every RaftMessageRequest, but
// may be used for certain error conditions.
type RaftMessageResponse struct {
	RangeID     github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty"`
	FromReplica roachpb.ReplicaDescriptor                            `protobuf:"bytes,2,opt,name=from_replica,json=fromReplica,proto3" json:"from_replica"`
	ToReplica   roachpb.ReplicaDescriptor                            `protobuf:"bytes,3,opt,name=to_replica,json=toReplica,proto3" json:"to_replica"`
	Union       RaftMessageResponseUnion                             `protobuf:"bytes,4,opt,name=union,proto3" json:"union"`
}

func (m *RaftMessageResponse) Reset()         { *m = RaftMessageResponse{} }
func (m *RaftMessageResponse) String() string { return proto.CompactTextString(m) }
func (*RaftMessageResponse) ProtoMessage()    {}
func (*RaftMessageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_755441ac72dfaa3b, []int{4}
}
func (m *RaftMessageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftMessageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RaftMessageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftMessageResponse.Merge(m, src)
}
func (m *RaftMessageResponse) XXX_Size() int {
	return m.Size()
}
func (m *RaftMessageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftMessageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RaftMessageResponse proto.InternalMessageInfo

// SnapshotRequest is the request used to send streaming snapshot requests.
type SnapshotRequest struct {
	Header *SnapshotRequest_Header `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// A BatchRepr. Multiple kv_batches may be sent across multiple request messages.
	KVBatch      []byte                        `protobuf:"bytes,2,opt,name=kv_batch,json=kvBatch,proto3" json:"kv_batch,omitempty"`
	Final        bool                          `protobuf:"varint,4,opt,name=final,proto3" json:"final,omitempty"`
	SharedTables []SnapshotRequest_SharedTable `protobuf:"bytes,5,rep,name=shared_tables,json=sharedTables,proto3" json:"shared_tables"`
	// If true, signals the receiver that the sender can no longer replicate
	// using shared files, even though the Header initially contained
	// shared_replicate = true. All contents of this range will be streamed as
	// usual beyond this point. This bool must be set to true in a request before
	// the end of the snapshot (i.e. before the final = true request), and this
	// flag must be set to true before any user keys are streamed.
	TransitionFromSharedToRegularReplicate bool                            `protobuf:"varint,6,opt,name=transition_from_shared_to_regular_replicate,json=transitionFromSharedToRegularReplicate,proto3" json:"transition_from_shared_to_regular_replicate,omitempty"`
	ExternalTables                         []SnapshotRequest_ExternalTable `protobuf:"bytes,7,rep,name=external_tables,json=externalTables,proto3" json:"external_tables"`
}

func (m *SnapshotRequest) Reset()         { *m = SnapshotRequest{} }
func (m *SnapshotRequest) String() string { return proto.CompactTextString(m) }
func (*SnapshotRequest) ProtoMessage()    {}
func (*SnapshotRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_755441ac72dfaa3b, []int{5}
}
func (m *SnapshotRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SnapshotRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotRequest.Merge(m, src)
}
func (m *SnapshotRequest) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotRequest proto.InternalMessageInfo

type SnapshotRequest_Header struct {
	// The replica state at the time the snapshot was generated. Note
	// that ReplicaState.Desc differs from the above range_descriptor
	// field which holds the updated descriptor after the new replica
	// has been added while ReplicaState.Desc holds the descriptor
	// before the new replica has been added.
	State ReplicaState `protobuf:"bytes,5,opt,name=state,proto3" json:"state"`
	// The inner raft message is of type MsgSnap, and its snapshot data contains a UUID.
	RaftMessageRequest RaftMessageRequest `protobuf:"bytes,2,opt,name=raft_message_request,json=raftMessageRequest,proto3" json:"raft_message_request"`
	// The estimated size of the range, to be used in reservation decisions.
	RangeSize int64 `protobuf:"varint,3,opt,name=range_size,json=rangeSize,proto3" json:"range_size,omitempty"`
	// The sending queue's name, to be utilized to ensure fairness across
	// different snapshot sending sources. The default queue name, OTHER, is
	// reserved for any uncategorized and unprioritized snapshots, and requests
	// with sender queue name OTHER may not specify a non-zero
	// sender_queue_priority.  To prioritize snapshots categorized as OTHER,
	// first move them to a different queue name.
	SenderQueueName SnapshotRequest_QueueName `protobuf:"varint,10,opt,name=sender_queue_name,json=senderQueueName,proto3,enum=cockroach.kv.kvserver.kvserverpb.SnapshotRequest_QueueName" json:"sender_queue_name,omitempty"`
	// The sending queue's priority, to be utilized to prioritize snapshots
	// from a particular sending source.
	SenderQueuePriority float64 `protobuf:"fixed64,11,opt,name=sender_queue_priority,json=senderQueuePriority,proto3" json:"sender_queue_priority,omitempty"`
	// If true, the snapshot could contain shared files present in a pre-configured
	// or explicitly specified shared.Storage instance. Such files will have their
	// metadata present in the snapshot, but not file contents.
	SharedReplicate bool `protobuf:"varint,12,opt,name=shared_replicate,json=sharedReplicate,proto3" json:"shared_replicate,omitempty"`
	// If true, the snapshot could contain external files. Such files
	// will have their metadata present in the snapshot but not the
	// file contents.
	ExternalReplicate bool `protobuf:"varint,13,opt,name=external_replicate,json=externalReplicate,proto3" json:"external_replicate,omitempty"`
}

func (m *SnapshotRequest_Header) Reset()         { *m = SnapshotRequest_Header{} }
func (m *SnapshotRequest_Header) String() string { return proto.CompactTextString(m) }
func (*SnapshotRequest_Header) ProtoMessage()    {}
func (*SnapshotRequest_Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_755441ac72dfaa3b, []int{5, 0}
}
func (m *SnapshotRequest_Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotRequest_Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SnapshotRequest_Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotRequest_Header.Merge(m, src)
}
func (m *SnapshotRequest_Header) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotRequest_Header) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotRequest_Header.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotRequest_Header proto.InternalMessageInfo

// SharedTable represents one shared SSTable present in shared storage.
// Intended to be the protobuf version of pebble.SharedSSTMeta.
type SnapshotRequest_SharedTable struct {
	// Used by the Pebble objstorage package to resolve a reference to a shared object.
	Backing []byte `protobuf:"bytes,1,opt,name=backing,proto3" json:"backing,omitempty"`
	// Used by the Pebble objstorage package to generate new blob storage drivers.
	// Reserved for future use.
	Locator []byte `protobuf:"bytes,2,opt,name=locator,proto3" json:"locator,omitempty"`
	// Smallest internal key in the sstable.
	Smallest *SnapshotRequest_SharedTable_InternalKey `protobuf:"bytes,3,opt,name=smallest,proto3" json:"smallest,omitempty"`
	// Largest internal key in the sstable.
	Largest *SnapshotRequest_SharedTable_InternalKey `protobuf:"bytes,4,opt,name=largest,proto3" json:"largest,omitempty"`
	// Smallest range key in the sstable. Zero value if no range keys are
	// present.
	SmallestRangeKey *SnapshotRequest_SharedTable_InternalKey `protobuf:"bytes,5,opt,name=smallest_range_key,json=smallestRangeKey,proto3" json:"smallest_range_key,omitempty"`
	// Largest range key in the sstable. Zero value if no range keys are
	// present.
	LargestRangeKey *SnapshotRequest_SharedTable_InternalKey `protobuf:"bytes,6,opt,name=largest_range_key,json=largestRangeKey,proto3" json:"largest_range_key,omitempty"`
	// Smallest point key in the sstable. Zero value if no point keys are
	// present.
	SmallestPointKey *SnapshotRequest_SharedTable_InternalKey `protobuf:"bytes,7,opt,name=smallest_point_key,json=smallestPointKey,proto3" json:"smallest_point_key,omitempty"`
	// Largest point key in the sstable. Zero value if no point keys are
	// present.
	LargestPointKey *SnapshotRequest_SharedTable_InternalKey `protobuf:"bytes,8,opt,name=largest_point_key,json=largestPointKey,proto3" json:"largest_point_key,omitempty"`
	// LSM level of the original sstable. This sstable will go into the same
	// level in the destination LSM.
	Level int32 `protobuf:"varint,9,opt,name=level,proto3" json:"level,omitempty"`
	// Physical size of the sstable in bytes.
	Size_ uint64 `protobuf:"varint,10,opt,name=size,proto3" json:"size,omitempty"`
}

func (m *SnapshotRequest_SharedTable) Reset()         { *m = SnapshotRequest_SharedTable{} }
func (m *SnapshotRequest_SharedTable) String() string { return proto.CompactTextString(m) }
func (*SnapshotRequest_SharedTable) ProtoMessage()    {}
func (*SnapshotRequest_SharedTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_755441ac72dfaa3b, []int{5, 1}
}
func (m *SnapshotRequest_SharedTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotRequest_SharedTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SnapshotRequest_SharedTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotRequest_SharedTable.Merge(m, src)
}
func (m *SnapshotRequest_SharedTable) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotRequest_SharedTable) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotRequest_SharedTable.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotRequest_SharedTable proto.InternalMessageInfo

// Internal key represents a Pebble-internal key. See pebble.InternalKey
// for details on how these keys are used.
type SnapshotRequest_SharedTable_InternalKey struct {
	// User key portion of the internal key.
	UserKey []byte `protobuf:"bytes,1,opt,name=user_key,json=userKey,proto3" json:"user_key,omitempty"`
	// Trailer portion of the internal key, as defined by Pebble.
	Trailer uint64 `protobuf:"varint,2,opt,name=trailer,proto3" json:"trailer,omitempty"`
}

func (m *SnapshotRequest_SharedTable_InternalKey) Reset() {
	*m = SnapshotRequest_SharedTable_InternalKey{}
}
func (m *SnapshotRequest_SharedTable_InternalKey) String() string { return proto.CompactTextString(m) }
func (*SnapshotRequest_SharedTable_InternalKey) ProtoMessage()    {}
func (*SnapshotRequest_SharedTable_InternalKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_755441ac72dfaa3b, []int{5, 1, 0}
}
func (m *SnapshotRequest_SharedTable_InternalKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotRequest_SharedTable_InternalKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SnapshotRequest_SharedTable_InternalKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotRequest_SharedTable_InternalKey.Merge(m, src)
}
func (m *SnapshotRequest_SharedTable_InternalKey) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotRequest_SharedTable_InternalKey) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotRequest_SharedTable_InternalKey.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotRequest_SharedTable_InternalKey proto.InternalMessageInfo

// ExternalTable represents one SSTable present in external storage.
// Intended to be the protobuf version of pebble.ExternalFile.
type SnapshotRequest_ExternalTable struct {
	// Used by the Pebble objstorage package to generate new blob storage drivers.
	// Reserved for future use.
	Locator []byte `protobuf:"bytes,1,opt,name=locator,proto3" json:"locator,omitempty"`
	// ObjName is the unique name of this sstable on Locator.
	ObjectName string `protobuf:"bytes,2,opt,name=object_name,json=objectName,proto3" json:"object_name,omitempty"`
	// Physical size of the sstable in bytes.
	Size_ uint64 `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
	// StartKey is the loose, inclusive start key of the sstable.
	StartKey []byte `protobuf:"bytes,4,opt,name=StartKey,proto3" json:"StartKey,omitempty"`
	// EndKey is the loose, end key of the sstable. Whether it is
	// inclusive or exclusive is controlled by EndKeyIsInclusive.
	EndKey []byte `protobuf:"bytes,5,opt,name=EndKey,proto3" json:"EndKey,omitempty"`
	// EndKeyIsInclusive is true if the EndKey is inclusive.
	EndKeyIsInclusive bool `protobuf:"varint,6,opt,name=EndKeyIsInclusive,proto3" json:"EndKeyIsInclusive,omitempty"`
	// HasPointKey denote whether this file contains point keys.
	HasPointKey bool `protobuf:"varint,7,opt,name=has_point_key,json=hasPointKey,proto3" json:"has_point_key,omitempty"`
	// HasRangeKey denote whether this file contains range keys.
	HasRangeKey bool `protobuf:"varint,8,opt,name=has_range_key,json=hasRangeKey,proto3" json:"has_range_key,omitempty"`
	// SyntheticPrefix will prepend this suffix to all keys in the file during
	// iteration. Note that the backing file itself is not modified.
	SyntheticPrefix []byte `protobuf:"bytes,9,opt,name=synthetic_prefix,json=syntheticPrefix,proto3" json:"synthetic_prefix,omitempty"`
	// SyntheticSuffix will replace the suffix of every key in the file during
	// iteration. Note that the file itself is not modified, rather, every key
	// returned by an iterator will have the synthetic suffix.
	//
	// SyntheticSuffix can only be used under the following conditions:
	//  - the synthetic suffix must sort before any non-empty suffixes in the
	//    backing sst (the entire sst, not just the part restricted to Bounds).
	//  - the backing sst must not contain multiple keys with the same prefix.
	SyntheticSuffix []byte `protobuf:"bytes,10,opt,name=synthetic_suffix,json=syntheticSuffix,proto3" json:"synthetic_suffix,omitempty"`
	// LSM level of the original sstable. This sstable will go into the same
	// level in the destination LSM.
	Level int32 `protobuf:"varint,11,opt,name=level,proto3" json:"level,omitempty"`
}

func (m *SnapshotRequest_ExternalTable) Reset()         { *m = SnapshotRequest_ExternalTable{} }
func (m *SnapshotRequest_ExternalTable) String() string { return proto.CompactTextString(m) }
func (*SnapshotRequest_ExternalTable) ProtoMessage()    {}
func (*SnapshotRequest_ExternalTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_755441ac72dfaa3b, []int{5, 2}
}
func (m *SnapshotRequest_ExternalTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotRequest_ExternalTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SnapshotRequest_ExternalTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotRequest_ExternalTable.Merge(m, src)
}
func (m *SnapshotRequest_ExternalTable) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotRequest_ExternalTable) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotRequest_ExternalTable.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotRequest_ExternalTable proto.InternalMessageInfo

type SnapshotResponse struct {
	Status SnapshotResponse_Status `protobuf:"varint,1,opt,name=status,proto3,enum=cockroach.kv.kvserver.kvserverpb.SnapshotResponse_Status" json:"status,omitempty"`
	// Message is a message explaining an ERROR return value. It is not set for any
	// other status.
	//
	// As of 23.1, the encoded_error field is always used instead. 23.1 itself
	// needs to populate both due to needing to be compatible with 22.2. Once
	// the MinSupportedVersion is 23.1, this can be removed.
	DeprecatedMessage string `protobuf:"bytes,2,opt,name=deprecated_message,json=deprecatedMessage,proto3" json:"deprecated_message,omitempty"`
	// Traces from snapshot processing, returned on status APPLIED or ERROR.
	CollectedSpans []tracingpb.RecordedSpan `protobuf:"bytes,4,rep,name=collected_spans,json=collectedSpans,proto3" json:"collected_spans"`
	// encoded_error encodes the error when the status is ERROR.
	//
	// MIGRATION: only guaranteed to be set when the message field is no longer there.
	EncodedError errorspb.EncodedError `protobuf:"bytes,5,opt,name=encoded_error,json=encodedError,proto3" json:"encoded_error"`
	// msg_app_resp stores an optional MsgAppResp the receiving RawNode may have
	// generated in response to applying the snapshot. This message will also have
	// been handed to the raft transport, but it is helpful to step it into the
	// sender manually to avoid the race described in:
	//
	// https://github.com/cockroachdb/cockroach/issues/97971
	MsgAppResp *raftpb.Message `protobuf:"bytes,6,opt,name=msg_app_resp,json=msgAppResp,proto3" json:"msg_app_resp,omitempty"`
}

func (m *SnapshotResponse) Reset()         { *m = SnapshotResponse{} }
func (m *SnapshotResponse) String() string { return proto.CompactTextString(m) }
func (*SnapshotResponse) ProtoMessage()    {}
func (*SnapshotResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_755441ac72dfaa3b, []int{6}
}
func (m *SnapshotResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SnapshotResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotResponse.Merge(m, src)
}
func (m *SnapshotResponse) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotResponse proto.InternalMessageInfo

// TODO(baptist): Extend this if necessary to separate out the request for the throttle.
type DelegateSnapshotRequest struct {
	// Types that are valid to be assigned to Value:
	//	*DelegateSnapshotRequest_Send
	Value isDelegateSnapshotRequest_Value `protobuf_oneof:"value"`
}

func (m *DelegateSnapshotRequest) Reset()         { *m = DelegateSnapshotRequest{} }
func (m *DelegateSnapshotRequest) String() string { return proto.CompactTextString(m) }
func (*DelegateSnapshotRequest) ProtoMessage()    {}
func (*DelegateSnapshotRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_755441ac72dfaa3b, []int{7}
}
func (m *DelegateSnapshotRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegateSnapshotRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DelegateSnapshotRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegateSnapshotRequest.Merge(m, src)
}
func (m *DelegateSnapshotRequest) XXX_Size() int {
	return m.Size()
}
func (m *DelegateSnapshotRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegateSnapshotRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DelegateSnapshotRequest proto.InternalMessageInfo

type isDelegateSnapshotRequest_Value interface {
	isDelegateSnapshotRequest_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DelegateSnapshotRequest_Send struct {
	Send *DelegateSendSnapshotRequest `protobuf:"bytes,1,opt,name=send,proto3,oneof" json:"send,omitempty"`
}

func (*DelegateSnapshotRequest_Send) isDelegateSnapshotRequest_Value() {}

func (m *DelegateSnapshotRequest) GetValue() isDelegateSnapshotRequest_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *DelegateSnapshotRequest) GetSend() *DelegateSendSnapshotRequest {
	if x, ok := m.GetValue().(*DelegateSnapshotRequest_Send); ok {
		return x.Send
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DelegateSnapshotRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DelegateSnapshotRequest_Send)(nil),
	}
}

// DelegateSnapshotRequest is the request used to delegate send snapshot requests.
type DelegateSendSnapshotRequest struct {
	RangeID github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty"`
	// The replica that delegates the snapshot request, in most cases the leader/leaseholder.
	// The snapshot request should originate from the coordinator.
	CoordinatorReplica roachpb.ReplicaDescriptor `protobuf:"bytes,2,opt,name=coordinator_replica,json=coordinatorReplica,proto3" json:"coordinator_replica"`
	// The replica receiving the snapshot.
	RecipientReplica roachpb.ReplicaDescriptor `protobuf:"bytes,3,opt,name=recipient_replica,json=recipientReplica,proto3" json:"recipient_replica"`
	// The replica selected to act as the snapshot sender.
	DelegatedSender roachpb.ReplicaDescriptor `protobuf:"bytes,4,opt,name=delegated_sender,json=delegatedSender,proto3" json:"delegated_sender"`
	// The Raft term of the coordinator (in most cases the leaseholder) replica.
	// The term is used during snapshot receiving to reject messages from an older term.
	Term github_com_cockroachdb_cockroach_pkg_kv_kvpb.RaftTerm `protobuf:"varint,7,opt,name=term,proto3,casttype=github.com/cockroachdb/cockroach/pkg/kv/kvpb.RaftTerm" json:"term,omitempty"`
	// The first index of the Raft log on the coordinator replica.
	FirstIndex github_com_cockroachdb_cockroach_pkg_kv_kvpb.RaftIndex `protobuf:"varint,8,opt,name=first_index,json=firstIndex,proto3,casttype=github.com/cockroachdb/cockroach/pkg/kv/kvpb.RaftIndex" json:"first_index,omitempty"`
	// The sending queue's name.
	SenderQueueName SnapshotRequest_QueueName `protobuf:"varint,9,opt,name=sender_queue_name,json=senderQueueName,proto3,enum=cockroach.kv.kvserver.kvserverpb.SnapshotRequest_QueueName" json:"sender_queue_name,omitempty"`
	// The sending queue's priority.
	SenderQueuePriority float64 `protobuf:"fixed64,10,opt,name=sender_queue_priority,json=senderQueuePriority,proto3" json:"sender_queue_priority,omitempty"`
	// The generation of the leaseholders descriptor.
	DescriptorGeneration github_com_cockroachdb_cockroach_pkg_roachpb.RangeGeneration `protobuf:"varint,11,opt,name=descriptor_generation,json=descriptorGeneration,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeGeneration" json:"descriptor_generation,omitempty"`
	// Max queue length on the delegate before this request is rejected.
	QueueOnDelegateLen int64 `protobuf:"varint,12,opt,name=queue_on_delegate_len,json=queueOnDelegateLen,proto3" json:"queue_on_delegate_len,omitempty"`
	// Id of this snapshot which is maintained from coordinator to receiver.
	SnapId github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,13,opt,name=snap_id,json=snapId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"snap_id"`
}

func (m *DelegateSendSnapshotRequest) Reset()         { *m = DelegateSendSnapshotRequest{} }
func (m *DelegateSendSnapshotRequest) String() string { return proto.CompactTextString(m) }
func (*DelegateSendSnapshotRequest) ProtoMessage()    {}
func (*DelegateSendSnapshotRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_755441ac72dfaa3b, []int{8}
}
func (m *DelegateSendSnapshotRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegateSendSnapshotRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DelegateSendSnapshotRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegateSendSnapshotRequest.Merge(m, src)
}
func (m *DelegateSendSnapshotRequest) XXX_Size() int {
	return m.Size()
}
func (m *DelegateSendSnapshotRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegateSendSnapshotRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DelegateSendSnapshotRequest proto.InternalMessageInfo

type DelegateSnapshotResponse struct {
	Status       DelegateSnapshotResponse_Status `protobuf:"varint,1,opt,name=status,proto3,enum=cockroach.kv.kvserver.kvserverpb.DelegateSnapshotResponse_Status" json:"status,omitempty"`
	EncodedError errorspb.EncodedError           `protobuf:"bytes,2,opt,name=encoded_error,json=encodedError,proto3" json:"encoded_error"`
	// collected_spans stores trace spans recorded during the execution of this
	// request.
	CollectedSpans []tracingpb.RecordedSpan `protobuf:"bytes,3,rep,name=collected_spans,json=collectedSpans,proto3" json:"collected_spans"`
	// msg_app_resp stores an optional MsgAppResp the receiving RawNode may have
	// generated in response to applying the snapshot. This message will also have
	// been handed to the raft transport, but it is helpful to step it into the
	// sender manually to avoid the race described in:
	//
	// https://github.com/cockroachdb/cockroach/issues/97971
	MsgAppResp *raftpb.Message `protobuf:"bytes,4,opt,name=msg_app_resp,json=msgAppResp,proto3" json:"msg_app_resp,omitempty"`
}

func (m *DelegateSnapshotResponse) Reset()         { *m = DelegateSnapshotResponse{} }
func (m *DelegateSnapshotResponse) String() string { return proto.CompactTextString(m) }
func (*DelegateSnapshotResponse) ProtoMessage()    {}
func (*DelegateSnapshotResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_755441ac72dfaa3b, []int{9}
}
func (m *DelegateSnapshotResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegateSnapshotResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DelegateSnapshotResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegateSnapshotResponse.Merge(m, src)
}
func (m *DelegateSnapshotResponse) XXX_Size() int {
	return m.Size()
}
func (m *DelegateSnapshotResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegateSnapshotResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DelegateSnapshotResponse proto.InternalMessageInfo

// ConfChangeContext is encoded in the raftpb.ConfChange.Context field.
type ConfChangeContext struct {
	CommandID string `protobuf:"bytes,1,opt,name=command_id,json=commandId,proto3" json:"command_id,omitempty"`
	// Payload is the application-level command (i.e. an encoded
	// kvserverpb.RaftCommand).
	Payload []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *ConfChangeContext) Reset()         { *m = ConfChangeContext{} }
func (m *ConfChangeContext) String() string { return proto.CompactTextString(m) }
func (*ConfChangeContext) ProtoMessage()    {}
func (*ConfChangeContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_755441ac72dfaa3b, []int{10}
}
func (m *ConfChangeContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfChangeContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConfChangeContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfChangeContext.Merge(m, src)
}
func (m *ConfChangeContext) XXX_Size() int {
	return m.Size()
}
func (m *ConfChangeContext) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfChangeContext.DiscardUnknown(m)
}

var xxx_messageInfo_ConfChangeContext proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.kv.kvserver.kvserverpb.SnapshotRequest_QueueName", SnapshotRequest_QueueName_name, SnapshotRequest_QueueName_value)
	proto.RegisterEnum("cockroach.kv.kvserver.kvserverpb.SnapshotResponse_Status", SnapshotResponse_Status_name, SnapshotResponse_Status_value)
	proto.RegisterEnum("cockroach.kv.kvserver.kvserverpb.DelegateSnapshotResponse_Status", DelegateSnapshotResponse_Status_name, DelegateSnapshotResponse_Status_value)
	proto.RegisterType((*RaftHeartbeat)(nil), "cockroach.kv.kvserver.kvserverpb.RaftHeartbeat")
	proto.RegisterType((*RaftMessageRequest)(nil), "cockroach.kv.kvserver.kvserverpb.RaftMessageRequest")
	proto.RegisterType((*RaftMessageRequestBatch)(nil), "cockroach.kv.kvserver.kvserverpb.RaftMessageRequestBatch")
	proto.RegisterType((*RaftMessageResponseUnion)(nil), "cockroach.kv.kvserver.kvserverpb.RaftMessageResponseUnion")
	proto.RegisterType((*RaftMessageResponse)(nil), "cockroach.kv.kvserver.kvserverpb.RaftMessageResponse")
	proto.RegisterType((*SnapshotRequest)(nil), "cockroach.kv.kvserver.kvserverpb.SnapshotRequest")
	proto.RegisterType((*SnapshotRequest_Header)(nil), "cockroach.kv.kvserver.kvserverpb.SnapshotRequest.Header")
	proto.RegisterType((*SnapshotRequest_SharedTable)(nil), "cockroach.kv.kvserver.kvserverpb.SnapshotRequest.SharedTable")
	proto.RegisterType((*SnapshotRequest_SharedTable_InternalKey)(nil), "cockroach.kv.kvserver.kvserverpb.SnapshotRequest.SharedTable.InternalKey")
	proto.RegisterType((*SnapshotRequest_ExternalTable)(nil), "cockroach.kv.kvserver.kvserverpb.SnapshotRequest.ExternalTable")
	proto.RegisterType((*SnapshotResponse)(nil), "cockroach.kv.kvserver.kvserverpb.SnapshotResponse")
	proto.RegisterType((*DelegateSnapshotRequest)(nil), "cockroach.kv.kvserver.kvserverpb.DelegateSnapshotRequest")
	proto.RegisterType((*DelegateSendSnapshotRequest)(nil), "cockroach.kv.kvserver.kvserverpb.DelegateSendSnapshotRequest")
	proto.RegisterType((*DelegateSnapshotResponse)(nil), "cockroach.kv.kvserver.kvserverpb.DelegateSnapshotResponse")
	proto.RegisterType((*ConfChangeContext)(nil), "cockroach.kv.kvserver.kvserverpb.ConfChangeContext")
}

func init() { proto.RegisterFile("kv/kvserver/kvserverpb/raft.proto", fileDescriptor_755441ac72dfaa3b) }

var fileDescriptor_755441ac72dfaa3b = []byte{
	// 2248 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0xdf, 0x6e, 0xdb, 0xc8,
	0xd5, 0xb7, 0x6c, 0x4a, 0xa2, 0x8e, 0xac, 0x48, 0x9e, 0x38, 0x89, 0xe2, 0xef, 0xab, 0xe5, 0x15,
	0xda, 0x85, 0xdb, 0xee, 0xd2, 0x88, 0xb3, 0x5b, 0x74, 0x93, 0x2e, 0x5a, 0xcb, 0x56, 0x1a, 0xd9,
	0x49, 0xec, 0x8c, 0xec, 0x2c, 0xda, 0x60, 0x97, 0x18, 0x91, 0x23, 0x89, 0x35, 0x45, 0x32, 0x9c,
	0x91, 0x13, 0xe7, 0xaa, 0x0f, 0xd0, 0x8b, 0x3e, 0x42, 0x1f, 0xa4, 0x0f, 0x90, 0xcb, 0xbd, 0xe8,
	0xc5, 0xa2, 0x05, 0xdc, 0xd6, 0x29, 0xd0, 0x17, 0x28, 0x5a, 0x20, 0xbd, 0x29, 0x66, 0x38, 0xa4,
	0x68, 0x39, 0xd9, 0x58, 0xb0, 0x5d, 0xf4, 0x4a, 0xf3, 0xe7, 0xcc, 0xef, 0xcc, 0xcc, 0x39, 0xe7,
	0x77, 0xce, 0x50, 0xf0, 0xc1, 0xfe, 0xc1, 0xca, 0xfe, 0x01, 0xa3, 0xe1, 0x01, 0x0d, 0x93, 0x46,
	0xd0, 0x59, 0x09, 0x49, 0x97, 0x1b, 0x41, 0xe8, 0x73, 0x1f, 0x2d, 0x59, 0xbe, 0xb5, 0x1f, 0xfa,
	0xc4, 0xea, 0x1b, 0xfb, 0x07, 0x46, 0x2c, 0x63, 0x8c, 0x84, 0x17, 0xae, 0xd1, 0x30, 0xf4, 0x43,
	0x16, 0x74, 0x56, 0xa2, 0x46, 0xb4, 0x70, 0x61, 0x5e, 0x62, 0x8f, 0x8f, 0x5e, 0x97, 0x50, 0x41,
	0x67, 0x65, 0x40, 0x39, 0xb1, 0x09, 0x27, 0x6a, 0xdc, 0x48, 0xef, 0xc4, 0x75, 0x0e, 0xa8, 0x47,
	0x19, 0x4b, 0x1a, 0x41, 0x27, 0x69, 0x2a, 0xf9, 0xfa, 0x3b, 0x76, 0xce, 0x38, 0xe1, 0x54, 0xc9,
	0x7c, 0x7e, 0x52, 0xa6, 0xeb, 0xfa, 0xcf, 0x2d, 0xdf, 0xe3, 0xa1, 0xef, 0x9e, 0xec, 0x05, 0x9d,
	0x93, 0xfd, 0x64, 0xab, 0xa4, 0xcb, 0xe5, 0x55, 0x9c, 0xb8, 0x91, 0x85, 0xf9, 0x9e, 0xdf, 0xf3,
	0x65, 0x73, 0x45, 0xb4, 0xd4, 0xe8, 0x0f, 0x86, 0xdc, 0x71, 0x57, 0x78, 0x48, 0x2c, 0xc7, 0xeb,
	0xc5, 0xbf, 0x62, 0x21, 0xb5, 0xfc, 0xd0, 0xa6, 0xb6, 0xc9, 0x02, 0xe2, 0x45, 0xb2, 0xf5, 0xbf,
	0x65, 0xa1, 0x84, 0x49, 0x97, 0xdf, 0xa7, 0x24, 0xe4, 0x1d, 0x4a, 0x38, 0xfa, 0x0a, 0xf4, 0x90,
	0x78, 0x3d, 0x6a, 0x3a, 0x76, 0x35, 0xb3, 0x94, 0x59, 0xd6, 0x1a, 0xeb, 0xc7, 0x47, 0xb5, 0x3c,
	0x16, 0x63, 0xad, 0x8d, 0x37, 0x47, 0xb5, 0x4f, 0x7a, 0x0e, 0xef, 0x0f, 0x3b, 0x86, 0xe5, 0x0f,
	0x56, 0x12, 0x8b, 0xd8, 0x9d, 0x51, 0x7b, 0x25, 0xd8, 0xef, 0xad, 0xa8, 0xcb, 0x35, 0xd4, 0x3a,
	0x9c, 0x97, 0xa0, 0x2d, 0x1b, 0x31, 0x28, 0x77, 0x43, 0x7f, 0x60, 0x86, 0x34, 0x70, 0x1d, 0x8b,
	0x08, 0x35, 0xd3, 0x4b, 0x99, 0xe5, 0x52, 0x63, 0xeb, 0xf8, 0xa8, 0x56, 0xba, 0x17, 0xfa, 0x03,
	0x1c, 0xcd, 0x48, 0x65, 0x3f, 0x9a, 0x4c, 0x59, 0xbc, 0x12, 0x97, 0xba, 0x29, 0x20, 0x1b, 0x0d,
	0xa0, 0xc4, 0xfd, 0xb4, 0xca, 0x19, 0xa9, 0xb2, 0x75, 0x7c, 0x54, 0x2b, 0xee, 0xfa, 0x17, 0xa1,
	0xb0, 0xc8, 0xfd, 0x91, 0xba, 0x87, 0xa0, 0x71, 0x1a, 0x0e, 0xaa, 0x9a, 0xbc, 0xbf, 0xcf, 0xde,
	0x1c, 0xd5, 0x3e, 0x3d, 0x13, 0xac, 0xf2, 0x53, 0x43, 0x58, 0x64, 0x97, 0x86, 0x03, 0x2c, 0x61,
	0x10, 0x86, 0x9c, 0xe5, 0x0f, 0x06, 0x0e, 0xaf, 0x66, 0x25, 0xe0, 0x9d, 0x33, 0xef, 0x33, 0x0d,
	0xd8, 0xf2, 0x6c, 0xfa, 0x02, 0x2b, 0x24, 0x54, 0x85, 0xfc, 0xb3, 0xa1, 0x43, 0x99, 0x45, 0xab,
	0xb9, 0xa5, 0xcc, 0xb2, 0x8e, 0xe3, 0x2e, 0x7a, 0x09, 0xff, 0xef, 0x92, 0x5e, 0xcf, 0xf1, 0x7a,
	0x66, 0xd7, 0x77, 0x5d, 0xff, 0x39, 0x0d, 0x99, 0xe9, 0x7b, 0x66, 0x2c, 0xae, 0x2f, 0xcd, 0x2c,
	0x17, 0x57, 0x6f, 0x1b, 0x6f, 0x8f, 0xc6, 0x24, 0x38, 0x46, 0x01, 0x63, 0x3c, 0x50, 0xcd, 0x86,
	0xf6, 0xea, 0xa8, 0x36, 0x85, 0x6f, 0x2a, 0xf8, 0x7b, 0x31, 0xfa, 0xb6, 0xf7, 0x58, 0xe9, 0xde,
	0x81, 0xef, 0x7d, 0x9b, 0x6e, 0x93, 0x58, 0xd6, 0x30, 0x24, 0x9c, 0x56, 0x41, 0xee, 0xf9, 0x83,
	0x77, 0x22, 0xad, 0x29, 0xc1, 0x4d, 0x4d, 0xcf, 0x57, 0xf4, 0xfa, 0xaf, 0xf3, 0x80, 0xc4, 0x1d,
	0x3c, 0xa4, 0x8c, 0x91, 0x1e, 0xc5, 0xf4, 0xd9, 0x90, 0xb2, 0xcb, 0xf7, 0xf5, 0x2f, 0xa1, 0x1c,
	0xe1, 0x33, 0x4e, 0x42, 0x6e, 0xee, 0xd3, 0xc3, 0xaa, 0xbe, 0x94, 0x59, 0x9e, 0x6d, 0x7c, 0xfa,
	0xe6, 0xa8, 0x76, 0x6b, 0x32, 0xec, 0x2d, 0x7a, 0x88, 0x4b, 0x12, 0xad, 0x2d, 0xc0, 0xb6, 0xe8,
	0x21, 0x7a, 0x08, 0xb3, 0xe9, 0x50, 0x92, 0x71, 0x54, 0x5c, 0xfd, 0x6e, 0xca, 0x32, 0x63, 0x7e,
	0xba, 0x41, 0x99, 0x15, 0x3a, 0x01, 0xf7, 0x43, 0x65, 0x8a, 0x62, 0x2a, 0x4c, 0x50, 0x0b, 0x60,
	0x14, 0x24, 0x32, 0x42, 0x26, 0x03, 0x2b, 0x24, 0x21, 0x80, 0x56, 0x20, 0x3f, 0x88, 0xae, 0x5a,
	0xc6, 0x40, 0x71, 0xb5, 0x6c, 0x44, 0xec, 0x65, 0x28, 0x0b, 0xa8, 0x25, 0xb1, 0x54, 0xda, 0x1d,
	0xb3, 0x93, 0xb9, 0x63, 0xe1, 0x12, 0xdd, 0x71, 0x0f, 0xa0, 0x1f, 0x13, 0x23, 0xab, 0xe6, 0xa4,
	0xa6, 0x15, 0xe3, 0x7d, 0x69, 0xc8, 0x38, 0x41, 0xa8, 0x4a, 0x4b, 0x0a, 0x08, 0x7d, 0x05, 0xe5,
	0xa4, 0x67, 0x86, 0x94, 0x05, 0xac, 0x9a, 0x3f, 0x0f, 0xf6, 0x95, 0x04, 0x0d, 0x0b, 0x30, 0xf4,
	0x9b, 0x0c, 0xdc, 0x24, 0xf6, 0xc0, 0xe1, 0x9c, 0xda, 0xa6, 0xb8, 0x77, 0xd3, 0xf5, 0x7b, 0x26,
	0xf5, 0x78, 0xe8, 0x50, 0x56, 0x2d, 0x4a, 0x55, 0x5b, 0xef, 0x54, 0x95, 0x4e, 0x3f, 0x63, 0xc9,
	0xc9, 0x58, 0x53, 0xa8, 0x62, 0x17, 0x0f, 0xfc, 0x5e, 0x33, 0x82, 0x54, 0xdb, 0xb8, 0x4e, 0xde,
	0x3a, 0xbb, 0xa9, 0xe9, 0x50, 0x29, 0xd6, 0xff, 0x90, 0x81, 0x1b, 0xa7, 0x43, 0xb0, 0x41, 0xb8,
	0xd5, 0x47, 0x4f, 0x40, 0x0f, 0xa3, 0x3e, 0xab, 0x66, 0xe4, 0xf6, 0x3e, 0x39, 0xdb, 0x4d, 0x8c,
	0x81, 0x45, 0xfb, 0x48, 0xb0, 0x10, 0x81, 0x02, 0xe3, 0x7e, 0x28, 0xe2, 0x9b, 0x55, 0xa7, 0x97,
	0x66, 0x96, 0xb5, 0xc6, 0xc6, 0xf1, 0x51, 0x4d, 0x6f, 0x8b, 0xc1, 0xd6, 0x06, 0x9b, 0x38, 0xc2,
	0xd5, 0x42, 0xac, 0x4b, 0xd8, 0x96, 0xcd, 0xea, 0x3b, 0x50, 0x3d, 0xb1, 0x11, 0x16, 0xf8, 0x1e,
	0xa3, 0x7b, 0x9e, 0xe3, 0x7b, 0xc8, 0x80, 0xac, 0xac, 0x38, 0x24, 0xb7, 0x14, 0x57, 0xab, 0xe3,
	0x67, 0x0a, 0x3a, 0x46, 0x53, 0xcc, 0xe3, 0x48, 0xec, 0x8e, 0xf6, 0xea, 0x77, 0xb5, 0x4c, 0xfd,
	0xef, 0xd3, 0x70, 0xf5, 0x2d, 0x90, 0x97, 0x4e, 0x56, 0xff, 0xbb, 0x6c, 0xf2, 0x04, 0xb2, 0x43,
	0x71, 0xa1, 0x8a, 0x4b, 0xee, 0x4c, 0xe8, 0x1b, 0x29, 0x93, 0x28, 0xec, 0x08, 0xae, 0xfe, 0xaf,
	0x39, 0x28, 0xb7, 0x3d, 0x12, 0xb0, 0xbe, 0xcf, 0xe3, 0x94, 0xb0, 0x03, 0xb9, 0x3e, 0x25, 0x36,
	0x8d, 0x8d, 0xf6, 0xe3, 0xf7, 0x2b, 0x1b, 0x83, 0x30, 0xee, 0xcb, 0xf5, 0x58, 0xe1, 0xa0, 0x0f,
	0x41, 0xdf, 0x3f, 0x30, 0x3b, 0xc2, 0xd1, 0xe5, 0x9d, 0xce, 0x36, 0x8a, 0xc2, 0x6e, 0x5b, 0x4f,
	0xa4, 0xef, 0xe3, 0xfc, 0xfe, 0x41, 0x14, 0x04, 0xf3, 0x90, 0xed, 0x3a, 0x1e, 0x71, 0xe5, 0x29,
	0x75, 0x1c, 0x75, 0x50, 0x1f, 0x4a, 0xac, 0x4f, 0x42, 0x6a, 0x9b, 0x9c, 0x74, 0x5c, 0xca, 0xaa,
	0x59, 0x19, 0x1f, 0x9f, 0x4f, 0xbe, 0xad, 0xb6, 0x84, 0xd9, 0x15, 0x28, 0xea, 0x1a, 0x66, 0xd9,
	0x68, 0x88, 0xa1, 0xa7, 0xf0, 0x43, 0x1e, 0x12, 0x8f, 0x39, 0xdc, 0xf1, 0x3d, 0x53, 0xba, 0x42,
	0xac, 0x59, 0xd8, 0xb1, 0x37, 0x74, 0x49, 0x18, 0xdb, 0x93, 0xc7, 0x55, 0xc3, 0x87, 0xa3, 0x25,
	0xa2, 0x74, 0x53, 0x3a, 0x7c, 0x1c, 0x89, 0xe3, 0x58, 0x1a, 0x79, 0x50, 0xa6, 0x2f, 0x38, 0x0d,
	0x3d, 0xe2, 0xc6, 0x07, 0x89, 0x28, 0xef, 0xa7, 0x93, 0x1f, 0xa4, 0xa9, 0x80, 0xd2, 0x47, 0xb9,
	0x42, 0xd3, 0x83, 0x6c, 0xe1, 0xdf, 0x33, 0x90, 0x8b, 0xec, 0x80, 0x5a, 0x90, 0x95, 0xa5, 0xb8,
	0x4c, 0x2c, 0xc5, 0xd5, 0x8f, 0xdf, 0xa1, 0x50, 0x44, 0x34, 0xe9, 0xd1, 0x91, 0x47, 0xb6, 0xc5,
	0xa2, 0xd8, 0x61, 0x24, 0x02, 0x72, 0x61, 0x5e, 0xd2, 0xa9, 0xca, 0x5a, 0xa6, 0x22, 0x1a, 0x15,
	0x2a, 0xe7, 0xe1, 0x2c, 0x14, 0x9e, 0xae, 0x4e, 0xbe, 0x03, 0xa0, 0xaa, 0x07, 0xe7, 0x25, 0x95,
	0x11, 0x34, 0x83, 0x0b, 0x51, 0x05, 0xe0, 0xbc, 0xa4, 0xa8, 0x07, 0x73, 0x8c, 0x7a, 0x36, 0x0d,
	0xcd, 0x67, 0x43, 0x3a, 0xa4, 0xa6, 0x47, 0x06, 0x51, 0x5d, 0x74, 0x65, 0xf5, 0xee, 0xe4, 0x97,
	0xfa, 0x58, 0x60, 0x3c, 0x22, 0x03, 0x8a, 0xcb, 0x11, 0x6a, 0x32, 0x80, 0x56, 0xe1, 0xda, 0x09,
	0x45, 0x41, 0xe8, 0xf8, 0xa1, 0xc3, 0x0f, 0xab, 0xc5, 0xa5, 0xcc, 0x72, 0x06, 0x5f, 0x4d, 0xc9,
	0xef, 0xa8, 0x29, 0xf4, 0x7d, 0xa8, 0x28, 0xe7, 0x19, 0x79, 0xcc, 0xac, 0xf4, 0x98, 0x72, 0x34,
	0x3e, 0x72, 0x8d, 0x8f, 0x01, 0x25, 0xae, 0x31, 0x12, 0x2e, 0x49, 0xe1, 0xb9, 0x78, 0x26, 0x11,
	0xdf, 0xd4, 0xf4, 0x4c, 0x65, 0x7a, 0x53, 0xd3, 0xb5, 0x4a, 0x76, 0x53, 0xd3, 0x73, 0x95, 0x7c,
	0x54, 0xe2, 0x6d, 0x6a, 0xba, 0x5e, 0x29, 0x6c, 0x6a, 0x7a, 0xa1, 0x02, 0x0b, 0x7f, 0xca, 0x41,
	0x31, 0xe5, 0xee, 0xa2, 0xba, 0xe8, 0x10, 0x6b, 0xdf, 0xf1, 0x7a, 0x32, 0xaa, 0x67, 0x71, 0xdc,
	0x15, 0x33, 0xae, 0x6f, 0x11, 0xee, 0x87, 0x51, 0x6c, 0xe2, 0xb8, 0x8b, 0x28, 0xe8, 0x6c, 0x40,
	0x5c, 0x57, 0xd8, 0x37, 0x62, 0xaf, 0xd6, 0xb9, 0x62, 0xce, 0x68, 0x79, 0xd1, 0x51, 0x44, 0x21,
	0x97, 0x40, 0x23, 0x0b, 0xf2, 0x2e, 0x09, 0x7b, 0x42, 0x8b, 0x76, 0xd1, 0x5a, 0x62, 0x64, 0xf4,
	0x1c, 0x50, 0xac, 0xd0, 0x8c, 0x5c, 0x4a, 0x94, 0xa2, 0xd9, 0x8b, 0xd6, 0x57, 0x89, 0x95, 0xc8,
	0xdc, 0x22, 0x2a, 0xd4, 0x21, 0xcc, 0xa9, 0x3d, 0xa4, 0xf4, 0xe6, 0x2e, 0x5a, 0x6f, 0x59, 0xe9,
	0x48, 0xd4, 0xa6, 0xcf, 0x1b, 0xf8, 0x8e, 0x17, 0x95, 0xde, 0xf9, 0x4b, 0x3b, 0xef, 0x8e, 0xd0,
	0x31, 0x76, 0xde, 0x91, 0x5e, 0xfd, 0xb2, 0xce, 0x9b, 0xa8, 0x9d, 0x87, 0xac, 0x4b, 0x0f, 0xa8,
	0x5b, 0x2d, 0x2c, 0x65, 0x96, 0xb3, 0x38, 0xea, 0x20, 0x04, 0x9a, 0x64, 0x0e, 0xc1, 0x09, 0x1a,
	0x96, 0xed, 0x85, 0x06, 0x14, 0x53, 0x48, 0xe8, 0x26, 0xe8, 0x43, 0x46, 0x43, 0xb9, 0x4d, 0x15,
	0x19, 0xa2, 0x2f, 0xa6, 0xaa, 0x90, 0xe7, 0x21, 0x71, 0x5c, 0x1a, 0x45, 0x86, 0x86, 0xe3, 0xee,
	0xc2, 0x3f, 0xa6, 0xa1, 0x74, 0x82, 0x83, 0xd3, 0x51, 0x94, 0x39, 0x19, 0x45, 0x35, 0x28, 0xfa,
	0x9d, 0x5f, 0x51, 0x8b, 0x47, 0xf4, 0x24, 0x90, 0x0a, 0x18, 0xa2, 0x21, 0x49, 0x2e, 0xf1, 0x26,
	0x67, 0x46, 0x9b, 0x44, 0x0b, 0xa0, 0xc7, 0x6f, 0x1c, 0x19, 0x14, 0xb3, 0x38, 0xe9, 0xa3, 0xeb,
	0x90, 0x6b, 0x7a, 0xf6, 0x96, 0x72, 0xdf, 0x59, 0xac, 0x7a, 0xe8, 0x23, 0x98, 0x8b, 0x5a, 0x2d,
	0xd6, 0xf2, 0x2c, 0x77, 0xc8, 0x9c, 0x83, 0x38, 0x47, 0x9d, 0x9e, 0x40, 0x75, 0x28, 0xf5, 0x09,
	0x1b, 0xf3, 0x0d, 0x1d, 0x17, 0xfb, 0x84, 0x25, 0x97, 0xaa, 0x64, 0x46, 0x7e, 0xab, 0x27, 0x32,
	0x89, 0xa3, 0x09, 0x9a, 0x3b, 0xf4, 0x78, 0x9f, 0x72, 0xc7, 0x32, 0x83, 0x90, 0x76, 0x9d, 0x17,
	0xd2, 0x06, 0xb3, 0xb8, 0x9c, 0x8c, 0xef, 0xc8, 0xe1, 0x93, 0xa2, 0x6c, 0xd8, 0x15, 0xa2, 0x30,
	0x26, 0xda, 0x96, 0xc3, 0x23, 0x73, 0x16, 0x53, 0xe6, 0xac, 0x6f, 0x40, 0x61, 0xc4, 0xc9, 0x05,
	0xc8, 0x6e, 0xef, 0xde, 0x6f, 0xe2, 0xca, 0x14, 0xba, 0x0a, 0x65, 0xdc, 0xdc, 0x79, 0xd0, 0x5a,
	0x5f, 0xdb, 0x6d, 0x9a, 0x8f, 0xf7, 0x9a, 0x7b, 0xcd, 0x4a, 0x06, 0xdd, 0x80, 0xab, 0x78, 0xed,
	0xde, 0xae, 0xd9, 0x7e, 0xb4, 0xb6, 0xd3, 0xbe, 0xbf, 0xbd, 0xab, 0x26, 0x04, 0x71, 0xce, 0x54,
	0xb4, 0xfa, 0xef, 0x67, 0xa0, 0x32, 0xf2, 0x36, 0x55, 0x60, 0x3e, 0x86, 0x9c, 0x48, 0x73, 0x43,
	0x26, 0x8d, 0x78, 0x65, 0xf5, 0xb3, 0x49, 0x3c, 0x36, 0xc2, 0x30, 0xda, 0x12, 0x00, 0x2b, 0x20,
	0xc1, 0xed, 0x36, 0x0d, 0x42, 0x2a, 0x98, 0xdb, 0x8e, 0xd3, 0xa6, 0xf2, 0x82, 0xb9, 0xd1, 0x8c,
	0x4a, 0x7c, 0xe2, 0xbd, 0x6c, 0xf9, 0xae, 0x4b, 0x2d, 0xae, 0xbe, 0x52, 0xb1, 0xaa, 0x26, 0xab,
	0x04, 0x23, 0xb5, 0x95, 0x21, 0x77, 0x5c, 0x43, 0x7d, 0xd5, 0x32, 0x92, 0xaf, 0x5b, 0x06, 0x56,
	0x5f, 0xb7, 0xda, 0x01, 0x89, 0xcb, 0xbc, 0x2b, 0x09, 0x98, 0x18, 0x64, 0x68, 0x0b, 0x4a, 0xd4,
	0xb3, 0x7c, 0x9b, 0xda, 0x66, 0x54, 0x97, 0x47, 0x0c, 0xb8, 0x94, 0x02, 0x8f, 0x3f, 0x20, 0x1a,
	0xcd, 0x48, 0x50, 0xd6, 0xe7, 0x71, 0xb9, 0x44, 0x53, 0x63, 0xe8, 0x16, 0xcc, 0x0e, 0x58, 0xcf,
	0x24, 0x41, 0x20, 0x9f, 0x70, 0x8a, 0xd5, 0xc6, 0xdf, 0xb9, 0x18, 0x06, 0xac, 0xb7, 0x16, 0x04,
	0xe2, 0x82, 0xea, 0x6b, 0x90, 0x8b, 0xee, 0x07, 0x15, 0x21, 0xbf, 0xf7, 0x68, 0xeb, 0xd1, 0xf6,
	0x17, 0x8f, 0x2a, 0x53, 0x68, 0x16, 0xf4, 0xb5, 0xf5, 0xf5, 0xe6, 0xce, 0x6e, 0x73, 0xa3, 0x92,
	0x11, 0x53, 0x6b, 0x3b, 0x3b, 0x0f, 0x5a, 0xcd, 0x8d, 0xca, 0xb4, 0x30, 0x73, 0x13, 0xe3, 0x6d,
	0x5c, 0x99, 0xa9, 0x8b, 0x8c, 0xa7, 0x29, 0xf3, 0x3d, 0x87, 0x1b, 0x1b, 0xd4, 0xa5, 0x3d, 0xc2,
	0xe9, 0x78, 0xfd, 0xda, 0x06, 0x4d, 0xe4, 0x63, 0x55, 0xbd, 0x9e, 0xa1, 0x4c, 0x4c, 0x80, 0xa8,
	0x67, 0x8f, 0x81, 0xdd, 0x9f, 0xc2, 0x12, 0xac, 0x91, 0x87, 0xec, 0x01, 0x71, 0x87, 0xb4, 0xfe,
	0xe7, 0x3c, 0xfc, 0xdf, 0xb7, 0x2c, 0xb8, 0xf4, 0x37, 0xca, 0x53, 0xb8, 0x6a, 0xf9, 0x7e, 0x68,
	0x3b, 0x9e, 0x60, 0x97, 0x73, 0x3c, 0x55, 0x50, 0x0a, 0x26, 0x7e, 0x66, 0x7c, 0x01, 0x73, 0x21,
	0xb5, 0x9c, 0xc0, 0xa1, 0x1e, 0x3f, 0xc7, 0xc3, 0xa5, 0x92, 0x80, 0xc4, 0xc0, 0x7b, 0x50, 0xb1,
	0xd5, 0xa5, 0xd9, 0x66, 0x54, 0x2d, 0xa9, 0x64, 0x3f, 0x09, 0x6e, 0x39, 0xc1, 0x68, 0x4b, 0x88,
	0xe4, 0x2b, 0x63, 0xfe, 0x62, 0xbe, 0x32, 0x3e, 0x85, 0x62, 0xd7, 0x09, 0x19, 0x37, 0x1d, 0xcf,
	0xa6, 0x2f, 0x24, 0xdb, 0x9d, 0xef, 0x53, 0x23, 0x48, 0x38, 0xd9, 0x7e, 0x7b, 0xb1, 0x5a, 0xf8,
	0x6f, 0x16, 0xab, 0xf0, 0xee, 0x62, 0x75, 0x08, 0xd7, 0xec, 0xe4, 0xb6, 0xcd, 0x1e, 0xf5, 0x68,
	0x48, 0xc4, 0x8b, 0x46, 0xf2, 0xaf, 0xd6, 0xf8, 0xd9, 0x9b, 0xa3, 0xda, 0x4f, 0x26, 0xf7, 0xdb,
	0x9f, 0x27, 0x38, 0x78, 0x7e, 0x04, 0x3f, 0x1a, 0x45, 0xb7, 0xe0, 0x5a, 0xb4, 0x47, 0xdf, 0x33,
	0x63, 0xdb, 0x9a, 0x2e, 0xf5, 0x64, 0xa1, 0x3c, 0x83, 0x91, 0x9c, 0xdc, 0xf6, 0xe2, 0x78, 0x7b,
	0x40, 0x3d, 0xb4, 0x0b, 0x79, 0xe6, 0x91, 0x40, 0x84, 0x57, 0x49, 0x3e, 0x25, 0xef, 0x0a, 0xd7,
	0xf8, 0xe3, 0x51, 0xed, 0xf6, 0x99, 0xf6, 0x27, 0xff, 0x18, 0x18, 0x0e, 0x1d, 0xdb, 0xd8, 0xdb,
	0x6b, 0x6d, 0xe0, 0x9c, 0xc0, 0x6a, 0xd9, 0x9b, 0x9a, 0x9e, 0xad, 0xe4, 0xa2, 0x62, 0xba, 0xfe,
	0xcf, 0x69, 0xa8, 0x9e, 0xe6, 0x16, 0x95, 0x21, 0x7e, 0x31, 0x96, 0x21, 0xd6, 0x26, 0xa0, 0x97,
	0xf7, 0x64, 0x8a, 0x53, 0xdc, 0x3c, 0x7d, 0x0e, 0x6e, 0x7e, 0x4b, 0x1e, 0x99, 0xb9, 0xc0, 0x3c,
	0x32, 0x4e, 0xfd, 0xda, 0xfb, 0xa9, 0x7f, 0x29, 0xa1, 0xfe, 0x84, 0xd2, 0xa7, 0xd2, 0x54, 0x9f,
	0xa9, 0x3f, 0x85, 0xb9, 0x75, 0xdf, 0xeb, 0xae, 0xf7, 0x85, 0xef, 0xac, 0xfb, 0x1e, 0xa7, 0x2f,
	0x38, 0xfa, 0x08, 0xc0, 0xf2, 0x07, 0x03, 0xe2, 0xd9, 0x31, 0xa3, 0x16, 0x1a, 0xa5, 0xe3, 0xa3,
	0x5a, 0x61, 0x3d, 0x1a, 0x6d, 0x6d, 0xe0, 0x82, 0x12, 0x68, 0xd9, 0xa2, 0x0c, 0x0b, 0xc8, 0xa1,
	0xeb, 0x13, 0x3b, 0x7e, 0xcc, 0xa8, 0x6e, 0xe3, 0xcb, 0x57, 0x7f, 0x5d, 0x9c, 0x7a, 0x75, 0xbc,
	0x98, 0xf9, 0xfa, 0x78, 0x31, 0xf3, 0xcd, 0xf1, 0x62, 0xe6, 0x2f, 0xc7, 0x8b, 0x99, 0xdf, 0xbe,
	0x5e, 0x9c, 0xfa, 0xfa, 0xf5, 0xe2, 0xd4, 0x37, 0xaf, 0x17, 0xa7, 0x7e, 0x79, 0xf7, 0xec, 0x41,
	0x7e, 0xea, 0xaf, 0xae, 0x4e, 0x4e, 0xfe, 0x99, 0x74, 0xfb, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff,
	0x61, 0xc4, 0xfd, 0x7a, 0xc5, 0x1b, 0x00, 0x00,
}

func (m *RaftHeartbeat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftHeartbeat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftHeartbeat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LaggingFollowersOnQuiesceAccurate {
		i--
		if m.LaggingFollowersOnQuiesceAccurate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.LaggingFollowersOnQuiesce) > 0 {
		for iNdEx := len(m.LaggingFollowersOnQuiesce) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LaggingFollowersOnQuiesce[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Quiesce {
		i--
		if m.Quiesce {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Commit != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Commit))
		i--
		dAtA[i] = 0x28
	}
	if m.Term != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x20
	}
	if m.ToReplicaID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.ToReplicaID))
		i--
		dAtA[i] = 0x18
	}
	if m.FromReplicaID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.FromReplicaID))
		i--
		dAtA[i] = 0x10
	}
	if m.RangeID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RaftMessageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftMessageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftMessageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AdmittedRaftLogEntries) > 0 {
		for iNdEx := len(m.AdmittedRaftLogEntries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AdmittedRaftLogEntries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.LaggingFollowersOnQuiesce) > 0 {
		for iNdEx := len(m.LaggingFollowersOnQuiesce) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LaggingFollowersOnQuiesce[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.RangeStartKey) > 0 {
		i -= len(m.RangeStartKey)
		copy(dAtA[i:], m.RangeStartKey)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.RangeStartKey)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.HeartbeatResps) > 0 {
		for iNdEx := len(m.HeartbeatResps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HeartbeatResps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Heartbeats) > 0 {
		for iNdEx := len(m.Heartbeats) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Heartbeats[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Quiesce {
		i--
		if m.Quiesce {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.ToReplica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.FromReplica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.RangeID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RaftMessageRequestBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftMessageRequestBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftMessageRequestBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StoreIDs) > 0 {
		dAtA5 := make([]byte, len(m.StoreIDs)*10)
		var j4 int
		for _, num := range m.StoreIDs {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintRaft(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Requests) > 0 {
		for iNdEx := len(m.Requests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Requests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RaftMessageResponseUnion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftMessageResponseUnion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftMessageResponseUnion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftMessageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftMessageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftMessageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Union.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.ToReplica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.FromReplica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.RangeID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExternalTables) > 0 {
		for iNdEx := len(m.ExternalTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExternalTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.TransitionFromSharedToRegularReplicate {
		i--
		if m.TransitionFromSharedToRegularReplicate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.SharedTables) > 0 {
		for iNdEx := len(m.SharedTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SharedTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Final {
		i--
		if m.Final {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.KVBatch) > 0 {
		i -= len(m.KVBatch)
		copy(dAtA[i:], m.KVBatch)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.KVBatch)))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotRequest_Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotRequest_Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotRequest_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExternalReplicate {
		i--
		if m.ExternalReplicate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.SharedReplicate {
		i--
		if m.SharedReplicate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.SenderQueuePriority != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SenderQueuePriority))))
		i--
		dAtA[i] = 0x59
	}
	if m.SenderQueueName != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.SenderQueueName))
		i--
		dAtA[i] = 0x50
	}
	{
		size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.RangeSize != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.RangeSize))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.RaftMessageRequest.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}

func (m *SnapshotRequest_SharedTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotRequest_SharedTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotRequest_SharedTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Size_ != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x50
	}
	if m.Level != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x48
	}
	if m.LargestPointKey != nil {
		{
			size, err := m.LargestPointKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.SmallestPointKey != nil {
		{
			size, err := m.SmallestPointKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.LargestRangeKey != nil {
		{
			size, err := m.LargestRangeKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.SmallestRangeKey != nil {
		{
			size, err := m.SmallestRangeKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Largest != nil {
		{
			size, err := m.Largest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Smallest != nil {
		{
			size, err := m.Smallest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Locator) > 0 {
		i -= len(m.Locator)
		copy(dAtA[i:], m.Locator)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Locator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Backing) > 0 {
		i -= len(m.Backing)
		copy(dAtA[i:], m.Backing)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Backing)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotRequest_SharedTable_InternalKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotRequest_SharedTable_InternalKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotRequest_SharedTable_InternalKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Trailer != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Trailer))
		i--
		dAtA[i] = 0x10
	}
	if len(m.UserKey) > 0 {
		i -= len(m.UserKey)
		copy(dAtA[i:], m.UserKey)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.UserKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotRequest_ExternalTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotRequest_ExternalTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotRequest_ExternalTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x58
	}
	if len(m.SyntheticSuffix) > 0 {
		i -= len(m.SyntheticSuffix)
		copy(dAtA[i:], m.SyntheticSuffix)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.SyntheticSuffix)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.SyntheticPrefix) > 0 {
		i -= len(m.SyntheticPrefix)
		copy(dAtA[i:], m.SyntheticPrefix)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.SyntheticPrefix)))
		i--
		dAtA[i] = 0x4a
	}
	if m.HasRangeKey {
		i--
		if m.HasRangeKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.HasPointKey {
		i--
		if m.HasPointKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.EndKeyIsInclusive {
		i--
		if m.EndKeyIsInclusive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.Size_ != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ObjectName) > 0 {
		i -= len(m.ObjectName)
		copy(dAtA[i:], m.ObjectName)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.ObjectName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Locator) > 0 {
		i -= len(m.Locator)
		copy(dAtA[i:], m.Locator)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Locator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MsgAppResp != nil {
		{
			size, err := m.MsgAppResp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	{
		size, err := m.EncodedError.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.CollectedSpans) > 0 {
		for iNdEx := len(m.CollectedSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectedSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DeprecatedMessage) > 0 {
		i -= len(m.DeprecatedMessage)
		copy(dAtA[i:], m.DeprecatedMessage)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.DeprecatedMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DelegateSnapshotRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegateSnapshotRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegateSnapshotRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DelegateSnapshotRequest_Send) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegateSnapshotRequest_Send) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Send != nil {
		{
			size, err := m.Send.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DelegateSendSnapshotRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegateSendSnapshotRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegateSendSnapshotRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SnapId.Size()
		i -= size
		if _, err := m.SnapId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	if m.QueueOnDelegateLen != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.QueueOnDelegateLen))
		i--
		dAtA[i] = 0x60
	}
	if m.DescriptorGeneration != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.DescriptorGeneration))
		i--
		dAtA[i] = 0x58
	}
	if m.SenderQueuePriority != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SenderQueuePriority))))
		i--
		dAtA[i] = 0x51
	}
	if m.SenderQueueName != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.SenderQueueName))
		i--
		dAtA[i] = 0x48
	}
	if m.FirstIndex != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.FirstIndex))
		i--
		dAtA[i] = 0x40
	}
	if m.Term != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x38
	}
	{
		size, err := m.DelegatedSender.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.RecipientReplica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.CoordinatorReplica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.RangeID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.RangeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DelegateSnapshotResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegateSnapshotResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegateSnapshotResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MsgAppResp != nil {
		{
			size, err := m.MsgAppResp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.CollectedSpans) > 0 {
		for iNdEx := len(m.CollectedSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectedSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.EncodedError.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Status != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConfChangeContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfChangeContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfChangeContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CommandID) > 0 {
		i -= len(m.CommandID)
		copy(dAtA[i:], m.CommandID)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.CommandID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintRaft(dAtA []byte, offset int, v uint64) int {
	offset -= sovRaft(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RaftHeartbeat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovRaft(uint64(m.RangeID))
	}
	if m.FromReplicaID != 0 {
		n += 1 + sovRaft(uint64(m.FromReplicaID))
	}
	if m.ToReplicaID != 0 {
		n += 1 + sovRaft(uint64(m.ToReplicaID))
	}
	if m.Term != 0 {
		n += 1 + sovRaft(uint64(m.Term))
	}
	if m.Commit != 0 {
		n += 1 + sovRaft(uint64(m.Commit))
	}
	if m.Quiesce {
		n += 2
	}
	if len(m.LaggingFollowersOnQuiesce) > 0 {
		for _, e := range m.LaggingFollowersOnQuiesce {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	if m.LaggingFollowersOnQuiesceAccurate {
		n += 2
	}
	return n
}

func (m *RaftMessageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovRaft(uint64(m.RangeID))
	}
	l = m.FromReplica.Size()
	n += 1 + l + sovRaft(uint64(l))
	l = m.ToReplica.Size()
	n += 1 + l + sovRaft(uint64(l))
	l = m.Message.Size()
	n += 1 + l + sovRaft(uint64(l))
	if m.Quiesce {
		n += 2
	}
	if len(m.Heartbeats) > 0 {
		for _, e := range m.Heartbeats {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	if len(m.HeartbeatResps) > 0 {
		for _, e := range m.HeartbeatResps {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	l = len(m.RangeStartKey)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	if len(m.LaggingFollowersOnQuiesce) > 0 {
		for _, e := range m.LaggingFollowersOnQuiesce {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	if len(m.AdmittedRaftLogEntries) > 0 {
		for _, e := range m.AdmittedRaftLogEntries {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	return n
}

func (m *RaftMessageRequestBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	if len(m.StoreIDs) > 0 {
		l = 0
		for _, e := range m.StoreIDs {
			l += sovRaft(uint64(e))
		}
		n += 1 + sovRaft(uint64(l)) + l
	}
	return n
}

func (m *RaftMessageResponseUnion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}

func (m *RaftMessageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovRaft(uint64(m.RangeID))
	}
	l = m.FromReplica.Size()
	n += 1 + l + sovRaft(uint64(l))
	l = m.ToReplica.Size()
	n += 1 + l + sovRaft(uint64(l))
	l = m.Union.Size()
	n += 1 + l + sovRaft(uint64(l))
	return n
}

func (m *SnapshotRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	l = len(m.KVBatch)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.Final {
		n += 2
	}
	if len(m.SharedTables) > 0 {
		for _, e := range m.SharedTables {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	if m.TransitionFromSharedToRegularReplicate {
		n += 2
	}
	if len(m.ExternalTables) > 0 {
		for _, e := range m.ExternalTables {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	return n
}

func (m *SnapshotRequest_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RaftMessageRequest.Size()
	n += 1 + l + sovRaft(uint64(l))
	if m.RangeSize != 0 {
		n += 1 + sovRaft(uint64(m.RangeSize))
	}
	l = m.State.Size()
	n += 1 + l + sovRaft(uint64(l))
	if m.SenderQueueName != 0 {
		n += 1 + sovRaft(uint64(m.SenderQueueName))
	}
	if m.SenderQueuePriority != 0 {
		n += 9
	}
	if m.SharedReplicate {
		n += 2
	}
	if m.ExternalReplicate {
		n += 2
	}
	return n
}

func (m *SnapshotRequest_SharedTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Backing)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	l = len(m.Locator)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.Smallest != nil {
		l = m.Smallest.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.Largest != nil {
		l = m.Largest.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.SmallestRangeKey != nil {
		l = m.SmallestRangeKey.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.LargestRangeKey != nil {
		l = m.LargestRangeKey.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.SmallestPointKey != nil {
		l = m.SmallestPointKey.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.LargestPointKey != nil {
		l = m.LargestPointKey.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovRaft(uint64(m.Level))
	}
	if m.Size_ != 0 {
		n += 1 + sovRaft(uint64(m.Size_))
	}
	return n
}

func (m *SnapshotRequest_SharedTable_InternalKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserKey)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.Trailer != 0 {
		n += 1 + sovRaft(uint64(m.Trailer))
	}
	return n
}

func (m *SnapshotRequest_ExternalTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Locator)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	l = len(m.ObjectName)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovRaft(uint64(m.Size_))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.EndKeyIsInclusive {
		n += 2
	}
	if m.HasPointKey {
		n += 2
	}
	if m.HasRangeKey {
		n += 2
	}
	l = len(m.SyntheticPrefix)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	l = len(m.SyntheticSuffix)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovRaft(uint64(m.Level))
	}
	return n
}

func (m *SnapshotResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovRaft(uint64(m.Status))
	}
	l = len(m.DeprecatedMessage)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	if len(m.CollectedSpans) > 0 {
		for _, e := range m.CollectedSpans {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	l = m.EncodedError.Size()
	n += 1 + l + sovRaft(uint64(l))
	if m.MsgAppResp != nil {
		l = m.MsgAppResp.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}

func (m *DelegateSnapshotRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *DelegateSnapshotRequest_Send) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Send != nil {
		l = m.Send.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}
func (m *DelegateSendSnapshotRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovRaft(uint64(m.RangeID))
	}
	l = m.CoordinatorReplica.Size()
	n += 1 + l + sovRaft(uint64(l))
	l = m.RecipientReplica.Size()
	n += 1 + l + sovRaft(uint64(l))
	l = m.DelegatedSender.Size()
	n += 1 + l + sovRaft(uint64(l))
	if m.Term != 0 {
		n += 1 + sovRaft(uint64(m.Term))
	}
	if m.FirstIndex != 0 {
		n += 1 + sovRaft(uint64(m.FirstIndex))
	}
	if m.SenderQueueName != 0 {
		n += 1 + sovRaft(uint64(m.SenderQueueName))
	}
	if m.SenderQueuePriority != 0 {
		n += 9
	}
	if m.DescriptorGeneration != 0 {
		n += 1 + sovRaft(uint64(m.DescriptorGeneration))
	}
	if m.QueueOnDelegateLen != 0 {
		n += 1 + sovRaft(uint64(m.QueueOnDelegateLen))
	}
	l = m.SnapId.Size()
	n += 1 + l + sovRaft(uint64(l))
	return n
}

func (m *DelegateSnapshotResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovRaft(uint64(m.Status))
	}
	l = m.EncodedError.Size()
	n += 1 + l + sovRaft(uint64(l))
	if len(m.CollectedSpans) > 0 {
		for _, e := range m.CollectedSpans {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	if m.MsgAppResp != nil {
		l = m.MsgAppResp.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}

func (m *ConfChangeContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CommandID)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}

func sovRaft(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRaft(x uint64) (n int) {
	return sovRaft(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *RaftMessageResponseUnion) GetValue() interface{} {
	if this.Error != nil {
		return this.Error
	}
	return nil
}

func (this *RaftMessageResponseUnion) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *kvpb.Error:
		this.Error = vt
	default:
		return false
	}
	return true
}
func (m *RaftHeartbeat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftHeartbeat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftHeartbeat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromReplicaID", wireType)
			}
			m.FromReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromReplicaID |= github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToReplicaID", wireType)
			}
			m.ToReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToReplicaID |= github_com_cockroachdb_cockroach_pkg_roachpb.ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= github_com_cockroachdb_cockroach_pkg_kv_kvpb.RaftTerm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			m.Commit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commit |= github_com_cockroachdb_cockroach_pkg_kv_kvpb.RaftIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quiesce", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Quiesce = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaggingFollowersOnQuiesce", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LaggingFollowersOnQuiesce = append(m.LaggingFollowersOnQuiesce, livenesspb.Liveness{})
			if err := m.LaggingFollowersOnQuiesce[len(m.LaggingFollowersOnQuiesce)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaggingFollowersOnQuiesceAccurate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LaggingFollowersOnQuiesceAccurate = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftMessageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftMessageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftMessageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FromReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ToReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quiesce", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Quiesce = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heartbeats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Heartbeats = append(m.Heartbeats, RaftHeartbeat{})
			if err := m.Heartbeats[len(m.Heartbeats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatResps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeartbeatResps = append(m.HeartbeatResps, RaftHeartbeat{})
			if err := m.HeartbeatResps[len(m.HeartbeatResps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeStartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangeStartKey = append(m.RangeStartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.RangeStartKey == nil {
				m.RangeStartKey = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaggingFollowersOnQuiesce", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LaggingFollowersOnQuiesce = append(m.LaggingFollowersOnQuiesce, livenesspb.Liveness{})
			if err := m.LaggingFollowersOnQuiesce[len(m.LaggingFollowersOnQuiesce)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmittedRaftLogEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdmittedRaftLogEntries = append(m.AdmittedRaftLogEntries, kvflowcontrolpb.AdmittedRaftLogEntries{})
			if err := m.AdmittedRaftLogEntries[len(m.AdmittedRaftLogEntries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftMessageRequestBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftMessageRequestBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftMessageRequestBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, RaftMessageRequest{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.StoreID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StoreIDs = append(m.StoreIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRaft
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRaft
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.StoreIDs) == 0 {
					m.StoreIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.StoreID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.StoreID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StoreIDs = append(m.StoreIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftMessageResponseUnion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftMessageResponseUnion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftMessageResponseUnion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &kvpb.Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftMessageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftMessageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftMessageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FromReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ToReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Union", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Union.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &SnapshotRequest_Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KVBatch", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KVBatch = append(m.KVBatch[:0], dAtA[iNdEx:postIndex]...)
			if m.KVBatch == nil {
				m.KVBatch = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Final", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Final = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SharedTables = append(m.SharedTables, SnapshotRequest_SharedTable{})
			if err := m.SharedTables[len(m.SharedTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransitionFromSharedToRegularReplicate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TransitionFromSharedToRegularReplicate = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalTables = append(m.ExternalTables, SnapshotRequest_ExternalTable{})
			if err := m.ExternalTables[len(m.ExternalTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotRequest_Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftMessageRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RaftMessageRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeSize", wireType)
			}
			m.RangeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderQueueName", wireType)
			}
			m.SenderQueueName = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderQueueName |= SnapshotRequest_QueueName(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderQueuePriority", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SenderQueuePriority = float64(math.Float64frombits(v))
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedReplicate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SharedReplicate = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalReplicate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExternalReplicate = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotRequest_SharedTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SharedTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SharedTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backing", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Backing = append(m.Backing[:0], dAtA[iNdEx:postIndex]...)
			if m.Backing == nil {
				m.Backing = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locator", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locator = append(m.Locator[:0], dAtA[iNdEx:postIndex]...)
			if m.Locator == nil {
				m.Locator = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Smallest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Smallest == nil {
				m.Smallest = &SnapshotRequest_SharedTable_InternalKey{}
			}
			if err := m.Smallest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Largest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Largest == nil {
				m.Largest = &SnapshotRequest_SharedTable_InternalKey{}
			}
			if err := m.Largest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmallestRangeKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SmallestRangeKey == nil {
				m.SmallestRangeKey = &SnapshotRequest_SharedTable_InternalKey{}
			}
			if err := m.SmallestRangeKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LargestRangeKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LargestRangeKey == nil {
				m.LargestRangeKey = &SnapshotRequest_SharedTable_InternalKey{}
			}
			if err := m.LargestRangeKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmallestPointKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SmallestPointKey == nil {
				m.SmallestPointKey = &SnapshotRequest_SharedTable_InternalKey{}
			}
			if err := m.SmallestPointKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LargestPointKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LargestPointKey == nil {
				m.LargestPointKey = &SnapshotRequest_SharedTable_InternalKey{}
			}
			if err := m.LargestPointKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotRequest_SharedTable_InternalKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserKey = append(m.UserKey[:0], dAtA[iNdEx:postIndex]...)
			if m.UserKey == nil {
				m.UserKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trailer", wireType)
			}
			m.Trailer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Trailer |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotRequest_ExternalTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locator", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locator = append(m.Locator[:0], dAtA[iNdEx:postIndex]...)
			if m.Locator == nil {
				m.Locator = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKeyIsInclusive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EndKeyIsInclusive = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasPointKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasPointKey = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasRangeKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasRangeKey = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyntheticPrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SyntheticPrefix = append(m.SyntheticPrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.SyntheticPrefix == nil {
				m.SyntheticPrefix = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyntheticSuffix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SyntheticSuffix = append(m.SyntheticSuffix[:0], dAtA[iNdEx:postIndex]...)
			if m.SyntheticSuffix == nil {
				m.SyntheticSuffix = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SnapshotResponse_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeprecatedMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectedSpans = append(m.CollectedSpans, tracingpb.RecordedSpan{})
			if err := m.CollectedSpans[len(m.CollectedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodedError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EncodedError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgAppResp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgAppResp == nil {
				m.MsgAppResp = &raftpb.Message{}
			}
			if err := m.MsgAppResp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegateSnapshotRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegateSnapshotRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegateSnapshotRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Send", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DelegateSendSnapshotRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &DelegateSnapshotRequest_Send{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegateSendSnapshotRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegateSendSnapshotRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegateSendSnapshotRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoordinatorReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CoordinatorReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RecipientReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatedSender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DelegatedSender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= github_com_cockroachdb_cockroach_pkg_kv_kvpb.RaftTerm(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstIndex", wireType)
			}
			m.FirstIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstIndex |= github_com_cockroachdb_cockroach_pkg_kv_kvpb.RaftIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderQueueName", wireType)
			}
			m.SenderQueueName = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SenderQueueName |= SnapshotRequest_QueueName(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderQueuePriority", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SenderQueuePriority = float64(math.Float64frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorGeneration", wireType)
			}
			m.DescriptorGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorGeneration |= github_com_cockroachdb_cockroach_pkg_roachpb.RangeGeneration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueOnDelegateLen", wireType)
			}
			m.QueueOnDelegateLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueOnDelegateLen |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SnapId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegateSnapshotResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegateSnapshotResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegateSnapshotResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= DelegateSnapshotResponse_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodedError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EncodedError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectedSpans = append(m.CollectedSpans, tracingpb.RecordedSpan{})
			if err := m.CollectedSpans[len(m.CollectedSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgAppResp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgAppResp == nil {
				m.MsgAppResp = &raftpb.Message{}
			}
			if err := m.MsgAppResp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfChangeContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfChangeContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfChangeContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRaft(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRaft
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRaft
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRaft
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRaft        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRaft          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRaft = fmt.Errorf("proto: unexpected end of group")
)

