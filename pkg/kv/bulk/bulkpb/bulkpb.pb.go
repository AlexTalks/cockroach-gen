// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kv/bulk/bulkpb/bulkpb.proto

package bulkpb

import (
	fmt "fmt"
	github_com_cockroachdb_cockroach_pkg_roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	_ "github.com/cockroachdb/cockroach/pkg/util/hlc"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// IngestionPerformanceStats is a message containing information about the
// creation of SSTables by an SSTBatcher or BufferingAdder.
type IngestionPerformanceStats struct {
	// DataSize is the total byte size of all the SST files ingested.
	DataSize int64 `protobuf:"varint,1,opt,name=data_size,json=dataSize,proto3" json:"data_size,omitempty"`
	// Buffer Flushes is the number of buffer flushes.
	BufferFlushes int64 `protobuf:"varint,2,opt,name=buffer_flushes,json=bufferFlushes,proto3" json:"buffer_flushes,omitempty"`
	// FlushesDueToSize is the number of buffer flushes due to buffer size.
	FlushesDueToSize int64 `protobuf:"varint,3,opt,name=flushes_due_to_size,json=flushesDueToSize,proto3" json:"flushes_due_to_size,omitempty"`
	// Batches is the number of batches (addsstable calls) sent.
	Batches int64 `protobuf:"varint,4,opt,name=batches,proto3" json:"batches,omitempty"`
	// BatchesDueToRange is the number of batches due to range bounds.
	BatchesDueToRange int64 `protobuf:"varint,5,opt,name=batches_due_to_range,json=batchesDueToRange,proto3" json:"batches_due_to_range,omitempty"`
	// BatchesDueToSize is the number of batches due to batch size.
	BatchesDueToSize int64 `protobuf:"varint,6,opt,name=batches_due_to_size,json=batchesDueToSize,proto3" json:"batches_due_to_size,omitempty"`
	// SplitRetries is the number of extra sub-batches created due to unexpected
	// splits.
	SplitRetries int64 `protobuf:"varint,7,opt,name=split_retries,json=splitRetries,proto3" json:"split_retries,omitempty"`
	// Splits is the number of splits sent.
	Splits int64 `protobuf:"varint,8,opt,name=splits,proto3" json:"splits,omitempty"`
	// Scatters is the number of scatters sent.0
	Scatters int64 `protobuf:"varint,9,opt,name=scatters,proto3" json:"scatters,omitempty"`
	// ScatterMoved is the total size in bytes moved by scatter calls.
	ScatterMoved int64 `protobuf:"varint,10,opt,name=scatter_moved,json=scatterMoved,proto3" json:"scatter_moved,omitempty"`
	// FillWait is the time spent between buffer flushes.
	FillWait time.Duration `protobuf:"varint,11,opt,name=fill_wait,json=fillWait,proto3,casttype=time.Duration" json:"fill_wait,omitempty"`
	// SortWait is the time spent sorting buffers.
	SortWait time.Duration `protobuf:"varint,12,opt,name=sort_wait,json=sortWait,proto3,casttype=time.Duration" json:"sort_wait,omitempty"`
	// FlushWait is the time spent flushing buffers.
	FlushWait time.Duration `protobuf:"varint,13,opt,name=flush_wait,json=flushWait,proto3,casttype=time.Duration" json:"flush_wait,omitempty"`
	// BatchWait is the time spent flushing batches (inc split/scatter/send).
	BatchWait time.Duration `protobuf:"varint,14,opt,name=batch_wait,json=batchWait,proto3,casttype=time.Duration" json:"batch_wait,omitempty"`
	// SendWait is the time spent sending batches (addsstable+retries)
	SendWait time.Duration `protobuf:"varint,15,opt,name=send_wait,json=sendWait,proto3,casttype=time.Duration" json:"send_wait,omitempty"`
	// SplitWait is the time spent splitting.
	SplitWait time.Duration `protobuf:"varint,16,opt,name=split_wait,json=splitWait,proto3,casttype=time.Duration" json:"split_wait,omitempty"`
	// ScatterWait is the time spent scattering.
	ScatterWait time.Duration `protobuf:"varint,17,opt,name=scatter_wait,json=scatterWait,proto3,casttype=time.Duration" json:"scatter_wait,omitempty"`
	// CommitWait is the time spent waiting for commit timestamps.
	CommitWait time.Duration `protobuf:"varint,18,opt,name=commit_wait,json=commitWait,proto3,casttype=time.Duration" json:"commit_wait,omitempty"`
	// Duration is the total ingestion time.
	Duration time.Duration `protobuf:"varint,19,opt,name=duration,proto3,casttype=time.Duration" json:"duration,omitempty"`
	// SendWaitByStore is the time spent sending batches to each store.
	SendWaitByStore map[github_com_cockroachdb_cockroach_pkg_roachpb.StoreID]time.Duration `protobuf:"bytes,20,rep,name=send_wait_by_store,json=sendWaitByStore,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID,castvalue=time.Duration" json:"send_wait_by_store,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *IngestionPerformanceStats) Reset()         { *m = IngestionPerformanceStats{} }
func (m *IngestionPerformanceStats) String() string { return proto.CompactTextString(m) }
func (*IngestionPerformanceStats) ProtoMessage()    {}
func (*IngestionPerformanceStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_5cacc7c5400f9db8, []int{0}
}
func (m *IngestionPerformanceStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngestionPerformanceStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IngestionPerformanceStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngestionPerformanceStats.Merge(m, src)
}
func (m *IngestionPerformanceStats) XXX_Size() int {
	return m.Size()
}
func (m *IngestionPerformanceStats) XXX_DiscardUnknown() {
	xxx_messageInfo_IngestionPerformanceStats.DiscardUnknown(m)
}

var xxx_messageInfo_IngestionPerformanceStats proto.InternalMessageInfo

func init() {
	proto.RegisterType((*IngestionPerformanceStats)(nil), "cockroach.kv.bulk.bulkpb.IngestionPerformanceStats")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.StoreID]time.Duration)(nil), "cockroach.kv.bulk.bulkpb.IngestionPerformanceStats.SendWaitByStoreEntry")
}

func init() { proto.RegisterFile("kv/bulk/bulkpb/bulkpb.proto", fileDescriptor_5cacc7c5400f9db8) }

var fileDescriptor_5cacc7c5400f9db8 = []byte{
	// 614 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x94, 0xbd, 0x6f, 0xd3, 0x4e,
	0x18, 0xc7, 0xe3, 0xe6, 0xd7, 0x34, 0xb9, 0x34, 0x7d, 0xb9, 0x46, 0x3f, 0x1d, 0xa9, 0xe4, 0x56,
	0x20, 0xa4, 0x2e, 0xb5, 0x51, 0xe9, 0x80, 0x18, 0xa3, 0x82, 0xe8, 0x80, 0x84, 0x12, 0x24, 0x24,
	0x16, 0xeb, 0x6c, 0x5f, 0x1c, 0xcb, 0x2f, 0x67, 0xdd, 0x9d, 0x83, 0xd2, 0x91, 0x91, 0x89, 0x3f,
	0x89, 0xb1, 0x03, 0x43, 0xc7, 0x4e, 0x14, 0xd2, 0xff, 0x82, 0x09, 0xdd, 0x73, 0x76, 0x81, 0x0a,
	0x2f, 0xed, 0xf3, 0xf2, 0xf9, 0x3e, 0xdf, 0xbb, 0xc7, 0xba, 0xa0, 0xfd, 0x64, 0xe1, 0xfa, 0x65,
	0x9a, 0xc0, 0x9f, 0xc2, 0xaf, 0xfe, 0x39, 0x85, 0xe0, 0x8a, 0x63, 0x12, 0xf0, 0x20, 0x11, 0x9c,
	0x06, 0x73, 0x27, 0x59, 0x38, 0xba, 0xe5, 0x98, 0xfe, 0x88, 0x94, 0x2a, 0x4e, 0xdd, 0x79, 0x1a,
	0xb8, 0x2a, 0xce, 0x98, 0x54, 0x34, 0x2b, 0x8c, 0x66, 0x34, 0x8c, 0x78, 0xc4, 0x21, 0x74, 0x75,
	0x64, 0xaa, 0x0f, 0xbf, 0x76, 0xd1, 0x83, 0xf3, 0x3c, 0x62, 0x52, 0xc5, 0x3c, 0x7f, 0xc3, 0xc4,
	0x8c, 0x8b, 0x8c, 0xe6, 0x01, 0x9b, 0x2a, 0xaa, 0x24, 0xde, 0x47, 0xbd, 0x90, 0x2a, 0xea, 0xc9,
	0xf8, 0x82, 0x11, 0xeb, 0xd0, 0x3a, 0x6a, 0x4f, 0xba, 0xba, 0x30, 0x8d, 0x2f, 0x18, 0x7e, 0x8c,
	0xb6, 0xfc, 0x72, 0x36, 0x63, 0xc2, 0x9b, 0xa5, 0xa5, 0x9c, 0x33, 0x49, 0xd6, 0x80, 0x18, 0x98,
	0xea, 0x4b, 0x53, 0xc4, 0xc7, 0x68, 0xaf, 0xea, 0x7b, 0x61, 0xc9, 0x3c, 0xc5, 0xcd, 0xb4, 0x36,
	0xb0, 0x3b, 0x55, 0xeb, 0xac, 0x64, 0x6f, 0x39, 0x4c, 0x25, 0x68, 0xc3, 0xa7, 0x2a, 0xd0, 0xe3,
	0xfe, 0x03, 0xa4, 0x4e, 0xb1, 0x8b, 0x86, 0x55, 0x58, 0x0f, 0x12, 0x34, 0x8f, 0x18, 0x59, 0x07,
	0x6c, 0xb7, 0xea, 0xc1, 0xa4, 0x89, 0x6e, 0x68, 0xe7, 0x7b, 0x02, 0x70, 0xee, 0x18, 0xe7, 0x3f,
	0x79, 0x70, 0x7e, 0x84, 0x06, 0xb2, 0x48, 0x63, 0xe5, 0x09, 0xa6, 0x44, 0xcc, 0x24, 0xd9, 0x00,
	0x70, 0x13, 0x8a, 0x13, 0x53, 0xc3, 0xff, 0xa3, 0x0e, 0xe4, 0x92, 0x74, 0xa1, 0x5b, 0x65, 0x78,
	0x84, 0xba, 0x32, 0xa0, 0x4a, 0x31, 0x21, 0x49, 0xcf, 0x2c, 0xaa, 0xce, 0x61, 0xb0, 0x89, 0xbd,
	0x8c, 0x2f, 0x58, 0x48, 0x50, 0x35, 0xd8, 0x14, 0x5f, 0xeb, 0x1a, 0x76, 0x50, 0x6f, 0x16, 0xa7,
	0xa9, 0xf7, 0x81, 0xc6, 0x8a, 0xf4, 0x35, 0x30, 0xde, 0xfd, 0xf9, 0xed, 0x60, 0xa0, 0x3f, 0xa3,
	0x73, 0x56, 0x0a, 0xaa, 0x3f, 0xd0, 0xa4, 0xab, 0x99, 0x77, 0x34, 0x56, 0x9a, 0x97, 0x5c, 0x28,
	0xc3, 0x6f, 0x36, 0xf2, 0x9a, 0x01, 0xfe, 0x09, 0x42, 0xb0, 0x6b, 0x23, 0x18, 0x34, 0x09, 0x7a,
	0x00, 0xd5, 0x0a, 0xd8, 0x91, 0x51, 0x6c, 0x35, 0x2a, 0x00, 0xba, 0x3b, 0x13, 0xcb, 0x43, 0x23,
	0xd8, 0x6e, 0x3e, 0x13, 0xcb, 0xc3, 0xda, 0xc1, 0x6c, 0x1c, 0x04, 0x3b, 0x8d, 0x0e, 0x00, 0x81,
	0xe2, 0x14, 0xd5, 0x5b, 0x33, 0x9a, 0xdd, 0x26, 0x4d, 0xbf, 0xc2, 0x40, 0x75, 0x82, 0xfa, 0x01,
	0xcf, 0xb2, 0xda, 0x08, 0x37, 0x89, 0x90, 0xa1, 0x40, 0x73, 0x8c, 0xba, 0x61, 0x55, 0x27, 0x7b,
	0x8d, 0x57, 0xa9, 0x11, 0xfc, 0xc5, 0x42, 0xf8, 0xee, 0xee, 0x9e, 0xbf, 0xf4, 0xa4, 0xe2, 0x82,
	0x91, 0xe1, 0x61, 0xfb, 0xa8, 0x7f, 0xf2, 0xca, 0x69, 0x7a, 0xaf, 0x4e, 0xe3, 0xdb, 0x73, 0xa6,
	0xd5, 0x96, 0xc6, 0xcb, 0xa9, 0x1e, 0xf5, 0x22, 0x57, 0x62, 0x39, 0x3e, 0xff, 0x78, 0x73, 0x70,
	0x1a, 0xc5, 0x6a, 0x5e, 0xfa, 0x4e, 0xc0, 0x33, 0xf7, 0x6e, 0x6e, 0xe8, 0xff, 0x8e, 0xdd, 0x22,
	0x89, 0x5c, 0x88, 0x0a, 0xdf, 0x01, 0xf1, 0xf9, 0xd9, 0xa7, 0x9b, 0xfb, 0x67, 0xdf, 0x96, 0x7f,
	0x1b, 0x8c, 0xc6, 0x68, 0xf8, 0x2f, 0x4f, 0xbc, 0x83, 0xda, 0x09, 0x5b, 0xc2, 0xf3, 0x5f, 0x9f,
	0xe8, 0x10, 0x0f, 0xd1, 0xfa, 0x82, 0xa6, 0x25, 0xab, 0x1e, 0xbc, 0x49, 0x9e, 0xaf, 0x3d, 0xb3,
	0xc6, 0x47, 0x97, 0x3f, 0xec, 0xd6, 0xe5, 0xca, 0xb6, 0xae, 0x56, 0xb6, 0x75, 0xbd, 0xb2, 0xad,
	0xef, 0x2b, 0xdb, 0xfa, 0x7c, 0x6b, 0xb7, 0xae, 0x6e, 0xed, 0xd6, 0xf5, 0xad, 0xdd, 0x7a, 0xdf,
	0x31, 0x17, 0xf7, 0x3b, 0xf0, 0xfb, 0xf3, 0xf4, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0x8b, 0xc2,
	0x5b, 0xfe, 0xe8, 0x04, 0x00, 0x00,
}

func (m *IngestionPerformanceStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestionPerformanceStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngestionPerformanceStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SendWaitByStore) > 0 {
		keysForSendWaitByStore := make([]int32, 0, len(m.SendWaitByStore))
		for k := range m.SendWaitByStore {
			keysForSendWaitByStore = append(keysForSendWaitByStore, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForSendWaitByStore)
		for iNdEx := len(keysForSendWaitByStore) - 1; iNdEx >= 0; iNdEx-- {
			v := m.SendWaitByStore[github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(keysForSendWaitByStore[iNdEx])]
			baseI := i
			i = encodeVarintBulkpb(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintBulkpb(dAtA, i, uint64(keysForSendWaitByStore[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintBulkpb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.Duration != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.CommitWait != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.CommitWait))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ScatterWait != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.ScatterWait))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.SplitWait != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.SplitWait))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.SendWait != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.SendWait))
		i--
		dAtA[i] = 0x78
	}
	if m.BatchWait != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.BatchWait))
		i--
		dAtA[i] = 0x70
	}
	if m.FlushWait != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.FlushWait))
		i--
		dAtA[i] = 0x68
	}
	if m.SortWait != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.SortWait))
		i--
		dAtA[i] = 0x60
	}
	if m.FillWait != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.FillWait))
		i--
		dAtA[i] = 0x58
	}
	if m.ScatterMoved != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.ScatterMoved))
		i--
		dAtA[i] = 0x50
	}
	if m.Scatters != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.Scatters))
		i--
		dAtA[i] = 0x48
	}
	if m.Splits != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.Splits))
		i--
		dAtA[i] = 0x40
	}
	if m.SplitRetries != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.SplitRetries))
		i--
		dAtA[i] = 0x38
	}
	if m.BatchesDueToSize != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.BatchesDueToSize))
		i--
		dAtA[i] = 0x30
	}
	if m.BatchesDueToRange != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.BatchesDueToRange))
		i--
		dAtA[i] = 0x28
	}
	if m.Batches != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.Batches))
		i--
		dAtA[i] = 0x20
	}
	if m.FlushesDueToSize != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.FlushesDueToSize))
		i--
		dAtA[i] = 0x18
	}
	if m.BufferFlushes != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.BufferFlushes))
		i--
		dAtA[i] = 0x10
	}
	if m.DataSize != 0 {
		i = encodeVarintBulkpb(dAtA, i, uint64(m.DataSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintBulkpb(dAtA []byte, offset int, v uint64) int {
	offset -= sovBulkpb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *IngestionPerformanceStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataSize != 0 {
		n += 1 + sovBulkpb(uint64(m.DataSize))
	}
	if m.BufferFlushes != 0 {
		n += 1 + sovBulkpb(uint64(m.BufferFlushes))
	}
	if m.FlushesDueToSize != 0 {
		n += 1 + sovBulkpb(uint64(m.FlushesDueToSize))
	}
	if m.Batches != 0 {
		n += 1 + sovBulkpb(uint64(m.Batches))
	}
	if m.BatchesDueToRange != 0 {
		n += 1 + sovBulkpb(uint64(m.BatchesDueToRange))
	}
	if m.BatchesDueToSize != 0 {
		n += 1 + sovBulkpb(uint64(m.BatchesDueToSize))
	}
	if m.SplitRetries != 0 {
		n += 1 + sovBulkpb(uint64(m.SplitRetries))
	}
	if m.Splits != 0 {
		n += 1 + sovBulkpb(uint64(m.Splits))
	}
	if m.Scatters != 0 {
		n += 1 + sovBulkpb(uint64(m.Scatters))
	}
	if m.ScatterMoved != 0 {
		n += 1 + sovBulkpb(uint64(m.ScatterMoved))
	}
	if m.FillWait != 0 {
		n += 1 + sovBulkpb(uint64(m.FillWait))
	}
	if m.SortWait != 0 {
		n += 1 + sovBulkpb(uint64(m.SortWait))
	}
	if m.FlushWait != 0 {
		n += 1 + sovBulkpb(uint64(m.FlushWait))
	}
	if m.BatchWait != 0 {
		n += 1 + sovBulkpb(uint64(m.BatchWait))
	}
	if m.SendWait != 0 {
		n += 1 + sovBulkpb(uint64(m.SendWait))
	}
	if m.SplitWait != 0 {
		n += 2 + sovBulkpb(uint64(m.SplitWait))
	}
	if m.ScatterWait != 0 {
		n += 2 + sovBulkpb(uint64(m.ScatterWait))
	}
	if m.CommitWait != 0 {
		n += 2 + sovBulkpb(uint64(m.CommitWait))
	}
	if m.Duration != 0 {
		n += 2 + sovBulkpb(uint64(m.Duration))
	}
	if len(m.SendWaitByStore) > 0 {
		for k, v := range m.SendWaitByStore {
			_ = k
			_ = v
			mapEntrySize := 1 + sovBulkpb(uint64(k)) + 1 + sovBulkpb(uint64(v))
			n += mapEntrySize + 2 + sovBulkpb(uint64(mapEntrySize))
		}
	}
	return n
}

func sovBulkpb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBulkpb(x uint64) (n int) {
	return sovBulkpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IngestionPerformanceStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBulkpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestionPerformanceStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestionPerformanceStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSize", wireType)
			}
			m.DataSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferFlushes", wireType)
			}
			m.BufferFlushes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BufferFlushes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlushesDueToSize", wireType)
			}
			m.FlushesDueToSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlushesDueToSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batches", wireType)
			}
			m.Batches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Batches |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchesDueToRange", wireType)
			}
			m.BatchesDueToRange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchesDueToRange |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchesDueToSize", wireType)
			}
			m.BatchesDueToSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchesDueToSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitRetries", wireType)
			}
			m.SplitRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SplitRetries |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Splits", wireType)
			}
			m.Splits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Splits |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scatters", wireType)
			}
			m.Scatters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scatters |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScatterMoved", wireType)
			}
			m.ScatterMoved = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScatterMoved |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FillWait", wireType)
			}
			m.FillWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FillWait |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortWait", wireType)
			}
			m.SortWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SortWait |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlushWait", wireType)
			}
			m.FlushWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlushWait |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchWait", wireType)
			}
			m.BatchWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchWait |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendWait", wireType)
			}
			m.SendWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendWait |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitWait", wireType)
			}
			m.SplitWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SplitWait |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScatterWait", wireType)
			}
			m.ScatterWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScatterWait |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitWait", wireType)
			}
			m.CommitWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitWait |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendWaitByStore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBulkpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBulkpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SendWaitByStore == nil {
				m.SendWaitByStore = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.StoreID]time.Duration)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBulkpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBulkpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBulkpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBulkpb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBulkpb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SendWaitByStore[github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(mapkey)] = ((time.Duration)(mapvalue))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBulkpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBulkpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBulkpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBulkpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBulkpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBulkpb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBulkpb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBulkpb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBulkpb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBulkpb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBulkpb = fmt.Errorf("proto: unexpected end of group")
)
