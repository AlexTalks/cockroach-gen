exec
CREATE TABLE t.orders (oid INT PRIMARY KEY, cid INT, value DECIMAL, date DATE)
----

# In the string version, the constants are not anonymized.
plan-string
SELECT oid FROM t.orders WHERE oid = 123
----
0 render  (oid int) oid=CONST; key()
0 .render 0 (@1)[int] (oid int) oid=CONST; key()
1 scan  (oid int) oid=CONST; key()
1 .table orders@primary (oid int) oid=CONST; key()
1 .spans /123-/123/# (oid int) oid=CONST; key()

plan-tree
SELECT oid FROM t.orders WHERE oid = 123
----
name: render
attrs:
- key: render
  value: oid
children:
- name: scan
  attrs:
  - key: table
    value: orders@primary
  - key: spans
    value: 1 span
  children: []

plan-string
SELECT cid, date, value FROM t.orders
----
0 render  (cid int, date date, value decimal) 
0 .render 0 (@2)[int] (cid int, date date, value decimal) 
0 .render 1 (@4)[date] (cid int, date date, value decimal) 
0 .render 2 (@3)[decimal] (cid int, date date, value decimal) 
1 scan  (cid int, date date, value decimal) 
1 .table orders@primary (cid int, date date, value decimal) 
1 .spans ALL (cid int, date date, value decimal) 

plan-tree
SELECT cid, date, value FROM t.orders
----
name: render
attrs:
- key: render
  value: cid
- key: render
  value: date
- key: render
  value: value
children:
- name: scan
  attrs:
  - key: table
    value: orders@primary
  - key: spans
    value: ALL
  children: []

plan-string
SELECT cid, sum(value) FROM t.orders WHERE date > '2015-01-01' GROUP BY cid ORDER BY 1 - sum(value)
----
0 sort  (cid int, sum decimal) weak-key(cid)
0 .order +"?column?" (cid int, sum decimal) weak-key(cid)
1 render  (cid int, sum decimal) weak-key(cid)
1 .render 0 (@1)[int] (cid int, sum decimal) weak-key(cid)
1 .render 1 (@2)[decimal] (cid int, sum decimal) weak-key(cid)
1 .render 2 ((1)[decimal] - (@2)[decimal])[decimal] (cid int, sum decimal) weak-key(cid)
2 group  (cid int, sum decimal) weak-key(cid)
2 .aggregate 0 cid (cid int, sum decimal) weak-key(cid)
2 .aggregate 1 sum(value) (cid int, sum decimal) weak-key(cid)
2 .group by cid (cid int, sum decimal) weak-key(cid)
3 render  (cid int, sum decimal) weak-key(cid)
3 .render 0 (@2)[int] (cid int, sum decimal) weak-key(cid)
3 .render 1 (@3)[decimal] (cid int, sum decimal) weak-key(cid)
4 scan  (cid int, sum decimal) weak-key(cid)
4 .table orders@primary (cid int, sum decimal) weak-key(cid)
4 .spans ALL (cid int, sum decimal) weak-key(cid)
4 .filter ((@4)[date] > ('2015-01-01')[date])[bool] (cid int, sum decimal) weak-key(cid)

plan-tree
SELECT cid, sum(value) FROM t.orders WHERE date > '2015-01-01' GROUP BY cid ORDER BY 1 - sum(value)
----
name: sort
attrs:
- key: order
  value: +"?column?"
children:
- name: render
  attrs:
  - key: render
    value: agg0
  - key: render
    value: agg1
  - key: render
    value: _ - agg1
  children:
  - name: group
    attrs:
    - key: aggregate 0
      value: cid
    - key: aggregate 1
      value: sum(value)
    - key: group by
      value: cid
    children:
    - name: render
      attrs:
      - key: render
        value: cid
      - key: render
        value: value
      children:
      - name: scan
        attrs:
        - key: table
          value: orders@primary
        - key: spans
          value: ALL
        - key: filter
          value: date > _
        children: []

plan-string
SELECT value FROM (SELECT cid, date, value FROM t.orders)
----
0 render  (value decimal) 
0 .render 0 (@3)[decimal] (value decimal) 
1 render  (value decimal) 
1 .render 0 (NULL)[unknown] (value decimal) 
1 .render 1 (NULL)[unknown] (value decimal) 
1 .render 2 (@3)[decimal] (value decimal) 
2 scan  (value decimal) 
2 .table orders@primary (value decimal) 
2 .spans ALL (value decimal) 

plan-tree
SELECT value FROM (SELECT cid, date, value FROM t.orders)
----
name: render
attrs:
- key: render
  value: value
children:
- name: render
  attrs:
  - key: render
    value: _
  - key: render
    value: _
  - key: render
    value: value
  children:
  - name: scan
    attrs:
    - key: table
      value: orders@primary
    - key: spans
      value: ALL
    children: []

plan-string
SELECT cid, date, value FROM t.orders WHERE date IN (SELECT date FROM t.orders)
----
0 root  (cid int, date date, value decimal) date!=NULL
1 render  (cid int, date date, value decimal) date!=NULL
1 .render 0 (@2)[int] (cid int, date date, value decimal) date!=NULL
1 .render 1 (@4)[date] (cid int, date date, value decimal) date!=NULL
1 .render 2 (@3)[decimal] (cid int, date date, value decimal) date!=NULL
2 scan  (cid int, date date, value decimal) date!=NULL
2 .table orders@primary (cid int, date date, value decimal) date!=NULL
2 .spans ALL (cid int, date date, value decimal) date!=NULL
2 .filter ((@4)[date] IN (@S1)[tuple{date}])[bool] (cid int, date date, value decimal) date!=NULL
1 subquery  (cid int, date date, value decimal) date!=NULL
1 .id @S1 (cid int, date date, value decimal) date!=NULL
1 .original sql (SELECT date FROM t.public.orders) (cid int, date date, value decimal) date!=NULL
1 .exec mode all rows normalized (cid int, date date, value decimal) date!=NULL
2 render  (cid int, date date, value decimal) date!=NULL
2 .render 0 (@4)[date] (cid int, date date, value decimal) date!=NULL
3 scan  (cid int, date date, value decimal) date!=NULL
3 .table orders@primary (cid int, date date, value decimal) date!=NULL
3 .spans ALL (cid int, date date, value decimal) date!=NULL

plan-tree
SELECT cid, date, value FROM t.orders WHERE date IN (SELECT date FROM t.orders)
----
name: root
attrs: []
children:
- name: render
  attrs:
  - key: render
    value: cid
  - key: render
    value: date
  - key: render
    value: value
  children:
  - name: scan
    attrs:
    - key: table
      value: orders@primary
    - key: spans
      value: ALL
    - key: filter
      value: date IN (SELECT date FROM t.public.orders)
    children: []
- name: subquery
  attrs:
  - key: id
    value: '@S1'
  - key: original sql
    value: (SELECT date FROM t.public.orders)
  - key: exec mode
    value: all rows normalized
  children:
  - name: render
    attrs:
    - key: render
      value: date
    children:
    - name: scan
      attrs:
      - key: table
        value: orders@primary
      - key: spans
        value: ALL
      children: []

exec
CREATE TABLE t.movies (
  id SERIAL PRIMARY KEY,
  title TEXT,
  released INT
)
----

exec
CREATE TABLE t.actors (
  id SERIAL PRIMARY KEY,
  name TEXT
)
----

# Subquery.
plan-string
SELECT id AS movie_id, title, (SELECT name FROM t.actors WHERE name = 'Foo') FROM t.movies
----
0 root  (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)
1 render  (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)
1 .render 0 (@1)[int] (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)
1 .render 1 (@2)[string] (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)
1 .render 2 (@S1)[string] (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)
2 scan  (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)
2 .table movies@primary (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)
2 .spans ALL (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)
1 subquery  (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)
1 .id @S1 (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)
1 .original sql (SELECT name FROM t.public.actors WHERE name = 'Foo') (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)
1 .exec mode one row (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)
2 max1row  (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)
3 limit  (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)
3 .count (2)[int] (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)
4 render  (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)
4 .render 0 (@2)[string] (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)
5 scan  (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)
5 .table actors@primary (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)
5 .spans ALL (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)
5 .filter ((@2)[string] = ('Foo')[string])[bool] (movie_id int, title string, name string) name=CONST; movie_id!=NULL; key(movie_id)

plan-tree
SELECT id AS movie_id, title, (SELECT name FROM t.actors WHERE name = 'Foo') FROM t.movies
----
name: root
attrs: []
children:
- name: render
  attrs:
  - key: render
    value: id
  - key: render
    value: title
  - key: render
    value: (SELECT name FROM t.public.actors WHERE name = _)
  children:
  - name: scan
    attrs:
    - key: table
      value: movies@primary
    - key: spans
      value: ALL
    children: []
- name: subquery
  attrs:
  - key: id
    value: '@S1'
  - key: original sql
    value: (SELECT name FROM t.public.actors WHERE name = _)
  - key: exec mode
    value: one row
  children:
  - name: max1row
    attrs: []
    children:
    - name: limit
      attrs:
      - key: count
        value: _
      children:
      - name: render
        attrs:
        - key: render
          value: name
        children:
        - name: scan
          attrs:
          - key: table
            value: actors@primary
          - key: spans
            value: ALL
          - key: filter
            value: name = _
          children: []
