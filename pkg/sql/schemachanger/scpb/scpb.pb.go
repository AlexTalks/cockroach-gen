// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/schemachanger/scpb/scpb.proto

package scpb

import (
	fmt "fmt"
	github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Status int32

const (
	Status_UNKNOWN Status = 0
	// Target states are ABSENT, PUBLIC or TRANSIENT_ABSENT.
	// These are the desired final end states of a schema change.
	Status_ABSENT Status = 1
	Status_PUBLIC Status = 2
	// TRANSIENT_ABSENT is like ABSENT->TRANSIENT_ABSENT; the element is not
	// persisted once the schema change involving it is complete.
	Status_TRANSIENT_ABSENT Status = 3
	Status_DROPPED          Status = 5
	Status_OFFLINE          Status = 15
	// Intermediate states on the column and index dropping and adding paths.
	Status_WRITE_ONLY  Status = 6
	Status_DELETE_ONLY Status = 7
	// Intermediate states on the index dropping and adding paths.
	Status_VALIDATED     Status = 8
	Status_MERGED        Status = 9
	Status_MERGE_ONLY    Status = 10
	Status_BACKFILLED    Status = 11
	Status_BACKFILL_ONLY Status = 12
	// Intermediate states on the transient index dropping path
	Status_TRANSIENT_DELETE_ONLY   Status = 13
	Status_TRANSIENT_WRITE_ONLY    Status = 14
	Status_TRANSIENT_BACKFILL_ONLY Status = 16
	Status_TRANSIENT_BACKFILLED    Status = 17
	Status_TRANSIENT_MERGE_ONLY    Status = 18
	Status_TRANSIENT_MERGED        Status = 19
	Status_TRANSIENT_VALIDATED     Status = 20
	Status_TRANSIENT_PUBLIC        Status = 21
)

var Status_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "ABSENT",
	2:  "PUBLIC",
	3:  "TRANSIENT_ABSENT",
	5:  "DROPPED",
	15: "OFFLINE",
	6:  "WRITE_ONLY",
	7:  "DELETE_ONLY",
	8:  "VALIDATED",
	9:  "MERGED",
	10: "MERGE_ONLY",
	11: "BACKFILLED",
	12: "BACKFILL_ONLY",
	13: "TRANSIENT_DELETE_ONLY",
	14: "TRANSIENT_WRITE_ONLY",
	16: "TRANSIENT_BACKFILL_ONLY",
	17: "TRANSIENT_BACKFILLED",
	18: "TRANSIENT_MERGE_ONLY",
	19: "TRANSIENT_MERGED",
	20: "TRANSIENT_VALIDATED",
	21: "TRANSIENT_PUBLIC",
}

var Status_value = map[string]int32{
	"UNKNOWN":                 0,
	"ABSENT":                  1,
	"PUBLIC":                  2,
	"TRANSIENT_ABSENT":        3,
	"DROPPED":                 5,
	"OFFLINE":                 15,
	"WRITE_ONLY":              6,
	"DELETE_ONLY":             7,
	"VALIDATED":               8,
	"MERGED":                  9,
	"MERGE_ONLY":              10,
	"BACKFILLED":              11,
	"BACKFILL_ONLY":           12,
	"TRANSIENT_DELETE_ONLY":   13,
	"TRANSIENT_WRITE_ONLY":    14,
	"TRANSIENT_BACKFILL_ONLY": 16,
	"TRANSIENT_BACKFILLED":    17,
	"TRANSIENT_MERGE_ONLY":    18,
	"TRANSIENT_MERGED":        19,
	"TRANSIENT_VALIDATED":     20,
	"TRANSIENT_PUBLIC":        21,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}

func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5413c88842564e28, []int{0}
}

type Target struct {
	ElementProto `protobuf:"bytes,1,opt,name=element_proto,json=elementProto,proto3,embedded=element_proto" json:"element_proto"`
	Metadata     TargetMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata"`
	TargetStatus Status         `protobuf:"varint,3,opt,name=target_status,json=targetStatus,proto3,enum=cockroach.sql.schemachanger.scpb.Status" json:"target_status,omitempty"`
}

func (m *Target) Reset()         { *m = Target{} }
func (m *Target) String() string { return proto.CompactTextString(m) }
func (*Target) ProtoMessage()    {}
func (*Target) Descriptor() ([]byte, []int) {
	return fileDescriptor_5413c88842564e28, []int{0}
}
func (m *Target) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Target) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Target) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Target.Merge(m, src)
}
func (m *Target) XXX_Size() int {
	return m.Size()
}
func (m *Target) XXX_DiscardUnknown() {
	xxx_messageInfo_Target.DiscardUnknown(m)
}

var xxx_messageInfo_Target proto.InternalMessageInfo

// TargetMetadata refers to the metadata for individual elements, where
// some fields like statement_id are indexes into the the full declarative
// schema changer State.
type TargetMetadata struct {
	// SubWorkID identifies the individual portions of a statement that this
	// target belongs too. For example, if multiple objects such as tables or
	// schemas are dropped in a single statement (i.e. such as DROP TABLE A, B)
	//  then this counter will increment  for each of those objects.
	SubWorkID uint32 `protobuf:"varint,1,opt,name=sub_work_id,json=subWorkId,proto3" json:"sub_work_id,omitempty"`
	// SourceElementID identifies the parent element responsible for generating
	// an element, which will be used to track cascaded drops. For example
	// if database is being dropped, then any schemas that are dropped will have
	// this reference ID. Note: These ID's do not correspond to descriptor ID's
	// and are incremented as new elements are added into the State.
	SourceElementID SourceElementID `protobuf:"varint,2,opt,name=source_element_id,json=sourceElementId,proto3,casttype=SourceElementID" json:"source_element_id,omitempty"`
	// StatementID refers to the statement that produced this element, where
	// the ID indexes into the State structure.
	//
	// TODO(ajwerner): Potentially multiple statements in a transaction affect
	// the same target. We'll need to retain a set of ids to deal with that case.
	// Fortunately making a field repeated is backwards compatible.
	StatementID uint32 `protobuf:"varint,3,opt,name=statement_id,json=statementId,proto3" json:"statement_id,omitempty"`
}

func (m *TargetMetadata) Reset()         { *m = TargetMetadata{} }
func (m *TargetMetadata) String() string { return proto.CompactTextString(m) }
func (*TargetMetadata) ProtoMessage()    {}
func (*TargetMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_5413c88842564e28, []int{1}
}
func (m *TargetMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TargetMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TargetMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TargetMetadata.Merge(m, src)
}
func (m *TargetMetadata) XXX_Size() int {
	return m.Size()
}
func (m *TargetMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_TargetMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_TargetMetadata proto.InternalMessageInfo

type TargetState struct {
	Targets       []Target      `protobuf:"bytes,1,rep,name=targets,proto3" json:"targets"`
	Statements    []Statement   `protobuf:"bytes,2,rep,name=statements,proto3" json:"statements"`
	Authorization Authorization `protobuf:"bytes,3,opt,name=authorization,proto3" json:"authorization"`
}

func (m *TargetState) Reset()         { *m = TargetState{} }
func (m *TargetState) String() string { return proto.CompactTextString(m) }
func (*TargetState) ProtoMessage()    {}
func (*TargetState) Descriptor() ([]byte, []int) {
	return fileDescriptor_5413c88842564e28, []int{2}
}
func (m *TargetState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TargetState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TargetState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TargetState.Merge(m, src)
}
func (m *TargetState) XXX_Size() int {
	return m.Size()
}
func (m *TargetState) XXX_DiscardUnknown() {
	xxx_messageInfo_TargetState.DiscardUnknown(m)
}

var xxx_messageInfo_TargetState proto.InternalMessageInfo

type Statement struct {
	Statement         string `protobuf:"bytes,1,opt,name=statement,proto3" json:"statement,omitempty"`
	RedactedStatement string `protobuf:"bytes,2,opt,name=redacted_statement,json=redactedStatement,proto3" json:"redacted_statement,omitempty"`
	StatementTag      string `protobuf:"bytes,3,opt,name=statement_tag,json=statementTag,proto3" json:"statement_tag,omitempty"`
}

func (m *Statement) Reset()         { *m = Statement{} }
func (m *Statement) String() string { return proto.CompactTextString(m) }
func (*Statement) ProtoMessage()    {}
func (*Statement) Descriptor() ([]byte, []int) {
	return fileDescriptor_5413c88842564e28, []int{3}
}
func (m *Statement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Statement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Statement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Statement.Merge(m, src)
}
func (m *Statement) XXX_Size() int {
	return m.Size()
}
func (m *Statement) XXX_DiscardUnknown() {
	xxx_messageInfo_Statement.DiscardUnknown(m)
}

var xxx_messageInfo_Statement proto.InternalMessageInfo

type Authorization struct {
	UserName string `protobuf:"bytes,1,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
	AppName  string `protobuf:"bytes,2,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
}

func (m *Authorization) Reset()         { *m = Authorization{} }
func (m *Authorization) String() string { return proto.CompactTextString(m) }
func (*Authorization) ProtoMessage()    {}
func (*Authorization) Descriptor() ([]byte, []int) {
	return fileDescriptor_5413c88842564e28, []int{4}
}
func (m *Authorization) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Authorization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Authorization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Authorization.Merge(m, src)
}
func (m *Authorization) XXX_Size() int {
	return m.Size()
}
func (m *Authorization) XXX_DiscardUnknown() {
	xxx_messageInfo_Authorization.DiscardUnknown(m)
}

var xxx_messageInfo_Authorization proto.InternalMessageInfo

// DescriptorState contains the portion of a schema change state
// corresponding to an individual descriptor. The combination of
// these messages for all descriptors involved in a schema change produces the
// current state of the entire schema change.
type DescriptorState struct {
	// JobID is the ID of the job responsible for this DescriptorState.
	JobID github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.JobID `protobuf:"varint,5,opt,name=job_id,json=jobId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.JobID" json:"job_id,omitempty"`
	// Revertible captures whether the job is currently revertible.
	// This is important to facilitate constructing the job in the appropriate
	// way upon restore.
	Revertible bool `protobuf:"varint,7,opt,name=revertible,proto3" json:"revertible,omitempty"`
	// InRollback captures whether the job is currently rolling back.
	// This is important to ensure that the job can be moved to the proper
	// failed state upon restore.
	//
	// Note, if this value is true, the targets have had their directions
	// flipped already.
	//
	InRollback bool `protobuf:"varint,8,opt,name=in_rollback,json=inRollback,proto3" json:"in_rollback,omitempty"`
	// Targets is the set of targets in the schema change belonging to this
	// descriptor.
	Targets []Target `protobuf:"bytes,1,rep,name=targets,proto3" json:"targets"`
	// CurrentStatuses is parallel to Targets and stores the current status for
	// those targets.
	CurrentStatuses []Status `protobuf:"varint,4,rep,packed,name=current_statuses,json=currentStatuses,proto3,enum=cockroach.sql.schemachanger.scpb.Status" json:"current_statuses,omitempty"`
	// TargetRanks is parallel to Targets and stores the rank of the target in
	// the complete schema change. These ranks are used to deterministically
	// reconstruct the complete TargetState from a collection of DescriptorState
	// messages.
	TargetRanks []uint32 `protobuf:"varint,6,rep,packed,name=target_ranks,json=targetRanks,proto3" json:"target_ranks,omitempty"`
	// RelevantStatements is the set of statements which are relevant to any of
	// the targets. It is sorted internally by StatementRank.
	RelevantStatements []DescriptorState_Statement `protobuf:"bytes,2,rep,name=relevant_statements,json=relevantStatements,proto3" json:"relevant_statements"`
	// Authorization is information about the creator of the schema change.
	Authorization Authorization `protobuf:"bytes,3,opt,name=authorization,proto3" json:"authorization"`
}

func (m *DescriptorState) Reset()         { *m = DescriptorState{} }
func (m *DescriptorState) String() string { return proto.CompactTextString(m) }
func (*DescriptorState) ProtoMessage()    {}
func (*DescriptorState) Descriptor() ([]byte, []int) {
	return fileDescriptor_5413c88842564e28, []int{5}
}
func (m *DescriptorState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DescriptorState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DescriptorState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DescriptorState.Merge(m, src)
}
func (m *DescriptorState) XXX_Size() int {
	return m.Size()
}
func (m *DescriptorState) XXX_DiscardUnknown() {
	xxx_messageInfo_DescriptorState.DiscardUnknown(m)
}

var xxx_messageInfo_DescriptorState proto.InternalMessageInfo

// Statement is a statement which is associated with one or more targets
// in the current DescriptorState.
type DescriptorState_Statement struct {
	// Statement is a statement that is relevant to one or more targets
	// in this descriptor.
	Statement Statement `protobuf:"bytes,1,opt,name=statement,proto3" json:"statement"`
	// StatementRank is the rank of the statement in the transaction.
	StatementRank uint32 `protobuf:"varint,2,opt,name=statement_rank,json=statementRank,proto3" json:"statement_rank,omitempty"`
}

func (m *DescriptorState_Statement) Reset()         { *m = DescriptorState_Statement{} }
func (m *DescriptorState_Statement) String() string { return proto.CompactTextString(m) }
func (*DescriptorState_Statement) ProtoMessage()    {}
func (*DescriptorState_Statement) Descriptor() ([]byte, []int) {
	return fileDescriptor_5413c88842564e28, []int{5, 0}
}
func (m *DescriptorState_Statement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DescriptorState_Statement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DescriptorState_Statement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DescriptorState_Statement.Merge(m, src)
}
func (m *DescriptorState_Statement) XXX_Size() int {
	return m.Size()
}
func (m *DescriptorState_Statement) XXX_DiscardUnknown() {
	xxx_messageInfo_DescriptorState_Statement.DiscardUnknown(m)
}

var xxx_messageInfo_DescriptorState_Statement proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.sql.schemachanger.scpb.Status", Status_name, Status_value)
	proto.RegisterType((*Target)(nil), "cockroach.sql.schemachanger.scpb.Target")
	proto.RegisterType((*TargetMetadata)(nil), "cockroach.sql.schemachanger.scpb.TargetMetadata")
	proto.RegisterType((*TargetState)(nil), "cockroach.sql.schemachanger.scpb.TargetState")
	proto.RegisterType((*Statement)(nil), "cockroach.sql.schemachanger.scpb.Statement")
	proto.RegisterType((*Authorization)(nil), "cockroach.sql.schemachanger.scpb.Authorization")
	proto.RegisterType((*DescriptorState)(nil), "cockroach.sql.schemachanger.scpb.DescriptorState")
	proto.RegisterType((*DescriptorState_Statement)(nil), "cockroach.sql.schemachanger.scpb.DescriptorState.Statement")
}

func init() { proto.RegisterFile("sql/schemachanger/scpb/scpb.proto", fileDescriptor_5413c88842564e28) }

var fileDescriptor_5413c88842564e28 = []byte{
	// 987 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0x4f, 0x8f, 0xdb, 0x44,
	0x14, 0x8f, 0x93, 0x6c, 0x36, 0x79, 0x5e, 0x6f, 0xbc, 0xd3, 0xad, 0x9a, 0x6e, 0x91, 0x93, 0x06,
	0x15, 0x45, 0x45, 0x4d, 0xd0, 0x72, 0x03, 0x2e, 0x49, 0xed, 0x2d, 0xa6, 0xd9, 0xec, 0x32, 0x49,
	0x59, 0x01, 0x42, 0x66, 0x6c, 0x8f, 0xb2, 0x69, 0xfe, 0x38, 0x1d, 0x3b, 0x45, 0x42, 0xe2, 0xc4,
	0x01, 0x89, 0x13, 0x5f, 0x00, 0x89, 0x23, 0x1f, 0x65, 0x2f, 0x95, 0xf6, 0xd8, 0x53, 0x04, 0xd9,
	0x0b, 0x9f, 0x81, 0x13, 0x9a, 0xb1, 0x13, 0xdb, 0xad, 0xd0, 0x16, 0x84, 0xb8, 0xec, 0xce, 0xfc,
	0xde, 0xfb, 0xfd, 0xde, 0xbf, 0x79, 0x56, 0xe0, 0xae, 0xff, 0x6c, 0xd2, 0xf2, 0x9d, 0x73, 0x3a,
	0x25, 0xce, 0x39, 0x99, 0x0d, 0x29, 0x6b, 0xf9, 0xce, 0xdc, 0x16, 0x7f, 0x9a, 0x73, 0xe6, 0x05,
	0x1e, 0xaa, 0x39, 0x9e, 0x33, 0x66, 0x1e, 0x71, 0xce, 0x9b, 0xfe, 0xb3, 0x49, 0x33, 0xe5, 0xdc,
	0xe4, 0x7e, 0x07, 0xf7, 0xfe, 0x46, 0x84, 0x4e, 0xe8, 0x94, 0xce, 0x02, 0x3f, 0x14, 0x3a, 0xd8,
	0x1f, 0x7a, 0x43, 0x4f, 0x1c, 0x5b, 0xfc, 0x14, 0xa2, 0xf5, 0x1f, 0xb3, 0x50, 0x18, 0x10, 0x36,
	0xa4, 0x01, 0xfa, 0x0a, 0x94, 0x88, 0x62, 0x09, 0x5b, 0x45, 0xaa, 0x49, 0x0d, 0xf9, 0xb0, 0xd9,
	0xbc, 0x2e, 0x83, 0xa6, 0x11, 0xd2, 0x4e, 0x39, 0xab, 0x53, 0xbc, 0x58, 0x56, 0x33, 0x97, 0xcb,
	0xaa, 0x84, 0x77, 0x68, 0x02, 0x47, 0x18, 0x8a, 0x53, 0x1a, 0x10, 0x97, 0x04, 0xa4, 0x92, 0x15,
	0xca, 0xef, 0x5d, 0xaf, 0x1c, 0xa6, 0x76, 0x1c, 0xf1, 0x3a, 0x79, 0xae, 0x8d, 0x37, 0x3a, 0xe8,
	0x18, 0x94, 0x40, 0x78, 0x58, 0x7e, 0x40, 0x82, 0x85, 0x5f, 0xc9, 0xd5, 0xa4, 0xc6, 0xee, 0x61,
	0xe3, 0x7a, 0xe1, 0xbe, 0xf0, 0xc7, 0x3b, 0x21, 0x3d, 0xbc, 0xd5, 0x5f, 0x48, 0xb0, 0x9b, 0x8e,
	0x88, 0x1e, 0x80, 0xec, 0x2f, 0x6c, 0xeb, 0x1b, 0x8f, 0x8d, 0xad, 0x91, 0x2b, 0x5a, 0xa2, 0x74,
	0x94, 0xd5, 0xb2, 0x5a, 0xea, 0x2f, 0xec, 0x33, 0x8f, 0x8d, 0x4d, 0x1d, 0x97, 0xfc, 0xe8, 0xe8,
	0x22, 0x0c, 0x7b, 0xbe, 0xb7, 0x60, 0x0e, 0xb5, 0xd6, 0xad, 0x1c, 0xb9, 0xa2, 0x5a, 0xa5, 0xf3,
	0xce, 0x6a, 0x59, 0x2d, 0xf7, 0x85, 0x31, 0xea, 0x97, 0xa9, 0xff, 0xf9, 0x3a, 0x84, 0xcb, 0x7e,
	0x0a, 0x70, 0xd1, 0x21, 0xec, 0xf0, 0xea, 0x36, 0x72, 0x39, 0x21, 0x57, 0x5e, 0x2d, 0xab, 0x72,
	0x7f, 0x8d, 0x9b, 0x3a, 0x96, 0x37, 0x4e, 0xa6, 0xfb, 0x41, 0xfe, 0x8f, 0x5f, 0xaa, 0x52, 0xfd,
	0x87, 0x2c, 0xc8, 0x83, 0x4d, 0x81, 0x14, 0x7d, 0x0c, 0xdb, 0x61, 0xbd, 0x7e, 0x45, 0xaa, 0xe5,
	0x1a, 0xf2, 0x9b, 0x34, 0x2a, 0xe4, 0x47, 0x9d, 0x5f, 0xd3, 0xd1, 0xa7, 0x00, 0x9b, 0x70, 0x7e,
	0x25, 0x2b, 0xc4, 0xde, 0x7d, 0xb3, 0xae, 0x0b, 0x4e, 0xa4, 0x97, 0x10, 0x41, 0x5f, 0x82, 0x42,
	0x16, 0xc1, 0xb9, 0xc7, 0x46, 0xdf, 0x92, 0x60, 0xe4, 0xcd, 0x44, 0x9d, 0xf2, 0x61, 0xeb, 0x7a,
	0xd5, 0x76, 0x92, 0x16, 0x29, 0xa7, 0xb5, 0xea, 0xdf, 0x41, 0x69, 0x13, 0x1b, 0xbd, 0x05, 0xa5,
	0x4d, 0x5c, 0x31, 0xd1, 0x12, 0x8e, 0x01, 0xf4, 0x00, 0x10, 0xa3, 0x2e, 0x71, 0x02, 0xea, 0x5a,
	0xb1, 0x5b, 0x56, 0xb8, 0xed, 0xad, 0x2d, 0xb1, 0xd8, 0xdb, 0xa0, 0xc4, 0xd3, 0x09, 0xc8, 0x50,
	0xa4, 0x5d, 0xc2, 0xf1, 0xc8, 0x06, 0x64, 0x58, 0x7f, 0x04, 0x4a, 0x2a, 0x49, 0x74, 0x07, 0x4a,
	0x0b, 0x9f, 0x32, 0x6b, 0x46, 0xa6, 0x34, 0x4a, 0xa1, 0xc8, 0x81, 0x1e, 0x99, 0x52, 0x74, 0x1b,
	0x8a, 0x64, 0x3e, 0x0f, 0x6d, 0x61, 0xdc, 0x6d, 0x32, 0x9f, 0x73, 0x53, 0xfd, 0xc5, 0x16, 0x94,
	0x75, 0xea, 0x3b, 0x6c, 0x34, 0x0f, 0x3c, 0x16, 0x4e, 0xf5, 0x6b, 0x28, 0x3c, 0xf5, 0x6c, 0xfe,
	0x32, 0xb6, 0x6a, 0x52, 0x23, 0xd7, 0x31, 0x57, 0xcb, 0xea, 0xd6, 0x27, 0x9e, 0x2d, 0x9e, 0xd7,
	0x47, 0xc3, 0x51, 0x70, 0xbe, 0xb0, 0x9b, 0x8e, 0x37, 0x6d, 0x6d, 0x1a, 0xe9, 0xda, 0xf1, 0xb9,
	0x35, 0x1f, 0x0f, 0x5b, 0xfc, 0x0b, 0xe2, 0x90, 0x80, 0x4c, 0xbc, 0x21, 0xff, 0x3f, 0xb7, 0x9b,
	0x82, 0x8f, 0xb7, 0x9e, 0x7a, 0xb6, 0xe9, 0x22, 0x0d, 0x80, 0xd1, 0xe7, 0x94, 0x05, 0x23, 0x7b,
	0x42, 0x2b, 0xdb, 0x35, 0xa9, 0x51, 0xc4, 0x09, 0x04, 0x55, 0x41, 0x1e, 0xcd, 0x2c, 0xe6, 0x4d,
	0x26, 0x36, 0x71, 0xc6, 0x95, 0x62, 0xe8, 0x30, 0x9a, 0xe1, 0x08, 0xf9, 0x0f, 0x1f, 0x5e, 0x1f,
	0x54, 0x67, 0xc1, 0x18, 0x6f, 0x76, 0xb8, 0xf2, 0xd4, 0xaf, 0xe4, 0x6b, 0xb9, 0x7f, 0xb4, 0xf4,
	0xe5, 0x48, 0xa1, 0x1f, 0x09, 0xa0, 0xbb, 0x10, 0x7d, 0x07, 0x2c, 0x46, 0x66, 0x63, 0xbf, 0x52,
	0xa8, 0xe5, 0x1a, 0x0a, 0x96, 0x43, 0x0c, 0x73, 0x08, 0x31, 0xb8, 0xc1, 0xe8, 0x84, 0x3e, 0x27,
	0x51, 0xe0, 0xd4, 0xcb, 0xff, 0xf0, 0xfa, 0xd0, 0xaf, 0x0c, 0xed, 0xb5, 0x4d, 0x40, 0x6b, 0xf5,
	0xfe, 0xff, 0xb3, 0x11, 0x07, 0xdf, 0x4b, 0xc9, 0x95, 0x38, 0x79, 0x75, 0x25, 0xfe, 0xd5, 0x3a,
	0x27, 0xb6, 0xe8, 0x1e, 0xec, 0xc6, 0x6b, 0xc1, 0xbb, 0x1a, 0x7e, 0x05, 0x71, 0xbc, 0x2c, 0xbc,
	0xaf, 0xf7, 0x7f, 0xce, 0x41, 0x21, 0x1c, 0x03, 0x92, 0x61, 0xfb, 0x49, 0xef, 0x71, 0xef, 0xe4,
	0xac, 0xa7, 0x66, 0x10, 0x40, 0xa1, 0xdd, 0xe9, 0x1b, 0xbd, 0x81, 0x2a, 0xf1, 0xf3, 0xe9, 0x93,
	0x4e, 0xd7, 0x7c, 0xa8, 0x66, 0xd1, 0x3e, 0xa8, 0x03, 0xdc, 0xee, 0xf5, 0x4d, 0xa3, 0x37, 0xb0,
	0x22, 0x8f, 0x1c, 0xa7, 0xea, 0xf8, 0xe4, 0xf4, 0xd4, 0xd0, 0xd5, 0x2d, 0x7e, 0x39, 0x39, 0x3a,
	0xea, 0x9a, 0x3d, 0x43, 0x2d, 0xa3, 0x5d, 0x80, 0x33, 0x6c, 0x0e, 0x0c, 0xeb, 0xa4, 0xd7, 0xfd,
	0x5c, 0x2d, 0xa0, 0x32, 0xc8, 0xba, 0xd1, 0x35, 0xd6, 0xc0, 0x36, 0x52, 0xa0, 0xf4, 0x59, 0xbb,
	0x6b, 0xea, 0xed, 0x81, 0xa1, 0xab, 0x45, 0x1e, 0xeb, 0xd8, 0xc0, 0x8f, 0x0c, 0x5d, 0x2d, 0x71,
	0xae, 0x38, 0x87, 0xae, 0xc0, 0xef, 0x9d, 0xf6, 0xc3, 0xc7, 0x47, 0x66, 0xb7, 0x6b, 0xe8, 0xaa,
	0x8c, 0xf6, 0x40, 0x59, 0xdf, 0x43, 0x97, 0x1d, 0x74, 0x1b, 0x6e, 0xc6, 0xe9, 0x25, 0x03, 0x29,
	0xa8, 0x02, 0xfb, 0xb1, 0x29, 0x91, 0xd3, 0x2e, 0xba, 0x03, 0xb7, 0x62, 0x4b, 0x5a, 0x51, 0x4d,
	0xd3, 0x12, 0xe1, 0xf7, 0xd2, 0x96, 0x44, 0xa2, 0x28, 0xdd, 0xa4, 0xa8, 0x9c, 0x1b, 0xe8, 0x16,
	0xdc, 0x88, 0xd1, 0xb8, 0xe6, 0xfd, 0xb4, 0x7b, 0xd4, 0xe9, 0x9b, 0xf5, 0x7c, 0x31, 0xaf, 0xe6,
	0x3b, 0xf7, 0x2f, 0x7e, 0xd7, 0x32, 0xbf, 0xae, 0x34, 0xe9, 0x62, 0xa5, 0x49, 0x97, 0x2b, 0x4d,
	0x7a, 0xb9, 0xd2, 0xa4, 0xdf, 0x56, 0x9a, 0xf4, 0xd3, 0x95, 0x96, 0xb9, 0xbc, 0xd2, 0x32, 0x2f,
	0xaf, 0xb4, 0xcc, 0x17, 0x79, 0xfe, 0x1a, 0xec, 0x82, 0xf8, 0xd5, 0xf0, 0xfe, 0x5f, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x81, 0xf4, 0x79, 0x4e, 0xd5, 0x08, 0x00, 0x00,
}

func (this *Target) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Target)
	if !ok {
		that2, ok := that.(Target)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ElementProto.Equal(&that1.ElementProto) {
		return false
	}
	if !this.Metadata.Equal(&that1.Metadata) {
		return false
	}
	if this.TargetStatus != that1.TargetStatus {
		return false
	}
	return true
}
func (this *TargetMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TargetMetadata)
	if !ok {
		that2, ok := that.(TargetMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubWorkID != that1.SubWorkID {
		return false
	}
	if this.SourceElementID != that1.SourceElementID {
		return false
	}
	if this.StatementID != that1.StatementID {
		return false
	}
	return true
}
func (this *TargetState) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TargetState)
	if !ok {
		that2, ok := that.(TargetState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Targets) != len(that1.Targets) {
		return false
	}
	for i := range this.Targets {
		if !this.Targets[i].Equal(&that1.Targets[i]) {
			return false
		}
	}
	if len(this.Statements) != len(that1.Statements) {
		return false
	}
	for i := range this.Statements {
		if !this.Statements[i].Equal(&that1.Statements[i]) {
			return false
		}
	}
	if !this.Authorization.Equal(&that1.Authorization) {
		return false
	}
	return true
}
func (this *Statement) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Statement)
	if !ok {
		that2, ok := that.(Statement)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Statement != that1.Statement {
		return false
	}
	if this.RedactedStatement != that1.RedactedStatement {
		return false
	}
	if this.StatementTag != that1.StatementTag {
		return false
	}
	return true
}
func (this *Authorization) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Authorization)
	if !ok {
		that2, ok := that.(Authorization)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserName != that1.UserName {
		return false
	}
	if this.AppName != that1.AppName {
		return false
	}
	return true
}
func (this *DescriptorState) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DescriptorState)
	if !ok {
		that2, ok := that.(DescriptorState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.JobID != that1.JobID {
		return false
	}
	if this.Revertible != that1.Revertible {
		return false
	}
	if this.InRollback != that1.InRollback {
		return false
	}
	if len(this.Targets) != len(that1.Targets) {
		return false
	}
	for i := range this.Targets {
		if !this.Targets[i].Equal(&that1.Targets[i]) {
			return false
		}
	}
	if len(this.CurrentStatuses) != len(that1.CurrentStatuses) {
		return false
	}
	for i := range this.CurrentStatuses {
		if this.CurrentStatuses[i] != that1.CurrentStatuses[i] {
			return false
		}
	}
	if len(this.TargetRanks) != len(that1.TargetRanks) {
		return false
	}
	for i := range this.TargetRanks {
		if this.TargetRanks[i] != that1.TargetRanks[i] {
			return false
		}
	}
	if len(this.RelevantStatements) != len(that1.RelevantStatements) {
		return false
	}
	for i := range this.RelevantStatements {
		if !this.RelevantStatements[i].Equal(&that1.RelevantStatements[i]) {
			return false
		}
	}
	if !this.Authorization.Equal(&that1.Authorization) {
		return false
	}
	return true
}
func (this *DescriptorState_Statement) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DescriptorState_Statement)
	if !ok {
		that2, ok := that.(DescriptorState_Statement)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Statement.Equal(&that1.Statement) {
		return false
	}
	if this.StatementRank != that1.StatementRank {
		return false
	}
	return true
}
func (m *Target) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Target) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Target) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TargetStatus != 0 {
		i = encodeVarintScpb(dAtA, i, uint64(m.TargetStatus))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintScpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ElementProto.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintScpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TargetMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TargetMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StatementID != 0 {
		i = encodeVarintScpb(dAtA, i, uint64(m.StatementID))
		i--
		dAtA[i] = 0x18
	}
	if m.SourceElementID != 0 {
		i = encodeVarintScpb(dAtA, i, uint64(m.SourceElementID))
		i--
		dAtA[i] = 0x10
	}
	if m.SubWorkID != 0 {
		i = encodeVarintScpb(dAtA, i, uint64(m.SubWorkID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TargetState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TargetState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Authorization.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintScpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Statements) > 0 {
		for iNdEx := len(m.Statements) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Statements[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Targets) > 0 {
		for iNdEx := len(m.Targets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Targets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Statement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Statement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Statement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StatementTag) > 0 {
		i -= len(m.StatementTag)
		copy(dAtA[i:], m.StatementTag)
		i = encodeVarintScpb(dAtA, i, uint64(len(m.StatementTag)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RedactedStatement) > 0 {
		i -= len(m.RedactedStatement)
		copy(dAtA[i:], m.RedactedStatement)
		i = encodeVarintScpb(dAtA, i, uint64(len(m.RedactedStatement)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Statement) > 0 {
		i -= len(m.Statement)
		copy(dAtA[i:], m.Statement)
		i = encodeVarintScpb(dAtA, i, uint64(len(m.Statement)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Authorization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Authorization) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Authorization) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AppName) > 0 {
		i -= len(m.AppName)
		copy(dAtA[i:], m.AppName)
		i = encodeVarintScpb(dAtA, i, uint64(len(m.AppName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintScpb(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DescriptorState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescriptorState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DescriptorState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InRollback {
		i--
		if m.InRollback {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Revertible {
		i--
		if m.Revertible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.TargetRanks) > 0 {
		dAtA5 := make([]byte, len(m.TargetRanks)*10)
		var j4 int
		for _, num := range m.TargetRanks {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintScpb(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x32
	}
	if m.JobID != 0 {
		i = encodeVarintScpb(dAtA, i, uint64(m.JobID))
		i--
		dAtA[i] = 0x28
	}
	if len(m.CurrentStatuses) > 0 {
		dAtA7 := make([]byte, len(m.CurrentStatuses)*10)
		var j6 int
		for _, num := range m.CurrentStatuses {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintScpb(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Authorization.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintScpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.RelevantStatements) > 0 {
		for iNdEx := len(m.RelevantStatements) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RelevantStatements[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Targets) > 0 {
		for iNdEx := len(m.Targets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Targets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DescriptorState_Statement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescriptorState_Statement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DescriptorState_Statement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StatementRank != 0 {
		i = encodeVarintScpb(dAtA, i, uint64(m.StatementRank))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Statement.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintScpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintScpb(dAtA []byte, offset int, v uint64) int {
	offset -= sovScpb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Target) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ElementProto.Size()
	n += 1 + l + sovScpb(uint64(l))
	l = m.Metadata.Size()
	n += 1 + l + sovScpb(uint64(l))
	if m.TargetStatus != 0 {
		n += 1 + sovScpb(uint64(m.TargetStatus))
	}
	return n
}

func (m *TargetMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubWorkID != 0 {
		n += 1 + sovScpb(uint64(m.SubWorkID))
	}
	if m.SourceElementID != 0 {
		n += 1 + sovScpb(uint64(m.SourceElementID))
	}
	if m.StatementID != 0 {
		n += 1 + sovScpb(uint64(m.StatementID))
	}
	return n
}

func (m *TargetState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for _, e := range m.Targets {
			l = e.Size()
			n += 1 + l + sovScpb(uint64(l))
		}
	}
	if len(m.Statements) > 0 {
		for _, e := range m.Statements {
			l = e.Size()
			n += 1 + l + sovScpb(uint64(l))
		}
	}
	l = m.Authorization.Size()
	n += 1 + l + sovScpb(uint64(l))
	return n
}

func (m *Statement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Statement)
	if l > 0 {
		n += 1 + l + sovScpb(uint64(l))
	}
	l = len(m.RedactedStatement)
	if l > 0 {
		n += 1 + l + sovScpb(uint64(l))
	}
	l = len(m.StatementTag)
	if l > 0 {
		n += 1 + l + sovScpb(uint64(l))
	}
	return n
}

func (m *Authorization) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovScpb(uint64(l))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovScpb(uint64(l))
	}
	return n
}

func (m *DescriptorState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for _, e := range m.Targets {
			l = e.Size()
			n += 1 + l + sovScpb(uint64(l))
		}
	}
	if len(m.RelevantStatements) > 0 {
		for _, e := range m.RelevantStatements {
			l = e.Size()
			n += 1 + l + sovScpb(uint64(l))
		}
	}
	l = m.Authorization.Size()
	n += 1 + l + sovScpb(uint64(l))
	if len(m.CurrentStatuses) > 0 {
		l = 0
		for _, e := range m.CurrentStatuses {
			l += sovScpb(uint64(e))
		}
		n += 1 + sovScpb(uint64(l)) + l
	}
	if m.JobID != 0 {
		n += 1 + sovScpb(uint64(m.JobID))
	}
	if len(m.TargetRanks) > 0 {
		l = 0
		for _, e := range m.TargetRanks {
			l += sovScpb(uint64(e))
		}
		n += 1 + sovScpb(uint64(l)) + l
	}
	if m.Revertible {
		n += 2
	}
	if m.InRollback {
		n += 2
	}
	return n
}

func (m *DescriptorState_Statement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Statement.Size()
	n += 1 + l + sovScpb(uint64(l))
	if m.StatementRank != 0 {
		n += 1 + sovScpb(uint64(m.StatementRank))
	}
	return n
}

func sovScpb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozScpb(x uint64) (n int) {
	return sovScpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Target) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Target: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Target: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElementProto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ElementProto.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetStatus", wireType)
			}
			m.TargetStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetStatus |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubWorkID", wireType)
			}
			m.SubWorkID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubWorkID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceElementID", wireType)
			}
			m.SourceElementID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceElementID |= SourceElementID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementID", wireType)
			}
			m.StatementID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatementID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Targets = append(m.Targets, Target{})
			if err := m.Targets[len(m.Targets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statements = append(m.Statements, Statement{})
			if err := m.Statements[len(m.Statements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authorization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Authorization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Statement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Statement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Statement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedactedStatement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedactedStatement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatementTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Authorization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Authorization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Authorization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescriptorState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescriptorState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescriptorState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Targets = append(m.Targets, Target{})
			if err := m.Targets[len(m.Targets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelevantStatements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelevantStatements = append(m.RelevantStatements, DescriptorState_Statement{})
			if err := m.RelevantStatements[len(m.RelevantStatements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authorization", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Authorization.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v Status
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Status(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CurrentStatuses = append(m.CurrentStatuses, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthScpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthScpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.CurrentStatuses) == 0 {
					m.CurrentStatuses = make([]Status, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Status
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Status(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CurrentStatuses = append(m.CurrentStatuses, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentStatuses", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.JobID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TargetRanks = append(m.TargetRanks, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthScpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthScpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TargetRanks) == 0 {
					m.TargetRanks = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TargetRanks = append(m.TargetRanks, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetRanks", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revertible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Revertible = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InRollback", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InRollback = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipScpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescriptorState_Statement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Statement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Statement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Statement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementRank", wireType)
			}
			m.StatementRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatementRank |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipScpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthScpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipScpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowScpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthScpb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupScpb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthScpb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthScpb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowScpb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupScpb = fmt.Errorf("proto: unexpected end of group")
)
