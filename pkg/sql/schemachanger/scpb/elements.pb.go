// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/schemachanger/scpb/elements.proto

package scpb

import (
	fmt "fmt"
	catpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb"
	github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb"
	github_com_cockroachdb_cockroach_pkg_sql_sem_catid "github.com/cockroachdb/cockroach/pkg/sql/sem/catid"
	types "github.com/cockroachdb/cockroach/pkg/sql/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ConstraintType int32

const (
	ConstraintType_Invalid            ConstraintType = 0
	ConstraintType_UniqueWithoutIndex ConstraintType = 1
	ConstraintType_Check              ConstraintType = 2
	ConstraintType_FK                 ConstraintType = 3
	ConstraintType_PrimaryKey         ConstraintType = 4
)

var ConstraintType_name = map[int32]string{
	0: "Invalid",
	1: "UniqueWithoutIndex",
	2: "Check",
	3: "FK",
	4: "PrimaryKey",
}

var ConstraintType_value = map[string]int32{
	"Invalid":            0,
	"UniqueWithoutIndex": 1,
	"Check":              2,
	"FK":                 3,
	"PrimaryKey":         4,
}

func (x ConstraintType) String() string {
	return proto.EnumName(ConstraintType_name, int32(x))
}

func (ConstraintType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{0}
}

// The direction of a column in the index.
type PrimaryIndex_Direction int32

const (
	PrimaryIndex_ASC  PrimaryIndex_Direction = 0
	PrimaryIndex_DESC PrimaryIndex_Direction = 1
)

var PrimaryIndex_Direction_name = map[int32]string{
	0: "ASC",
	1: "DESC",
}

var PrimaryIndex_Direction_value = map[string]int32{
	"ASC":  0,
	"DESC": 1,
}

func (x PrimaryIndex_Direction) String() string {
	return proto.EnumName(PrimaryIndex_Direction_name, int32(x))
}

func (PrimaryIndex_Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{2, 0}
}

// The direction of a column in the index.
type SecondaryIndex_Direction int32

const (
	SecondaryIndex_ASC  SecondaryIndex_Direction = 0
	SecondaryIndex_DESC SecondaryIndex_Direction = 1
)

var SecondaryIndex_Direction_name = map[int32]string{
	0: "ASC",
	1: "DESC",
}

var SecondaryIndex_Direction_value = map[string]int32{
	"ASC":  0,
	"DESC": 1,
}

func (x SecondaryIndex_Direction) String() string {
	return proto.EnumName(SecondaryIndex_Direction_name, int32(x))
}

func (SecondaryIndex_Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{3, 0}
}

type SequenceDependency_Type int32

const (
	SequenceDependency_UNKNOWN SequenceDependency_Type = 0
	SequenceDependency_USES    SequenceDependency_Type = 1
	SequenceDependency_OWNS    SequenceDependency_Type = 2
)

var SequenceDependency_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "USES",
	2: "OWNS",
}

var SequenceDependency_Type_value = map[string]int32{
	"UNKNOWN": 0,
	"USES":    1,
	"OWNS":    2,
}

func (x SequenceDependency_Type) String() string {
	return proto.EnumName(SequenceDependency_Type_name, int32(x))
}

func (SequenceDependency_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{4, 0}
}

type ElementProto struct {
	Column                       *Column                       `protobuf:"bytes,1,opt,name=column,proto3" json:"column,omitempty" parent:"Table"`
	PrimaryIndex                 *PrimaryIndex                 `protobuf:"bytes,2,opt,name=primary_index,json=primaryIndex,proto3" json:"primary_index,omitempty" parent:"Table"`
	SecondaryIndex               *SecondaryIndex               `protobuf:"bytes,3,opt,name=secondary_index,json=secondaryIndex,proto3" json:"secondary_index,omitempty" parent:"Table"`
	SequenceDependency           *SequenceDependency           `protobuf:"bytes,4,opt,name=sequence_dependency,json=sequenceDependency,proto3" json:"sequence_dependency,omitempty" parent:"Column, Table"`
	UniqueConstraint             *UniqueConstraint             `protobuf:"bytes,5,opt,name=unique_constraint,json=uniqueConstraint,proto3" json:"unique_constraint,omitempty" parent:"SecondaryIndex, Table"`
	CheckConstraint              *CheckConstraint              `protobuf:"bytes,6,opt,name=check_constraint,json=checkConstraint,proto3" json:"check_constraint,omitempty" parent:"Table"`
	Sequence                     *Sequence                     `protobuf:"bytes,7,opt,name=sequence,proto3" json:"sequence,omitempty"`
	DefaultExpression            *DefaultExpression            `protobuf:"bytes,8,opt,name=default_expression,json=defaultExpression,proto3" json:"default_expression,omitempty" parent:"Column"`
	View                         *View                         `protobuf:"bytes,9,opt,name=view,proto3" json:"view,omitempty"`
	Table                        *Table                        `protobuf:"bytes,10,opt,name=table,proto3" json:"table,omitempty"`
	OutForeignKey                *ForeignKey                   `protobuf:"bytes,11,opt,name=out_foreign_key,json=outForeignKey,proto3" json:"out_foreign_key,omitempty" parent:"Table"`
	InForeignKey                 *ForeignKeyBackReference      `protobuf:"bytes,12,opt,name=in_foreign_key,json=inForeignKey,proto3" json:"in_foreign_key,omitempty" parent:"Table"`
	RelationDependedOnBy         *RelationDependedOnBy         `protobuf:"bytes,13,opt,name=relation_depended_on_by,json=relationDependedOnBy,proto3" json:"relation_depended_on_by,omitempty" parent:"Table, View"`
	SequenceOwner                *SequenceOwnedBy              `protobuf:"bytes,45,opt,name=sequence_owner,json=sequenceOwner,proto3" json:"sequence_owner,omitempty" parent:"Column, Sequence"`
	Type                         *Type                         `protobuf:"bytes,15,opt,name=type,proto3" json:"type,omitempty"`
	Schema                       *Schema                       `protobuf:"bytes,16,opt,name=schema,proto3" json:"schema,omitempty"`
	Database                     *Database                     `protobuf:"bytes,17,opt,name=database,proto3" json:"database,omitempty"`
	Partitioning                 *IndexPartitioning            `protobuf:"bytes,18,opt,name=partitioning,proto3" json:"partitioning,omitempty" parent:"PrimaryIndex, SecondaryIndex"`
	Namespace                    *Namespace                    `protobuf:"bytes,19,opt,name=namespace,proto3" json:"namespace,omitempty" parent:"Table, View, Sequence, Database, Schema, Type"`
	Owner                        *Owner                        `protobuf:"bytes,20,opt,name=owner,proto3" json:"owner,omitempty" parent:"Table, View, Sequence, Database, Schema"`
	UserPrivileges               *UserPrivileges               `protobuf:"bytes,21,opt,name=user_privileges,json=userPrivileges,proto3" json:"user_privileges,omitempty" parent:"Table, View, Sequence, Database, Schema"`
	ColumnName                   *ColumnName                   `protobuf:"bytes,22,opt,name=column_name,json=columnName,proto3" json:"column_name,omitempty" parent:"Column"`
	Locality                     *Locality                     `protobuf:"bytes,23,opt,name=locality,proto3" json:"locality,omitempty" parent:"Table"`
	IndexName                    *IndexName                    `protobuf:"bytes,24,opt,name=index_name,json=indexName,proto3" json:"index_name,omitempty" parent:"PrimaryIndex, SecondaryIndex"`
	ConstraintName               *ConstraintName               `protobuf:"bytes,25,opt,name=constraint_name,json=constraintName,proto3" json:"constraint_name,omitempty" parent:"UniqueConstraint, CheckConstraint"`
	DefaultExprTypeRef           *DefaultExprTypeReference     `protobuf:"bytes,26,opt,name=default_expr_type_ref,json=defaultExprTypeRef,proto3" json:"default_expr_type_ref,omitempty" parent:"Column, Type"`
	OnUpdateTypeReference        *OnUpdateExprTypeReference    `protobuf:"bytes,27,opt,name=on_update_type_reference,json=onUpdateTypeReference,proto3" json:"on_update_type_reference,omitempty" parent:"Column, Type"`
	ComputedExprTypeReference    *ComputedExprTypeReference    `protobuf:"bytes,28,opt,name=computed_expr_type_reference,json=computedExprTypeReference,proto3" json:"computed_expr_type_reference,omitempty" parent:"Column, Type"`
	ViewDependsOnType            *ViewDependsOnType            `protobuf:"bytes,29,opt,name=view_depends_on_type,json=viewDependsOnType,proto3" json:"view_depends_on_type,omitempty" parent:"View, Type"`
	ColumnTypeReference          *ColumnTypeReference          `protobuf:"bytes,30,opt,name=column_type_reference,json=columnTypeReference,proto3" json:"column_type_reference,omitempty" parent:"Column, Type"`
	SchemaEntry                  *DatabaseSchemaEntry          `protobuf:"bytes,31,opt,name=schema_entry,json=schemaEntry,proto3" json:"schema_entry,omitempty" parent:"Database, Schema"`
	CheckConstraintTypeReference *CheckConstraintTypeReference `protobuf:"bytes,32,opt,name=check_constraint_type_reference,json=checkConstraintTypeReference,proto3" json:"check_constraint_type_reference,omitempty" parent:"Table, Type"`
	TableComment                 *TableComment                 `protobuf:"bytes,33,opt,name=table_comment,json=tableComment,proto3" json:"table_comment,omitempty" parent:"Table, View, Sequence"`
	DatabaseComment              *DatabaseComment              `protobuf:"bytes,35,opt,name=database_comment,json=databaseComment,proto3" json:"database_comment,omitempty" parent:"Database"`
	SchemaComment                *SchemaComment                `protobuf:"bytes,36,opt,name=schema_comment,json=schemaComment,proto3" json:"schema_comment,omitempty" parent:"Schema"`
	IndexComment                 *IndexComment                 `protobuf:"bytes,37,opt,name=index_comment,json=indexComment,proto3" json:"index_comment,omitempty" parent:"Index"`
	ColumnComment                *ColumnComment                `protobuf:"bytes,38,opt,name=column_comment,json=columnComment,proto3" json:"column_comment,omitempty" parent:"Column"`
	ConstraintComment            *ConstraintComment            `protobuf:"bytes,39,opt,name=constraint_comment,json=constraintComment,proto3" json:"constraint_comment,omitempty" parent:"PrimaryIndex, SecondaryIndex, ForeignKey, UniqueConstraint, CheckConstraint"`
	DatabaseRoleSetting          *DatabaseRoleSetting          `protobuf:"bytes,40,opt,name=database_role_setting,json=databaseRoleSetting,proto3" json:"database_role_setting,omitempty" parent:"Database"`
	RowLevelTTL                  *RowLevelTTL                  `protobuf:"bytes,41,opt,name=row_level_ttl,json=rowLevelTtl,proto3" json:"row_level_ttl,omitempty" parent:"Table"`
}

func (m *ElementProto) Reset()         { *m = ElementProto{} }
func (m *ElementProto) String() string { return proto.CompactTextString(m) }
func (*ElementProto) ProtoMessage()    {}
func (*ElementProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{0}
}
func (m *ElementProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ElementProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ElementProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ElementProto.Merge(m, src)
}
func (m *ElementProto) XXX_Size() int {
	return m.Size()
}
func (m *ElementProto) XXX_DiscardUnknown() {
	xxx_messageInfo_ElementProto.DiscardUnknown(m)
}

var xxx_messageInfo_ElementProto proto.InternalMessageInfo

type Column struct {
	TableID                           github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID                      `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID                          github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID                    `protobuf:"varint,3,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	FamilyID                          github_com_cockroachdb_cockroach_pkg_sql_sem_catid.FamilyID                    `protobuf:"varint,4,opt,name=family_id,json=familyId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.FamilyID" json:"family_id,omitempty"`
	FamilyName                        string                                                                         `protobuf:"bytes,5,opt,name=family_name,json=familyName,proto3" json:"family_name,omitempty"`
	Type                              *types.T                                                                       `protobuf:"bytes,6,opt,name=type,proto3" json:"type,omitempty"`
	Nullable                          bool                                                                           `protobuf:"varint,7,opt,name=nullable,proto3" json:"nullable,omitempty"`
	DefaultExpr                       string                                                                         `protobuf:"bytes,8,opt,name=default_expr,json=defaultExpr,proto3" json:"default_expr,omitempty"`
	OnUpdateExpr                      string                                                                         `protobuf:"bytes,9,opt,name=on_update_expr,json=onUpdateExpr,proto3" json:"on_update_expr,omitempty"`
	Hidden                            bool                                                                           `protobuf:"varint,10,opt,name=hidden,proto3" json:"hidden,omitempty"`
	Inaccessible                      bool                                                                           `protobuf:"varint,11,opt,name=inaccessible,proto3" json:"inaccessible,omitempty"`
	GeneratedAsIdentityType           github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.GeneratedAsIdentityType `protobuf:"varint,12,opt,name=generated_as_identity_type,json=generatedAsIdentityType,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.GeneratedAsIdentityType" json:"generated_as_identity_type,omitempty"`
	GeneratedAsIdentitySequenceOption string                                                                         `protobuf:"bytes,13,opt,name=generated_as_identity_sequence_option,json=generatedAsIdentitySequenceOption,proto3" json:"generated_as_identity_sequence_option,omitempty"`
	UsesSequenceIDs                   []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID                    `protobuf:"varint,14,rep,packed,name=uses_sequence_ids,json=usesSequenceIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_sequence_ids,omitempty"`
	ComputerExpr                      string                                                                         `protobuf:"bytes,15,opt,name=computer_expr,json=computerExpr,proto3" json:"computer_expr,omitempty"`
	PgAttributeNum                    uint32                                                                         `protobuf:"varint,16,opt,name=pg_attribute_num,json=pgAttributeNum,proto3" json:"pg_attribute_num,omitempty"`
	SystemColumnKind                  github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.SystemColumnKind        `protobuf:"varint,17,opt,name=system_column_kind,json=systemColumnKind,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.SystemColumnKind" json:"system_column_kind,omitempty"`
	Virtual                           bool                                                                           `protobuf:"varint,18,opt,name=virtual,proto3" json:"virtual,omitempty"`
}

func (m *Column) Reset()         { *m = Column{} }
func (m *Column) String() string { return proto.CompactTextString(m) }
func (*Column) ProtoMessage()    {}
func (*Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{1}
}
func (m *Column) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Column.Merge(m, src)
}
func (m *Column) XXX_Size() int {
	return m.Size()
}
func (m *Column) XXX_DiscardUnknown() {
	xxx_messageInfo_Column.DiscardUnknown(m)
}

var xxx_messageInfo_Column proto.InternalMessageInfo

type PrimaryIndex struct {
	TableID             github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID     `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID             github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID    `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	Unique              bool                                                          `protobuf:"varint,3,opt,name=unique,proto3" json:"unique,omitempty"`
	KeyColumnIDs        []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,4,rep,packed,name=key_column_ids,json=keyColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"key_column_ids,omitempty"`
	KeyColumnDirections []PrimaryIndex_Direction                                      `protobuf:"varint,5,rep,packed,name=key_column_directions,json=keyColumnDirections,proto3,enum=cockroach.sql.schemachanger.scpb.PrimaryIndex_Direction" json:"key_column_directions,omitempty"`
	KeySuffixColumnIDs  []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,6,rep,packed,name=key_suffix_column_ids,json=keySuffixColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"key_suffix_column_ids,omitempty"`
	ShardedDescriptor   *catpb.ShardedDescriptor                                      `protobuf:"bytes,7,opt,name=sharded_descriptor,json=shardedDescriptor,proto3" json:"sharded_descriptor,omitempty"`
	StoringColumnIDs    []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,8,rep,packed,name=storing_column_ids,json=storingColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"storing_column_ids,omitempty"`
	CompositeColumnIDs  []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,9,rep,packed,name=composite_column_ids,json=compositeColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"composite_column_ids,omitempty"`
	Inverted            bool                                                          `protobuf:"varint,10,opt,name=inverted,proto3" json:"inverted,omitempty"`
	Concurrently        bool                                                          `protobuf:"varint,11,opt,name=concurrently,proto3" json:"concurrently,omitempty"`
	// SourceIndexID refers to the primary index which will be used to
	// to backfill this index.
	SourceIndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,12,opt,name=source_index_id,json=sourceIndexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"source_index_id,omitempty"`
}

func (m *PrimaryIndex) Reset()         { *m = PrimaryIndex{} }
func (m *PrimaryIndex) String() string { return proto.CompactTextString(m) }
func (*PrimaryIndex) ProtoMessage()    {}
func (*PrimaryIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{2}
}
func (m *PrimaryIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrimaryIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PrimaryIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrimaryIndex.Merge(m, src)
}
func (m *PrimaryIndex) XXX_Size() int {
	return m.Size()
}
func (m *PrimaryIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_PrimaryIndex.DiscardUnknown(m)
}

var xxx_messageInfo_PrimaryIndex proto.InternalMessageInfo

type SecondaryIndex struct {
	TableID             github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID     `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID             github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID    `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	Unique              bool                                                          `protobuf:"varint,3,opt,name=unique,proto3" json:"unique,omitempty"`
	KeyColumnIDs        []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,4,rep,packed,name=key_column_ids,json=keyColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"key_column_ids,omitempty"`
	KeyColumnDirections []SecondaryIndex_Direction                                    `protobuf:"varint,5,rep,packed,name=key_column_directions,json=keyColumnDirections,proto3,enum=cockroach.sql.schemachanger.scpb.SecondaryIndex_Direction" json:"key_column_directions,omitempty"`
	KeySuffixColumnIDs  []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,6,rep,packed,name=key_suffix_column_ids,json=keySuffixColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"key_suffix_column_ids,omitempty"`
	ShardedDescriptor   *catpb.ShardedDescriptor                                      `protobuf:"bytes,7,opt,name=sharded_descriptor,json=shardedDescriptor,proto3" json:"sharded_descriptor,omitempty"`
	StoringColumnIDs    []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,8,rep,packed,name=storing_column_ids,json=storingColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"storing_column_ids,omitempty"`
	CompositeColumnIDs  []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,9,rep,packed,name=composite_column_ids,json=compositeColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"composite_column_ids,omitempty"`
	Inverted            bool                                                          `protobuf:"varint,10,opt,name=inverted,proto3" json:"inverted,omitempty"`
	Concurrently        bool                                                          `protobuf:"varint,11,opt,name=concurrently,proto3" json:"concurrently,omitempty"`
	// SourceIndexID refers to the primary index which will be used to
	// to backfill this index.
	SourceIndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,12,opt,name=source_index_id,json=sourceIndexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"source_index_id,omitempty"`
}

func (m *SecondaryIndex) Reset()         { *m = SecondaryIndex{} }
func (m *SecondaryIndex) String() string { return proto.CompactTextString(m) }
func (*SecondaryIndex) ProtoMessage()    {}
func (*SecondaryIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{3}
}
func (m *SecondaryIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecondaryIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SecondaryIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecondaryIndex.Merge(m, src)
}
func (m *SecondaryIndex) XXX_Size() int {
	return m.Size()
}
func (m *SecondaryIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_SecondaryIndex.DiscardUnknown(m)
}

var xxx_messageInfo_SecondaryIndex proto.InternalMessageInfo

type SequenceDependency struct {
	TableID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	SequenceID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,3,opt,name=sequence_id,json=sequenceId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"sequence_id,omitempty"`
	Type       SequenceDependency_Type                                     `protobuf:"varint,4,opt,name=type,proto3,enum=cockroach.sql.schemachanger.scpb.SequenceDependency_Type" json:"type,omitempty"`
}

func (m *SequenceDependency) Reset()         { *m = SequenceDependency{} }
func (m *SequenceDependency) String() string { return proto.CompactTextString(m) }
func (*SequenceDependency) ProtoMessage()    {}
func (*SequenceDependency) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{4}
}
func (m *SequenceDependency) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SequenceDependency) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SequenceDependency) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SequenceDependency.Merge(m, src)
}
func (m *SequenceDependency) XXX_Size() int {
	return m.Size()
}
func (m *SequenceDependency) XXX_DiscardUnknown() {
	xxx_messageInfo_SequenceDependency.DiscardUnknown(m)
}

var xxx_messageInfo_SequenceDependency proto.InternalMessageInfo

type UniqueConstraint struct {
	ConstraintType    ConstraintType                                                `protobuf:"varint,1,opt,name=constraint_type,json=constraintType,proto3,enum=cockroach.sql.schemachanger.scpb.ConstraintType" json:"constraint_type,omitempty"`
	ConstraintOrdinal uint32                                                        `protobuf:"varint,2,opt,name=constraint_ordinal,json=constraintOrdinal,proto3" json:"constraint_ordinal,omitempty"`
	TableID           github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID     `protobuf:"varint,3,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID           github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID    `protobuf:"varint,4,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	ColumnIDs         []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,5,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
}

func (m *UniqueConstraint) Reset()         { *m = UniqueConstraint{} }
func (m *UniqueConstraint) String() string { return proto.CompactTextString(m) }
func (*UniqueConstraint) ProtoMessage()    {}
func (*UniqueConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{5}
}
func (m *UniqueConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UniqueConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UniqueConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UniqueConstraint.Merge(m, src)
}
func (m *UniqueConstraint) XXX_Size() int {
	return m.Size()
}
func (m *UniqueConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_UniqueConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_UniqueConstraint proto.InternalMessageInfo

type CheckConstraint struct {
	ConstraintType    ConstraintType                                                `protobuf:"varint,1,opt,name=constraint_type,json=constraintType,proto3,enum=cockroach.sql.schemachanger.scpb.ConstraintType" json:"constraint_type,omitempty"`
	ConstraintOrdinal uint32                                                        `protobuf:"varint,2,opt,name=constraint_ordinal,json=constraintOrdinal,proto3" json:"constraint_ordinal,omitempty"`
	TableID           github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID     `protobuf:"varint,3,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	Name              string                                                        `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Expr              string                                                        `protobuf:"bytes,5,opt,name=expr,proto3" json:"expr,omitempty"`
	ColumnIDs         []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,6,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
	Validated         bool                                                          `protobuf:"varint,7,opt,name=validated,proto3" json:"validated,omitempty"`
}

func (m *CheckConstraint) Reset()         { *m = CheckConstraint{} }
func (m *CheckConstraint) String() string { return proto.CompactTextString(m) }
func (*CheckConstraint) ProtoMessage()    {}
func (*CheckConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{6}
}
func (m *CheckConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CheckConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckConstraint.Merge(m, src)
}
func (m *CheckConstraint) XXX_Size() int {
	return m.Size()
}
func (m *CheckConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_CheckConstraint proto.InternalMessageInfo

type Sequence struct {
	SequenceID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=sequence_id,json=sequenceId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"sequence_id,omitempty"`
}

func (m *Sequence) Reset()         { *m = Sequence{} }
func (m *Sequence) String() string { return proto.CompactTextString(m) }
func (*Sequence) ProtoMessage()    {}
func (*Sequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{7}
}
func (m *Sequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Sequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sequence.Merge(m, src)
}
func (m *Sequence) XXX_Size() int {
	return m.Size()
}
func (m *Sequence) XXX_DiscardUnknown() {
	xxx_messageInfo_Sequence.DiscardUnknown(m)
}

var xxx_messageInfo_Sequence proto.InternalMessageInfo

type DefaultExpression struct {
	TableID         github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID        github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	UsesSequenceIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,3,rep,packed,name=uses_sequence_ids,json=usesSequenceIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_sequence_ids,omitempty"`
	DefaultExpr     string                                                      `protobuf:"bytes,4,opt,name=default_expr,json=defaultExpr,proto3" json:"default_expr,omitempty"`
}

func (m *DefaultExpression) Reset()         { *m = DefaultExpression{} }
func (m *DefaultExpression) String() string { return proto.CompactTextString(m) }
func (*DefaultExpression) ProtoMessage()    {}
func (*DefaultExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{8}
}
func (m *DefaultExpression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefaultExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DefaultExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefaultExpression.Merge(m, src)
}
func (m *DefaultExpression) XXX_Size() int {
	return m.Size()
}
func (m *DefaultExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_DefaultExpression.DiscardUnknown(m)
}

var xxx_messageInfo_DefaultExpression proto.InternalMessageInfo

type View struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
}

func (m *View) Reset()         { *m = View{} }
func (m *View) String() string { return proto.CompactTextString(m) }
func (*View) ProtoMessage()    {}
func (*View) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{9}
}
func (m *View) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *View) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *View) XXX_Merge(src proto.Message) {
	xxx_messageInfo_View.Merge(m, src)
}
func (m *View) XXX_Size() int {
	return m.Size()
}
func (m *View) XXX_DiscardUnknown() {
	xxx_messageInfo_View.DiscardUnknown(m)
}

var xxx_messageInfo_View proto.InternalMessageInfo

type Table struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
}

func (m *Table) Reset()         { *m = Table{} }
func (m *Table) String() string { return proto.CompactTextString(m) }
func (*Table) ProtoMessage()    {}
func (*Table) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{10}
}
func (m *Table) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Table) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Table) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Table.Merge(m, src)
}
func (m *Table) XXX_Size() int {
	return m.Size()
}
func (m *Table) XXX_DiscardUnknown() {
	xxx_messageInfo_Table.DiscardUnknown(m)
}

var xxx_messageInfo_Table proto.InternalMessageInfo

type OnUpdateExprTypeReference struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	TypeID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,3,opt,name=type_id,json=typeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"type_id,omitempty"`
}

func (m *OnUpdateExprTypeReference) Reset()         { *m = OnUpdateExprTypeReference{} }
func (m *OnUpdateExprTypeReference) String() string { return proto.CompactTextString(m) }
func (*OnUpdateExprTypeReference) ProtoMessage()    {}
func (*OnUpdateExprTypeReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{11}
}
func (m *OnUpdateExprTypeReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OnUpdateExprTypeReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OnUpdateExprTypeReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnUpdateExprTypeReference.Merge(m, src)
}
func (m *OnUpdateExprTypeReference) XXX_Size() int {
	return m.Size()
}
func (m *OnUpdateExprTypeReference) XXX_DiscardUnknown() {
	xxx_messageInfo_OnUpdateExprTypeReference.DiscardUnknown(m)
}

var xxx_messageInfo_OnUpdateExprTypeReference proto.InternalMessageInfo

type ComputedExprTypeReference struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	TypeID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,3,opt,name=type_id,json=typeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"type_id,omitempty"`
}

func (m *ComputedExprTypeReference) Reset()         { *m = ComputedExprTypeReference{} }
func (m *ComputedExprTypeReference) String() string { return proto.CompactTextString(m) }
func (*ComputedExprTypeReference) ProtoMessage()    {}
func (*ComputedExprTypeReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{12}
}
func (m *ComputedExprTypeReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComputedExprTypeReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ComputedExprTypeReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComputedExprTypeReference.Merge(m, src)
}
func (m *ComputedExprTypeReference) XXX_Size() int {
	return m.Size()
}
func (m *ComputedExprTypeReference) XXX_DiscardUnknown() {
	xxx_messageInfo_ComputedExprTypeReference.DiscardUnknown(m)
}

var xxx_messageInfo_ComputedExprTypeReference proto.InternalMessageInfo

type DefaultExprTypeReference struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	TypeID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,3,opt,name=type_id,json=typeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"type_id,omitempty"`
}

func (m *DefaultExprTypeReference) Reset()         { *m = DefaultExprTypeReference{} }
func (m *DefaultExprTypeReference) String() string { return proto.CompactTextString(m) }
func (*DefaultExprTypeReference) ProtoMessage()    {}
func (*DefaultExprTypeReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{13}
}
func (m *DefaultExprTypeReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefaultExprTypeReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DefaultExprTypeReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefaultExprTypeReference.Merge(m, src)
}
func (m *DefaultExprTypeReference) XXX_Size() int {
	return m.Size()
}
func (m *DefaultExprTypeReference) XXX_DiscardUnknown() {
	xxx_messageInfo_DefaultExprTypeReference.DiscardUnknown(m)
}

var xxx_messageInfo_DefaultExprTypeReference proto.InternalMessageInfo

type ColumnTypeReference struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	TypeID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,3,opt,name=type_id,json=typeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"type_id,omitempty"`
}

func (m *ColumnTypeReference) Reset()         { *m = ColumnTypeReference{} }
func (m *ColumnTypeReference) String() string { return proto.CompactTextString(m) }
func (*ColumnTypeReference) ProtoMessage()    {}
func (*ColumnTypeReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{14}
}
func (m *ColumnTypeReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnTypeReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnTypeReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnTypeReference.Merge(m, src)
}
func (m *ColumnTypeReference) XXX_Size() int {
	return m.Size()
}
func (m *ColumnTypeReference) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnTypeReference.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnTypeReference proto.InternalMessageInfo

type CheckConstraintTypeReference struct {
	TableID           github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintOrdinal uint32                                                    `protobuf:"varint,2,opt,name=constraint_ordinal,json=constraintOrdinal,proto3" json:"constraint_ordinal,omitempty"`
	TypeID            github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,3,opt,name=type_id,json=typeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"type_id,omitempty"`
}

func (m *CheckConstraintTypeReference) Reset()         { *m = CheckConstraintTypeReference{} }
func (m *CheckConstraintTypeReference) String() string { return proto.CompactTextString(m) }
func (*CheckConstraintTypeReference) ProtoMessage()    {}
func (*CheckConstraintTypeReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{15}
}
func (m *CheckConstraintTypeReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckConstraintTypeReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CheckConstraintTypeReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckConstraintTypeReference.Merge(m, src)
}
func (m *CheckConstraintTypeReference) XXX_Size() int {
	return m.Size()
}
func (m *CheckConstraintTypeReference) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckConstraintTypeReference.DiscardUnknown(m)
}

var xxx_messageInfo_CheckConstraintTypeReference proto.InternalMessageInfo

type ViewDependsOnType struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	TypeID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,3,opt,name=type_id,json=typeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"type_id,omitempty"`
}

func (m *ViewDependsOnType) Reset()         { *m = ViewDependsOnType{} }
func (m *ViewDependsOnType) String() string { return proto.CompactTextString(m) }
func (*ViewDependsOnType) ProtoMessage()    {}
func (*ViewDependsOnType) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{16}
}
func (m *ViewDependsOnType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewDependsOnType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ViewDependsOnType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewDependsOnType.Merge(m, src)
}
func (m *ViewDependsOnType) XXX_Size() int {
	return m.Size()
}
func (m *ViewDependsOnType) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewDependsOnType.DiscardUnknown(m)
}

var xxx_messageInfo_ViewDependsOnType proto.InternalMessageInfo

type ForeignKey struct {
	OriginID         github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID               `protobuf:"varint,1,opt,name=origin_id,json=originId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"origin_id,omitempty"`
	OriginColumns    []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID           `protobuf:"varint,3,rep,packed,name=origin_columns,json=originColumns,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"origin_columns,omitempty"`
	ReferenceID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID               `protobuf:"varint,4,opt,name=reference_id,json=referenceId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"reference_id,omitempty"`
	ReferenceColumns []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID           `protobuf:"varint,5,rep,packed,name=reference_columns,json=referenceColumns,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"reference_columns,omitempty"`
	OnUpdate         github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.ForeignKeyAction `protobuf:"varint,6,opt,name=on_update,json=onUpdate,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.ForeignKeyAction" json:"on_update,omitempty"`
	OnDelete         github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.ForeignKeyAction `protobuf:"varint,7,opt,name=on_delete,json=onDelete,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.ForeignKeyAction" json:"on_delete,omitempty"`
	Name             string                                                                  `protobuf:"bytes,8,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ForeignKey) Reset()         { *m = ForeignKey{} }
func (m *ForeignKey) String() string { return proto.CompactTextString(m) }
func (*ForeignKey) ProtoMessage()    {}
func (*ForeignKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{17}
}
func (m *ForeignKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForeignKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ForeignKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForeignKey.Merge(m, src)
}
func (m *ForeignKey) XXX_Size() int {
	return m.Size()
}
func (m *ForeignKey) XXX_DiscardUnknown() {
	xxx_messageInfo_ForeignKey.DiscardUnknown(m)
}

var xxx_messageInfo_ForeignKey proto.InternalMessageInfo

type ForeignKeyBackReference struct {
	OriginID         github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID               `protobuf:"varint,1,opt,name=origin_id,json=originId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"origin_id,omitempty"`
	OriginColumns    []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID           `protobuf:"varint,3,rep,packed,name=origin_columns,json=originColumns,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"origin_columns,omitempty"`
	ReferenceID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID               `protobuf:"varint,4,opt,name=reference_id,json=referenceId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"reference_id,omitempty"`
	ReferenceColumns []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID           `protobuf:"varint,5,rep,packed,name=reference_columns,json=referenceColumns,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"reference_columns,omitempty"`
	OnUpdate         github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.ForeignKeyAction `protobuf:"varint,6,opt,name=on_update,json=onUpdate,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.ForeignKeyAction" json:"on_update,omitempty"`
	OnDelete         github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.ForeignKeyAction `protobuf:"varint,7,opt,name=on_delete,json=onDelete,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.ForeignKeyAction" json:"on_delete,omitempty"`
	Name             string                                                                  `protobuf:"bytes,8,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ForeignKeyBackReference) Reset()         { *m = ForeignKeyBackReference{} }
func (m *ForeignKeyBackReference) String() string { return proto.CompactTextString(m) }
func (*ForeignKeyBackReference) ProtoMessage()    {}
func (*ForeignKeyBackReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{18}
}
func (m *ForeignKeyBackReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForeignKeyBackReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ForeignKeyBackReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForeignKeyBackReference.Merge(m, src)
}
func (m *ForeignKeyBackReference) XXX_Size() int {
	return m.Size()
}
func (m *ForeignKeyBackReference) XXX_DiscardUnknown() {
	xxx_messageInfo_ForeignKeyBackReference.DiscardUnknown(m)
}

var xxx_messageInfo_ForeignKeyBackReference proto.InternalMessageInfo

type SequenceOwnedBy struct {
	SequenceID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=sequence_id,json=sequenceId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"sequence_id,omitempty"`
	OwnerTableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=owner_table_id,json=ownerTableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"owner_table_id,omitempty"`
}

func (m *SequenceOwnedBy) Reset()         { *m = SequenceOwnedBy{} }
func (m *SequenceOwnedBy) String() string { return proto.CompactTextString(m) }
func (*SequenceOwnedBy) ProtoMessage()    {}
func (*SequenceOwnedBy) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{19}
}
func (m *SequenceOwnedBy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SequenceOwnedBy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SequenceOwnedBy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SequenceOwnedBy.Merge(m, src)
}
func (m *SequenceOwnedBy) XXX_Size() int {
	return m.Size()
}
func (m *SequenceOwnedBy) XXX_DiscardUnknown() {
	xxx_messageInfo_SequenceOwnedBy.DiscardUnknown(m)
}

var xxx_messageInfo_SequenceOwnedBy proto.InternalMessageInfo

type RelationDependedOnBy struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	DependedOnBy github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,2,opt,name=depended_on,json=dependedOn,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"depended_on,omitempty"`
	ColumnID     github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,3,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
}

func (m *RelationDependedOnBy) Reset()         { *m = RelationDependedOnBy{} }
func (m *RelationDependedOnBy) String() string { return proto.CompactTextString(m) }
func (*RelationDependedOnBy) ProtoMessage()    {}
func (*RelationDependedOnBy) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{20}
}
func (m *RelationDependedOnBy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelationDependedOnBy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RelationDependedOnBy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelationDependedOnBy.Merge(m, src)
}
func (m *RelationDependedOnBy) XXX_Size() int {
	return m.Size()
}
func (m *RelationDependedOnBy) XXX_DiscardUnknown() {
	xxx_messageInfo_RelationDependedOnBy.DiscardUnknown(m)
}

var xxx_messageInfo_RelationDependedOnBy proto.InternalMessageInfo

type Type struct {
	TypeID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=type_id,json=typeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"type_id,omitempty"`
}

func (m *Type) Reset()         { *m = Type{} }
func (m *Type) String() string { return proto.CompactTextString(m) }
func (*Type) ProtoMessage()    {}
func (*Type) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{21}
}
func (m *Type) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Type) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Type) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Type.Merge(m, src)
}
func (m *Type) XXX_Size() int {
	return m.Size()
}
func (m *Type) XXX_DiscardUnknown() {
	xxx_messageInfo_Type.DiscardUnknown(m)
}

var xxx_messageInfo_Type proto.InternalMessageInfo

type Schema struct {
	SchemaID         github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=schema_id,json=schemaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"schema_id,omitempty"`
	DependentObjects []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,3,rep,packed,name=dependent_objects,json=dependentObjects,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"dependent_objects,omitempty"`
}

func (m *Schema) Reset()         { *m = Schema{} }
func (m *Schema) String() string { return proto.CompactTextString(m) }
func (*Schema) ProtoMessage()    {}
func (*Schema) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{22}
}
func (m *Schema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Schema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Schema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schema.Merge(m, src)
}
func (m *Schema) XXX_Size() int {
	return m.Size()
}
func (m *Schema) XXX_DiscardUnknown() {
	xxx_messageInfo_Schema.DiscardUnknown(m)
}

var xxx_messageInfo_Schema proto.InternalMessageInfo

type Database struct {
	DatabaseID       github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
	DependentObjects []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,3,rep,packed,name=dependent_objects,json=dependentObjects,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"dependent_objects,omitempty"`
}

func (m *Database) Reset()         { *m = Database{} }
func (m *Database) String() string { return proto.CompactTextString(m) }
func (*Database) ProtoMessage()    {}
func (*Database) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{23}
}
func (m *Database) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Database) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Database) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Database.Merge(m, src)
}
func (m *Database) XXX_Size() int {
	return m.Size()
}
func (m *Database) XXX_DiscardUnknown() {
	xxx_messageInfo_Database.DiscardUnknown(m)
}

var xxx_messageInfo_Database proto.InternalMessageInfo

type IndexPartitioning struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID                      `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID                     `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	Partitioning *github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.PartitioningDescriptor `protobuf:"bytes,3,opt,name=partitioning,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.PartitioningDescriptor" json:"partitioning,omitempty"`
}

func (m *IndexPartitioning) Reset()         { *m = IndexPartitioning{} }
func (m *IndexPartitioning) String() string { return proto.CompactTextString(m) }
func (*IndexPartitioning) ProtoMessage()    {}
func (*IndexPartitioning) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{24}
}
func (m *IndexPartitioning) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexPartitioning) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexPartitioning) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexPartitioning.Merge(m, src)
}
func (m *IndexPartitioning) XXX_Size() int {
	return m.Size()
}
func (m *IndexPartitioning) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexPartitioning.DiscardUnknown(m)
}

var xxx_messageInfo_IndexPartitioning proto.InternalMessageInfo

type Namespace struct {
	DatabaseID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
	SchemaID     github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=schema_id,json=schemaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"schema_id,omitempty"`
	DescriptorID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,3,opt,name=descriptor_id,json=descriptorId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"descriptor_id,omitempty"`
	Name         string                                                    `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Namespace) Reset()         { *m = Namespace{} }
func (m *Namespace) String() string { return proto.CompactTextString(m) }
func (*Namespace) ProtoMessage()    {}
func (*Namespace) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{25}
}
func (m *Namespace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Namespace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Namespace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Namespace.Merge(m, src)
}
func (m *Namespace) XXX_Size() int {
	return m.Size()
}
func (m *Namespace) XXX_DiscardUnknown() {
	xxx_messageInfo_Namespace.DiscardUnknown(m)
}

var xxx_messageInfo_Namespace proto.InternalMessageInfo

type Owner struct {
	DescriptorID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=descriptor_id,json=descriptorId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"descriptor_id,omitempty"`
	Owner        string                                                    `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *Owner) Reset()         { *m = Owner{} }
func (m *Owner) String() string { return proto.CompactTextString(m) }
func (*Owner) ProtoMessage()    {}
func (*Owner) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{26}
}
func (m *Owner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Owner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Owner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Owner.Merge(m, src)
}
func (m *Owner) XXX_Size() int {
	return m.Size()
}
func (m *Owner) XXX_DiscardUnknown() {
	xxx_messageInfo_Owner.DiscardUnknown(m)
}

var xxx_messageInfo_Owner proto.InternalMessageInfo

type UserPrivileges struct {
	DescriptorID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=descriptor_id,json=descriptorId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"descriptor_id,omitempty"`
	Username     string                                                    `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Privileges   uint32                                                    `protobuf:"varint,3,opt,name=privileges,proto3" json:"privileges,omitempty"`
}

func (m *UserPrivileges) Reset()         { *m = UserPrivileges{} }
func (m *UserPrivileges) String() string { return proto.CompactTextString(m) }
func (*UserPrivileges) ProtoMessage()    {}
func (*UserPrivileges) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{27}
}
func (m *UserPrivileges) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserPrivileges) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UserPrivileges) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserPrivileges.Merge(m, src)
}
func (m *UserPrivileges) XXX_Size() int {
	return m.Size()
}
func (m *UserPrivileges) XXX_DiscardUnknown() {
	xxx_messageInfo_UserPrivileges.DiscardUnknown(m)
}

var xxx_messageInfo_UserPrivileges proto.InternalMessageInfo

type Locality struct {
	DescriptorID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID              `protobuf:"varint,1,opt,name=descriptor_id,json=descriptorId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"descriptor_id,omitempty"`
	Locality     *github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.LocalityConfig `protobuf:"bytes,2,opt,name=locality,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.LocalityConfig" json:"locality,omitempty"`
}

func (m *Locality) Reset()         { *m = Locality{} }
func (m *Locality) String() string { return proto.CompactTextString(m) }
func (*Locality) ProtoMessage()    {}
func (*Locality) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{28}
}
func (m *Locality) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Locality) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Locality) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Locality.Merge(m, src)
}
func (m *Locality) XXX_Size() int {
	return m.Size()
}
func (m *Locality) XXX_DiscardUnknown() {
	xxx_messageInfo_Locality.DiscardUnknown(m)
}

var xxx_messageInfo_Locality proto.InternalMessageInfo

type RowLevelTTL struct {
	TableID     github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	RowLevelTTL *catpb.RowLevelTTL                                        `protobuf:"bytes,2,opt,name=row_level_ttl,json=rowLevelTtl,proto3" json:"row_level_ttl,omitempty"`
}

func (m *RowLevelTTL) Reset()         { *m = RowLevelTTL{} }
func (m *RowLevelTTL) String() string { return proto.CompactTextString(m) }
func (*RowLevelTTL) ProtoMessage()    {}
func (*RowLevelTTL) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{29}
}
func (m *RowLevelTTL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowLevelTTL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RowLevelTTL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowLevelTTL.Merge(m, src)
}
func (m *RowLevelTTL) XXX_Size() int {
	return m.Size()
}
func (m *RowLevelTTL) XXX_DiscardUnknown() {
	xxx_messageInfo_RowLevelTTL.DiscardUnknown(m)
}

var xxx_messageInfo_RowLevelTTL proto.InternalMessageInfo

type ColumnName struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	Name     string                                                      `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ColumnName) Reset()         { *m = ColumnName{} }
func (m *ColumnName) String() string { return proto.CompactTextString(m) }
func (*ColumnName) ProtoMessage()    {}
func (*ColumnName) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{30}
}
func (m *ColumnName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnName.Merge(m, src)
}
func (m *ColumnName) XXX_Size() int {
	return m.Size()
}
func (m *ColumnName) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnName.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnName proto.InternalMessageInfo

type IndexName struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	Name    string                                                     `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *IndexName) Reset()         { *m = IndexName{} }
func (m *IndexName) String() string { return proto.CompactTextString(m) }
func (*IndexName) ProtoMessage()    {}
func (*IndexName) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{31}
}
func (m *IndexName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexName.Merge(m, src)
}
func (m *IndexName) XXX_Size() int {
	return m.Size()
}
func (m *IndexName) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexName.DiscardUnknown(m)
}

var xxx_messageInfo_IndexName proto.InternalMessageInfo

type ConstraintName struct {
	TableID           github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintType    ConstraintType                                            `protobuf:"varint,2,opt,name=constraint_type,json=constraintType,proto3,enum=cockroach.sql.schemachanger.scpb.ConstraintType" json:"constraint_type,omitempty"`
	ConstraintOrdinal uint32                                                    `protobuf:"varint,3,opt,name=constraint_ordinal,json=constraintOrdinal,proto3" json:"constraint_ordinal,omitempty"`
	Name              string                                                    `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ConstraintName) Reset()         { *m = ConstraintName{} }
func (m *ConstraintName) String() string { return proto.CompactTextString(m) }
func (*ConstraintName) ProtoMessage()    {}
func (*ConstraintName) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{32}
}
func (m *ConstraintName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConstraintName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConstraintName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConstraintName.Merge(m, src)
}
func (m *ConstraintName) XXX_Size() int {
	return m.Size()
}
func (m *ConstraintName) XXX_DiscardUnknown() {
	xxx_messageInfo_ConstraintName.DiscardUnknown(m)
}

var xxx_messageInfo_ConstraintName proto.InternalMessageInfo

type DefaultPrivilege struct {
	DescriptorID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=descriptor_id,json=descriptorId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"descriptor_id,omitempty"`
	// Types that are valid to be assigned to Role:
	//	*DefaultPrivilege_ExplicitRole
	//	*DefaultPrivilege_ForAllRoles
	Role                isDefaultPrivilege_Role                             `protobuf_oneof:"role"`
	PrivilegesPerObject map[uint32]*DefaultPrivilege_DefaultObjectPrivilege `protobuf:"bytes,4,rep,name=privileges_per_object,json=privilegesPerObject,proto3" json:"privileges_per_object,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *DefaultPrivilege) Reset()         { *m = DefaultPrivilege{} }
func (m *DefaultPrivilege) String() string { return proto.CompactTextString(m) }
func (*DefaultPrivilege) ProtoMessage()    {}
func (*DefaultPrivilege) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{33}
}
func (m *DefaultPrivilege) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefaultPrivilege) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DefaultPrivilege) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefaultPrivilege.Merge(m, src)
}
func (m *DefaultPrivilege) XXX_Size() int {
	return m.Size()
}
func (m *DefaultPrivilege) XXX_DiscardUnknown() {
	xxx_messageInfo_DefaultPrivilege.DiscardUnknown(m)
}

var xxx_messageInfo_DefaultPrivilege proto.InternalMessageInfo

type isDefaultPrivilege_Role interface {
	isDefaultPrivilege_Role()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DefaultPrivilege_ExplicitRole struct {
	ExplicitRole *catpb.DefaultPrivilegesForRole_ExplicitRole `protobuf:"bytes,2,opt,name=explicit_role,json=explicitRole,proto3,oneof" json:"explicit_role,omitempty"`
}
type DefaultPrivilege_ForAllRoles struct {
	ForAllRoles *catpb.DefaultPrivilegesForRole_ForAllRolesPseudoRole `protobuf:"bytes,3,opt,name=for_all_roles,json=forAllRoles,proto3,oneof" json:"for_all_roles,omitempty"`
}

func (*DefaultPrivilege_ExplicitRole) isDefaultPrivilege_Role() {}
func (*DefaultPrivilege_ForAllRoles) isDefaultPrivilege_Role()  {}

func (m *DefaultPrivilege) GetRole() isDefaultPrivilege_Role {
	if m != nil {
		return m.Role
	}
	return nil
}

func (m *DefaultPrivilege) GetExplicitRole() *catpb.DefaultPrivilegesForRole_ExplicitRole {
	if x, ok := m.GetRole().(*DefaultPrivilege_ExplicitRole); ok {
		return x.ExplicitRole
	}
	return nil
}

func (m *DefaultPrivilege) GetForAllRoles() *catpb.DefaultPrivilegesForRole_ForAllRolesPseudoRole {
	if x, ok := m.GetRole().(*DefaultPrivilege_ForAllRoles); ok {
		return x.ForAllRoles
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DefaultPrivilege) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DefaultPrivilege_ExplicitRole)(nil),
		(*DefaultPrivilege_ForAllRoles)(nil),
	}
}

type DefaultPrivilege_DefaultObjectPrivilege struct {
	Privileges []*UserPrivileges `protobuf:"bytes,1,rep,name=privileges,proto3" json:"privileges,omitempty"`
}

func (m *DefaultPrivilege_DefaultObjectPrivilege) Reset() {
	*m = DefaultPrivilege_DefaultObjectPrivilege{}
}
func (m *DefaultPrivilege_DefaultObjectPrivilege) String() string { return proto.CompactTextString(m) }
func (*DefaultPrivilege_DefaultObjectPrivilege) ProtoMessage()    {}
func (*DefaultPrivilege_DefaultObjectPrivilege) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{33, 0}
}
func (m *DefaultPrivilege_DefaultObjectPrivilege) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefaultPrivilege_DefaultObjectPrivilege) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DefaultPrivilege_DefaultObjectPrivilege) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefaultPrivilege_DefaultObjectPrivilege.Merge(m, src)
}
func (m *DefaultPrivilege_DefaultObjectPrivilege) XXX_Size() int {
	return m.Size()
}
func (m *DefaultPrivilege_DefaultObjectPrivilege) XXX_DiscardUnknown() {
	xxx_messageInfo_DefaultPrivilege_DefaultObjectPrivilege.DiscardUnknown(m)
}

var xxx_messageInfo_DefaultPrivilege_DefaultObjectPrivilege proto.InternalMessageInfo

type DatabaseSchemaEntry struct {
	DatabaseID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
	SchemaID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=schema_id,json=schemaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"schema_id,omitempty"`
}

func (m *DatabaseSchemaEntry) Reset()         { *m = DatabaseSchemaEntry{} }
func (m *DatabaseSchemaEntry) String() string { return proto.CompactTextString(m) }
func (*DatabaseSchemaEntry) ProtoMessage()    {}
func (*DatabaseSchemaEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{34}
}
func (m *DatabaseSchemaEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseSchemaEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabaseSchemaEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseSchemaEntry.Merge(m, src)
}
func (m *DatabaseSchemaEntry) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseSchemaEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseSchemaEntry.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseSchemaEntry proto.InternalMessageInfo

type TableComment struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	Comment string                                                    `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *TableComment) Reset()         { *m = TableComment{} }
func (m *TableComment) String() string { return proto.CompactTextString(m) }
func (*TableComment) ProtoMessage()    {}
func (*TableComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{35}
}
func (m *TableComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableComment.Merge(m, src)
}
func (m *TableComment) XXX_Size() int {
	return m.Size()
}
func (m *TableComment) XXX_DiscardUnknown() {
	xxx_messageInfo_TableComment.DiscardUnknown(m)
}

var xxx_messageInfo_TableComment proto.InternalMessageInfo

type DatabaseComment struct {
	DatabaseID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
	Comment    string                                                    `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *DatabaseComment) Reset()         { *m = DatabaseComment{} }
func (m *DatabaseComment) String() string { return proto.CompactTextString(m) }
func (*DatabaseComment) ProtoMessage()    {}
func (*DatabaseComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{36}
}
func (m *DatabaseComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabaseComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseComment.Merge(m, src)
}
func (m *DatabaseComment) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseComment) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseComment.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseComment proto.InternalMessageInfo

type SchemaComment struct {
	SchemaID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=schema_id,json=schemaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"schema_id,omitempty"`
	Comment  string                                                    `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *SchemaComment) Reset()         { *m = SchemaComment{} }
func (m *SchemaComment) String() string { return proto.CompactTextString(m) }
func (*SchemaComment) ProtoMessage()    {}
func (*SchemaComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{37}
}
func (m *SchemaComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SchemaComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaComment.Merge(m, src)
}
func (m *SchemaComment) XXX_Size() int {
	return m.Size()
}
func (m *SchemaComment) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaComment.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaComment proto.InternalMessageInfo

type IndexComment struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	Comment string                                                     `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *IndexComment) Reset()         { *m = IndexComment{} }
func (m *IndexComment) String() string { return proto.CompactTextString(m) }
func (*IndexComment) ProtoMessage()    {}
func (*IndexComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{38}
}
func (m *IndexComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexComment.Merge(m, src)
}
func (m *IndexComment) XXX_Size() int {
	return m.Size()
}
func (m *IndexComment) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexComment.DiscardUnknown(m)
}

var xxx_messageInfo_IndexComment proto.InternalMessageInfo

type ColumnComment struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	Comment  string                                                      `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *ColumnComment) Reset()         { *m = ColumnComment{} }
func (m *ColumnComment) String() string { return proto.CompactTextString(m) }
func (*ColumnComment) ProtoMessage()    {}
func (*ColumnComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{39}
}
func (m *ColumnComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnComment.Merge(m, src)
}
func (m *ColumnComment) XXX_Size() int {
	return m.Size()
}
func (m *ColumnComment) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnComment.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnComment proto.InternalMessageInfo

type ConstraintComment struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	Comment      string                                                          `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *ConstraintComment) Reset()         { *m = ConstraintComment{} }
func (m *ConstraintComment) String() string { return proto.CompactTextString(m) }
func (*ConstraintComment) ProtoMessage()    {}
func (*ConstraintComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{40}
}
func (m *ConstraintComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConstraintComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConstraintComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConstraintComment.Merge(m, src)
}
func (m *ConstraintComment) XXX_Size() int {
	return m.Size()
}
func (m *ConstraintComment) XXX_DiscardUnknown() {
	xxx_messageInfo_ConstraintComment.DiscardUnknown(m)
}

var xxx_messageInfo_ConstraintComment proto.InternalMessageInfo

type DatabaseRoleSetting struct {
	DatabaseID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
	RoleName   string                                                    `protobuf:"bytes,2,opt,name=role_name,json=roleName,proto3" json:"role_name,omitempty"`
}

func (m *DatabaseRoleSetting) Reset()         { *m = DatabaseRoleSetting{} }
func (m *DatabaseRoleSetting) String() string { return proto.CompactTextString(m) }
func (*DatabaseRoleSetting) ProtoMessage()    {}
func (*DatabaseRoleSetting) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{41}
}
func (m *DatabaseRoleSetting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseRoleSetting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabaseRoleSetting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseRoleSetting.Merge(m, src)
}
func (m *DatabaseRoleSetting) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseRoleSetting) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseRoleSetting.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseRoleSetting proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.sql.schemachanger.scpb.ConstraintType", ConstraintType_name, ConstraintType_value)
	proto.RegisterEnum("cockroach.sql.schemachanger.scpb.PrimaryIndex_Direction", PrimaryIndex_Direction_name, PrimaryIndex_Direction_value)
	proto.RegisterEnum("cockroach.sql.schemachanger.scpb.SecondaryIndex_Direction", SecondaryIndex_Direction_name, SecondaryIndex_Direction_value)
	proto.RegisterEnum("cockroach.sql.schemachanger.scpb.SequenceDependency_Type", SequenceDependency_Type_name, SequenceDependency_Type_value)
	proto.RegisterType((*ElementProto)(nil), "cockroach.sql.schemachanger.scpb.ElementProto")
	proto.RegisterType((*Column)(nil), "cockroach.sql.schemachanger.scpb.Column")
	proto.RegisterType((*PrimaryIndex)(nil), "cockroach.sql.schemachanger.scpb.PrimaryIndex")
	proto.RegisterType((*SecondaryIndex)(nil), "cockroach.sql.schemachanger.scpb.SecondaryIndex")
	proto.RegisterType((*SequenceDependency)(nil), "cockroach.sql.schemachanger.scpb.SequenceDependency")
	proto.RegisterType((*UniqueConstraint)(nil), "cockroach.sql.schemachanger.scpb.UniqueConstraint")
	proto.RegisterType((*CheckConstraint)(nil), "cockroach.sql.schemachanger.scpb.CheckConstraint")
	proto.RegisterType((*Sequence)(nil), "cockroach.sql.schemachanger.scpb.Sequence")
	proto.RegisterType((*DefaultExpression)(nil), "cockroach.sql.schemachanger.scpb.DefaultExpression")
	proto.RegisterType((*View)(nil), "cockroach.sql.schemachanger.scpb.View")
	proto.RegisterType((*Table)(nil), "cockroach.sql.schemachanger.scpb.Table")
	proto.RegisterType((*OnUpdateExprTypeReference)(nil), "cockroach.sql.schemachanger.scpb.OnUpdateExprTypeReference")
	proto.RegisterType((*ComputedExprTypeReference)(nil), "cockroach.sql.schemachanger.scpb.ComputedExprTypeReference")
	proto.RegisterType((*DefaultExprTypeReference)(nil), "cockroach.sql.schemachanger.scpb.DefaultExprTypeReference")
	proto.RegisterType((*ColumnTypeReference)(nil), "cockroach.sql.schemachanger.scpb.ColumnTypeReference")
	proto.RegisterType((*CheckConstraintTypeReference)(nil), "cockroach.sql.schemachanger.scpb.CheckConstraintTypeReference")
	proto.RegisterType((*ViewDependsOnType)(nil), "cockroach.sql.schemachanger.scpb.ViewDependsOnType")
	proto.RegisterType((*ForeignKey)(nil), "cockroach.sql.schemachanger.scpb.ForeignKey")
	proto.RegisterType((*ForeignKeyBackReference)(nil), "cockroach.sql.schemachanger.scpb.ForeignKeyBackReference")
	proto.RegisterType((*SequenceOwnedBy)(nil), "cockroach.sql.schemachanger.scpb.SequenceOwnedBy")
	proto.RegisterType((*RelationDependedOnBy)(nil), "cockroach.sql.schemachanger.scpb.RelationDependedOnBy")
	proto.RegisterType((*Type)(nil), "cockroach.sql.schemachanger.scpb.Type")
	proto.RegisterType((*Schema)(nil), "cockroach.sql.schemachanger.scpb.Schema")
	proto.RegisterType((*Database)(nil), "cockroach.sql.schemachanger.scpb.Database")
	proto.RegisterType((*IndexPartitioning)(nil), "cockroach.sql.schemachanger.scpb.IndexPartitioning")
	proto.RegisterType((*Namespace)(nil), "cockroach.sql.schemachanger.scpb.Namespace")
	proto.RegisterType((*Owner)(nil), "cockroach.sql.schemachanger.scpb.Owner")
	proto.RegisterType((*UserPrivileges)(nil), "cockroach.sql.schemachanger.scpb.UserPrivileges")
	proto.RegisterType((*Locality)(nil), "cockroach.sql.schemachanger.scpb.Locality")
	proto.RegisterType((*RowLevelTTL)(nil), "cockroach.sql.schemachanger.scpb.RowLevelTTL")
	proto.RegisterType((*ColumnName)(nil), "cockroach.sql.schemachanger.scpb.ColumnName")
	proto.RegisterType((*IndexName)(nil), "cockroach.sql.schemachanger.scpb.IndexName")
	proto.RegisterType((*ConstraintName)(nil), "cockroach.sql.schemachanger.scpb.ConstraintName")
	proto.RegisterType((*DefaultPrivilege)(nil), "cockroach.sql.schemachanger.scpb.DefaultPrivilege")
	proto.RegisterMapType((map[uint32]*DefaultPrivilege_DefaultObjectPrivilege)(nil), "cockroach.sql.schemachanger.scpb.DefaultPrivilege.PrivilegesPerObjectEntry")
	proto.RegisterType((*DefaultPrivilege_DefaultObjectPrivilege)(nil), "cockroach.sql.schemachanger.scpb.DefaultPrivilege.DefaultObjectPrivilege")
	proto.RegisterType((*DatabaseSchemaEntry)(nil), "cockroach.sql.schemachanger.scpb.DatabaseSchemaEntry")
	proto.RegisterType((*TableComment)(nil), "cockroach.sql.schemachanger.scpb.TableComment")
	proto.RegisterType((*DatabaseComment)(nil), "cockroach.sql.schemachanger.scpb.DatabaseComment")
	proto.RegisterType((*SchemaComment)(nil), "cockroach.sql.schemachanger.scpb.SchemaComment")
	proto.RegisterType((*IndexComment)(nil), "cockroach.sql.schemachanger.scpb.IndexComment")
	proto.RegisterType((*ColumnComment)(nil), "cockroach.sql.schemachanger.scpb.ColumnComment")
	proto.RegisterType((*ConstraintComment)(nil), "cockroach.sql.schemachanger.scpb.ConstraintComment")
	proto.RegisterType((*DatabaseRoleSetting)(nil), "cockroach.sql.schemachanger.scpb.DatabaseRoleSetting")
}

func init() {
	proto.RegisterFile("sql/schemachanger/scpb/elements.proto", fileDescriptor_49b58fafa7b67c5d)
}

var fileDescriptor_49b58fafa7b67c5d = []byte{
	// 3638 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x3c, 0x4b, 0x70, 0x24, 0xc9,
	0x55, 0x53, 0xdd, 0x2d, 0xa9, 0xfb, 0xa9, 0xbb, 0xd5, 0x4a, 0x49, 0x33, 0x35, 0xf2, 0x58, 0xa5,
	0x29, 0xef, 0x7a, 0xe5, 0x45, 0xdb, 0x32, 0x6b, 0xe3, 0xb0, 0x65, 0x8c, 0x99, 0x96, 0x34, 0x6b,
	0x85, 0x66, 0x47, 0x72, 0x69, 0xc6, 0x63, 0x1c, 0xe1, 0x68, 0x4a, 0x55, 0xa9, 0x56, 0xad, 0x4a,
	0x55, 0x3d, 0x95, 0xd5, 0xd2, 0x74, 0x04, 0x1f, 0x1b, 0x43, 0x18, 0x02, 0x08, 0x58, 0x4c, 0x04,
	0xc1, 0x09, 0x9f, 0x80, 0x80, 0x23, 0x37, 0xe0, 0xc0, 0x89, 0x58, 0x02, 0x0e, 0x26, 0x02, 0x08,
	0x07, 0x87, 0x0e, 0xac, 0xe5, 0xc0, 0xe7, 0x00, 0x21, 0x38, 0xc0, 0x9c, 0x88, 0xcc, 0xac, 0xac,
	0x4f, 0x77, 0x6b, 0x54, 0xad, 0x4f, 0x4f, 0x20, 0xcf, 0x65, 0xa6, 0x2b, 0x33, 0xdf, 0x27, 0x5f,
	0xbe, 0x7c, 0xef, 0xe5, 0xcb, 0x7c, 0x82, 0xd7, 0xc9, 0x53, 0x7b, 0x89, 0x18, 0x7b, 0xf8, 0x40,
	0x37, 0xf6, 0x74, 0xa7, 0x81, 0xbd, 0x25, 0x62, 0x34, 0x77, 0x96, 0xb0, 0x8d, 0x0f, 0xb0, 0xe3,
	0x93, 0x6a, 0xd3, 0x73, 0x7d, 0x17, 0xcd, 0x1b, 0xae, 0xb1, 0xef, 0xb9, 0xba, 0xb1, 0x57, 0x25,
	0x4f, 0xed, 0x6a, 0x02, 0xa0, 0x4a, 0x01, 0x66, 0x15, 0x8a, 0xc8, 0xd0, 0x7d, 0xdd, 0x76, 0x1b,
	0xf4, 0xff, 0xe6, 0x8e, 0xf8, 0xe2, 0x28, 0x66, 0xef, 0xf6, 0x0e, 0x68, 0x7a, 0xd6, 0xa1, 0x65,
	0xe3, 0x06, 0x0e, 0x86, 0xcc, 0xd0, 0x21, 0x7e, 0xbb, 0x89, 0x09, 0xff, 0x37, 0x68, 0x9e, 0x6e,
	0xb8, 0x0d, 0x97, 0xfd, 0x5c, 0xa2, 0xbf, 0x78, 0xab, 0xfa, 0xa7, 0xaf, 0x41, 0x71, 0x8d, 0x73,
	0xb9, 0xc5, 0x78, 0x7c, 0x04, 0xa3, 0x86, 0x6b, 0xb7, 0x0e, 0x1c, 0x59, 0x9a, 0x97, 0x16, 0xc6,
	0xdf, 0x5e, 0xa8, 0x9e, 0xc5, 0x74, 0x75, 0x85, 0x8d, 0xaf, 0xa1, 0x93, 0x8e, 0x52, 0x6e, 0xea,
	0x1e, 0x76, 0xfc, 0x65, 0xf5, 0x91, 0xbe, 0x63, 0x63, 0x55, 0x0b, 0x70, 0xa1, 0x06, 0x94, 0x9a,
	0x9e, 0x75, 0xa0, 0x7b, 0xed, 0xba, 0xe5, 0x98, 0xf8, 0x99, 0x9c, 0x61, 0xc8, 0xab, 0x67, 0x23,
	0xdf, 0xe2, 0x60, 0xeb, 0x14, 0xaa, 0x2f, 0x89, 0x62, 0x33, 0x36, 0x02, 0x1d, 0xc0, 0x04, 0xc1,
	0x86, 0xeb, 0x98, 0x11, 0xa9, 0x2c, 0x23, 0xf5, 0xc9, 0xb3, 0x49, 0x6d, 0x0b, 0xc0, 0xd3, 0x89,
	0x95, 0x49, 0x62, 0x0c, 0xfa, 0xa6, 0x04, 0x53, 0x04, 0x3f, 0x6d, 0x61, 0xc7, 0xc0, 0x75, 0x13,
	0x37, 0xb1, 0x63, 0x62, 0xc7, 0x68, 0xcb, 0x39, 0x46, 0xf3, 0xd3, 0x69, 0x68, 0x72, 0xe0, 0xd5,
	0x10, 0xb6, 0x36, 0x7b, 0xd2, 0x51, 0x6e, 0x0a, 0xba, 0x5c, 0xb6, 0x8b, 0xf3, 0x01, 0x7d, 0x44,
	0x7a, 0xc6, 0xa3, 0x6f, 0x49, 0x30, 0xd9, 0x72, 0xac, 0xa7, 0x2d, 0x5c, 0x37, 0x5c, 0x87, 0xf8,
	0x9e, 0x6e, 0x39, 0xbe, 0x3c, 0xc2, 0x38, 0x78, 0xfb, 0x6c, 0x0e, 0x1e, 0x33, 0xd0, 0x95, 0x10,
	0xb2, 0xa6, 0x9e, 0x74, 0x94, 0x39, 0x41, 0x3f, 0x29, 0x93, 0x90, 0x8f, 0x4a, 0xab, 0x0b, 0x0a,
	0x35, 0xa1, 0x62, 0xec, 0x61, 0x63, 0x3f, 0xce, 0xc3, 0x28, 0xe3, 0xe1, 0x47, 0x53, 0x68, 0x10,
	0x85, 0x8c, 0xb1, 0xd0, 0x4f, 0xf4, 0x13, 0x46, 0x72, 0x10, 0xba, 0x0f, 0x79, 0x21, 0x0d, 0x79,
	0x8c, 0x51, 0x7a, 0x33, 0xbd, 0xbc, 0xb5, 0x10, 0x16, 0x1d, 0x01, 0x32, 0xf1, 0xae, 0xde, 0xb2,
	0xfd, 0x3a, 0x7e, 0xd6, 0xf4, 0x30, 0x21, 0x96, 0xeb, 0xc8, 0x79, 0x86, 0xf1, 0x53, 0x67, 0x63,
	0x5c, 0xe5, 0xb0, 0x6b, 0x21, 0x68, 0x6d, 0xea, 0xa4, 0xa3, 0x4c, 0x24, 0x17, 0x50, 0xd5, 0x26,
	0xcd, 0xee, 0x71, 0x68, 0x19, 0x72, 0x87, 0x16, 0x3e, 0x92, 0x0b, 0x8c, 0xd4, 0xc7, 0xcf, 0x26,
	0xf5, 0x15, 0x0b, 0x1f, 0x69, 0x0c, 0x06, 0x7d, 0x01, 0x46, 0x7c, 0x2a, 0x17, 0x19, 0x18, 0xf0,
	0x1b, 0x67, 0x03, 0x33, 0x31, 0x6a, 0x1c, 0x0a, 0xed, 0xc1, 0x84, 0xdb, 0xf2, 0xeb, 0xbb, 0xae,
	0x87, 0xad, 0x86, 0x53, 0xdf, 0xc7, 0x6d, 0x79, 0x9c, 0x21, 0x5a, 0x3c, 0x1b, 0xd1, 0x7d, 0x0e,
	0xb4, 0x81, 0xdb, 0x7d, 0xd7, 0xa9, 0xe4, 0xb6, 0xfc, 0x68, 0x08, 0x22, 0x50, 0xb6, 0x9c, 0x04,
	0xa1, 0x22, 0x23, 0xf4, 0xb9, 0x81, 0x08, 0xe9, 0xc6, 0xbe, 0x86, 0x77, 0xb1, 0x47, 0x17, 0xac,
	0xbf, 0x15, 0xb0, 0x9c, 0x18, 0xd1, 0x6f, 0x4b, 0x70, 0xcb, 0xc3, 0xb6, 0xee, 0x5b, 0xae, 0x23,
	0xb6, 0xa5, 0x59, 0x77, 0x9d, 0xfa, 0x4e, 0x5b, 0x2e, 0x31, 0xf2, 0x9f, 0x39, 0x9b, 0xbc, 0x16,
	0x20, 0x08, 0xb6, 0x9a, 0xb9, 0xe9, 0xd4, 0xda, 0x35, 0xf9, 0xa4, 0xa3, 0x4c, 0x27, 0x68, 0x2f,
	0xce, 0xd3, 0x65, 0x51, 0xb5, 0x69, 0xaf, 0xcf, 0x78, 0x74, 0x04, 0xe5, 0xd0, 0x3e, 0xb8, 0x47,
	0x0e, 0xf6, 0xe4, 0xb7, 0xd2, 0x6e, 0x0a, 0xa1, 0xaa, 0x9b, 0x47, 0x0e, 0x36, 0x6b, 0xed, 0xda,
	0x47, 0x4f, 0x3a, 0xca, 0xed, 0x6e, 0xbb, 0x20, 0x06, 0xa9, 0x5a, 0x89, 0xc4, 0xc6, 0x7b, 0x54,
	0xb9, 0xa8, 0xf5, 0x97, 0x27, 0xd2, 0x2a, 0xd7, 0xa3, 0x76, 0x13, 0x6b, 0x0c, 0x06, 0xfd, 0x24,
	0x8c, 0xf2, 0x01, 0x72, 0x25, 0xad, 0x0f, 0xd8, 0x66, 0x4d, 0x5a, 0x00, 0x47, 0xf7, 0xa6, 0xa9,
	0xfb, 0xfa, 0x8e, 0x4e, 0xb0, 0x3c, 0x99, 0x76, 0x6f, 0xae, 0x06, 0x10, 0x5a, 0x08, 0x8b, 0x7e,
	0x41, 0x82, 0x62, 0x53, 0xf7, 0x7c, 0x8b, 0x0a, 0xd6, 0x72, 0x1a, 0x32, 0x4a, 0xbb, 0x2d, 0x99,
	0xbd, 0xda, 0x8a, 0x81, 0xd6, 0x3e, 0x71, 0xd2, 0x51, 0x5e, 0x17, 0xf2, 0x8b, 0xbb, 0x15, 0x2a,
	0xc5, 0xb8, 0x95, 0xa3, 0x3e, 0x25, 0x06, 0x88, 0x7e, 0x49, 0x82, 0x82, 0xa3, 0x1f, 0x60, 0xd2,
	0xd4, 0x0d, 0x2c, 0x4f, 0x31, 0x0e, 0x7e, 0xe4, 0x6c, 0x0e, 0x1e, 0x0a, 0x90, 0xda, 0xf2, 0x49,
	0x47, 0xf9, 0x4c, 0x1f, 0xa5, 0x89, 0x96, 0x6f, 0x71, 0x5e, 0x4c, 0x7e, 0x71, 0x9e, 0x8b, 0x72,
	0x71, 0x9e, 0x2e, 0x88, 0xaa, 0x45, 0x94, 0x11, 0x81, 0x11, 0xae, 0x42, 0xd3, 0x69, 0xf7, 0x3c,
	0x53, 0x85, 0xda, 0xa7, 0x4f, 0x3a, 0xca, 0x27, 0x07, 0x24, 0xaf, 0x6a, 0x9c, 0x16, 0xfa, 0x0d,
	0x09, 0x26, 0x5a, 0x04, 0x7b, 0xf5, 0x30, 0xcc, 0x20, 0xf2, 0x4c, 0x5a, 0x8f, 0xfa, 0x98, 0x60,
	0x6f, 0x2b, 0x84, 0x3b, 0x27, 0x23, 0xe5, 0x56, 0x02, 0x0b, 0xda, 0x81, 0x71, 0x1e, 0x55, 0xd4,
	0xa9, 0x68, 0xe4, 0x9b, 0x69, 0xed, 0x16, 0xdf, 0x32, 0x74, 0x55, 0xfa, 0x5b, 0x68, 0x30, 0xc2,
	0x01, 0xe8, 0x6b, 0x90, 0xb7, 0x5d, 0x43, 0xb7, 0x2d, 0xbf, 0x2d, 0xdf, 0x4a, 0xab, 0xbf, 0x0f,
	0x02, 0x88, 0xbe, 0x06, 0x2a, 0xc4, 0x87, 0x5a, 0x00, 0x2c, 0x30, 0xe1, 0xec, 0xcb, 0x69, 0xd5,
	0x89, 0xa9, 0x26, 0xe3, 0x7e, 0x00, 0x45, 0x2e, 0x58, 0x02, 0x0a, 0xfd, 0x8a, 0x04, 0x13, 0x91,
	0x6f, 0xe6, 0xc4, 0x6f, 0xa7, 0x5d, 0xc8, 0xc8, 0xed, 0x32, 0x0e, 0xaa, 0x27, 0x1d, 0xe5, 0x4d,
	0xc1, 0x41, 0x77, 0x00, 0xb1, 0x38, 0xdf, 0xe5, 0xce, 0x55, 0xad, 0x6c, 0x24, 0xe0, 0xd1, 0x2f,
	0x4b, 0x30, 0x13, 0xf7, 0xb9, 0x75, 0x6a, 0x76, 0xea, 0x1e, 0xde, 0x95, 0x67, 0x19, 0x47, 0xcb,
	0x03, 0xb9, 0x5d, 0x66, 0xb9, 0x42, 0xef, 0x70, 0xfb, 0xa4, 0xa3, 0xcc, 0xf4, 0x84, 0x4f, 0x6c,
	0x2f, 0x21, 0xb3, 0x07, 0x88, 0xea, 0xb7, 0xec, 0x3a, 0xf5, 0x56, 0xd3, 0xd4, 0x7d, 0x1c, 0xf2,
	0xc1, 0x71, 0xc9, 0x1f, 0x61, 0xdc, 0x7c, 0x3e, 0xc5, 0x46, 0x73, 0x1e, 0x33, 0x04, 0x03, 0xb1,
	0x33, 0xe3, 0x06, 0x50, 0x09, 0x08, 0xf4, 0x3b, 0x12, 0xdc, 0x31, 0xdc, 0x83, 0x66, 0xcb, 0xc7,
	0x66, 0x52, 0x3a, 0x01, 0x57, 0x77, 0xd2, 0x72, 0xb5, 0x12, 0x60, 0x19, 0x88, 0xab, 0xdb, 0xc6,
	0x69, 0x50, 0xe8, 0x67, 0x61, 0x9a, 0x06, 0x1f, 0x81, 0x47, 0x25, 0xd4, 0xa1, 0x32, 0x1f, 0xf3,
	0xd1, 0xb4, 0x46, 0x99, 0x6e, 0x76, 0xee, 0x1e, 0xc9, 0xa6, 0x43, 0x71, 0xd7, 0x6e, 0x9d, 0x74,
	0x94, 0x29, 0xc1, 0x08, 0xb7, 0x05, 0x9c, 0x8d, 0xc9, 0xc3, 0xee, 0xb1, 0xe8, 0x17, 0x25, 0x98,
	0x09, 0x76, 0x7e, 0x97, 0x44, 0xe6, 0x18, 0x03, 0x3f, 0x96, 0xd6, 0x06, 0xa4, 0x96, 0xc5, 0x94,
	0xd1, 0x3b, 0x1e, 0x1d, 0x41, 0x91, 0x63, 0xae, 0x63, 0xc7, 0xf7, 0xda, 0xb2, 0x92, 0x96, 0xb8,
	0x30, 0x6d, 0xdc, 0xb0, 0xad, 0x51, 0xe0, 0xa4, 0x53, 0xef, 0xb5, 0x7d, 0xe3, 0x24, 0x1a, 0x8b,
	0x7e, 0x4f, 0x02, 0xa5, 0x3b, 0xc6, 0xee, 0x96, 0xc4, 0x3c, 0x63, 0xe6, 0x27, 0x06, 0x0e, 0xb9,
	0x93, 0x22, 0xe9, 0x17, 0xe5, 0x70, 0x89, 0xdc, 0x31, 0x5e, 0x00, 0x87, 0x8e, 0xa0, 0xc4, 0xe2,
	0xcb, 0xba, 0xe1, 0x1e, 0xd0, 0x23, 0xa5, 0x7c, 0x37, 0xed, 0x31, 0x8f, 0x11, 0x59, 0xe1, 0x50,
	0xc9, 0x13, 0x48, 0x5f, 0x3f, 0xa1, 0x6a, 0x45, 0x3f, 0x06, 0x81, 0x08, 0x54, 0x44, 0xcc, 0x10,
	0xd2, 0xfe, 0x58, 0xda, 0x40, 0x4b, 0x88, 0x5d, 0x90, 0x9f, 0x39, 0xe9, 0x28, 0x93, 0xdd, 0x6b,
	0xa2, 0x6a, 0x13, 0x66, 0x72, 0x1c, 0xda, 0x87, 0x72, 0xa0, 0x08, 0x82, 0xe4, 0x6b, 0x8c, 0xe4,
	0x52, 0xda, 0x70, 0x49, 0x10, 0x4c, 0xb8, 0x23, 0xb1, 0xf4, 0x25, 0x12, 0x1f, 0x43, 0x4f, 0xd0,
	0xdc, 0x6b, 0x08, 0x5a, 0xaf, 0xa7, 0x15, 0x2d, 0x73, 0x05, 0x82, 0x54, 0xc2, 0x35, 0x89, 0x68,
	0xc7, 0x8a, 0x8d, 0xa0, 0xb3, 0x0a, 0x36, 0x99, 0xa0, 0xf4, 0xf1, 0xb4, 0xb3, 0xe2, 0x9b, 0xa7,
	0xef, 0xac, 0x84, 0x93, 0x2d, 0x19, 0xf1, 0x31, 0xe8, 0xcf, 0x25, 0x40, 0x31, 0x65, 0x16, 0x14,
	0xdf, 0x48, 0x6b, 0x50, 0x22, 0x45, 0x14, 0x54, 0xbf, 0x7a, 0xd2, 0x51, 0x1e, 0xa5, 0x71, 0x8e,
	0x8b, 0xf3, 0xd1, 0x81, 0x61, 0x71, 0x3e, 0x85, 0x13, 0x9b, 0x34, 0xba, 0x89, 0xa1, 0x6f, 0x50,
	0x3f, 0x26, 0xf4, 0xce, 0x73, 0x6d, 0x5c, 0x27, 0xd8, 0xf7, 0x69, 0x9c, 0xba, 0x30, 0xa8, 0x51,
	0xd0, 0x5c, 0x1b, 0x6f, 0x73, 0xe0, 0xd3, 0x14, 0x70, 0xca, 0xec, 0x1d, 0x8b, 0x7c, 0x28, 0x79,
	0xee, 0x51, 0xdd, 0xc6, 0x87, 0xd8, 0xae, 0xfb, 0xbe, 0x2d, 0x7f, 0x82, 0x51, 0x7e, 0x2b, 0xc5,
	0xf9, 0xc6, 0x3d, 0x7a, 0x40, 0xa1, 0x1e, 0x3d, 0x7a, 0x50, 0xbb, 0x7b, 0xdc, 0x51, 0xc6, 0x63,
	0x0d, 0x7d, 0x02, 0x98, 0x71, 0x4f, 0x74, 0xfb, 0xf6, 0x72, 0xee, 0x83, 0xef, 0x2a, 0x92, 0xfa,
	0xbf, 0x79, 0x18, 0xe5, 0x0b, 0x8b, 0x0c, 0xc8, 0xf3, 0x9d, 0x6f, 0x99, 0x2c, 0x71, 0x54, 0xaa,
	0x7d, 0xe9, 0xb8, 0xa3, 0x8c, 0x31, 0xd8, 0xf5, 0xd5, 0xe7, 0x1d, 0xe5, 0x73, 0x0d, 0xcb, 0xdf,
	0x6b, 0xed, 0x54, 0x0d, 0xf7, 0x60, 0x29, 0x64, 0xcd, 0xdc, 0x89, 0x7e, 0x2f, 0x35, 0xf7, 0x1b,
	0x4b, 0x2c, 0x8f, 0x86, 0x0f, 0x96, 0x0c, 0xdd, 0xb7, 0xcc, 0xea, 0x2a, 0x26, 0xc6, 0xfa, 0xaa,
	0x36, 0xc6, 0x30, 0xaf, 0x9b, 0x68, 0x0f, 0x0a, 0x81, 0x6a, 0x5a, 0x26, 0x4b, 0xeb, 0x94, 0x6a,
	0x1b, 0xc7, 0x1d, 0x25, 0xcf, 0x79, 0x60, 0x64, 0x3e, 0x7f, 0x0e, 0x32, 0x02, 0x5c, 0xcb, 0x73,
	0xec, 0x9c, 0xd2, 0xae, 0x7e, 0x60, 0xd9, 0x6d, 0x4a, 0x29, 0x17, 0x51, 0xba, 0xcf, 0x1a, 0xcf,
	0x4d, 0x49, 0x80, 0x6b, 0x79, 0x8e, 0x7d, 0xdd, 0x44, 0x0a, 0x8c, 0x07, 0x94, 0x58, 0x44, 0x36,
	0x32, 0x2f, 0x2d, 0x14, 0x34, 0xe0, 0x4d, 0x2c, 0x56, 0xaa, 0x06, 0x07, 0x39, 0x9e, 0x4c, 0x99,
	0xed, 0x5e, 0x57, 0x7c, 0x50, 0xe5, 0x59, 0xbe, 0x47, 0xc1, 0xe1, 0x6d, 0x16, 0xf2, 0x4e, 0xcb,
	0xb6, 0x59, 0x72, 0x60, 0x6c, 0x5e, 0x5a, 0xc8, 0x6b, 0xe1, 0x37, 0xba, 0x0b, 0xc5, 0x78, 0xd8,
	0xc5, 0x92, 0x1c, 0x05, 0x6d, 0x3c, 0x16, 0x16, 0xa1, 0xd7, 0xa0, 0x1c, 0x85, 0x43, 0x6c, 0x50,
	0x81, 0x0d, 0x2a, 0xba, 0xb1, 0x10, 0x07, 0xdd, 0x84, 0xd1, 0x3d, 0xcb, 0x34, 0xb1, 0xc3, 0xf2,
	0x0f, 0x79, 0x2d, 0xf8, 0x42, 0x2a, 0x14, 0x2d, 0x47, 0x37, 0x0c, 0x4c, 0x88, 0x45, 0x19, 0x18,
	0x67, 0xbd, 0x89, 0x36, 0x1a, 0x71, 0xcd, 0x36, 0xb0, 0x83, 0x3d, 0x9d, 0x06, 0x38, 0x3a, 0xa9,
	0x5b, 0x26, 0x76, 0x7c, 0xcb, 0x6f, 0xf3, 0x60, 0xa2, 0xc8, 0xa4, 0xad, 0x3d, 0xef, 0x28, 0x0f,
	0x53, 0x4b, 0x38, 0x91, 0x10, 0xad, 0xbe, 0x23, 0x90, 0xdf, 0x23, 0xeb, 0x01, 0x6a, 0xe6, 0xa6,
	0x6e, 0x35, 0xfa, 0x77, 0xa0, 0x2d, 0x78, 0xbd, 0x3f, 0x43, 0xd1, 0xd1, 0xbd, 0x49, 0x0f, 0x83,
	0x2c, 0x77, 0x50, 0xd0, 0xee, 0xf6, 0xc1, 0x13, 0x1e, 0xd6, 0xd9, 0x40, 0xf4, 0x33, 0x30, 0xd9,
	0x22, 0x98, 0x44, 0x08, 0x2c, 0x93, 0xc8, 0xe5, 0xf9, 0xec, 0x42, 0xa9, 0xb6, 0x75, 0xdc, 0x51,
	0x26, 0x1e, 0x13, 0x4c, 0x04, 0xc8, 0xfa, 0x2a, 0xb9, 0xd8, 0xfe, 0xa0, 0xe7, 0xb3, 0x08, 0x9b,
	0x49, 0xd0, 0xc7, 0xa0, 0x14, 0x04, 0x71, 0x1e, 0x5f, 0xc2, 0x09, 0xbe, 0x84, 0xa2, 0x91, 0x2d,
	0xe1, 0x02, 0x54, 0x9a, 0x8d, 0xba, 0xee, 0xfb, 0x9e, 0xb5, 0xd3, 0xf2, 0x71, 0xdd, 0x69, 0x1d,
	0xb0, 0xe3, 0x7e, 0x49, 0x2b, 0x37, 0x1b, 0xf7, 0x44, 0xf3, 0xc3, 0xd6, 0x01, 0x6a, 0x03, 0x22,
	0x6d, 0xe2, 0xe3, 0x83, 0x7a, 0xb0, 0xfb, 0xf6, 0x2d, 0xc7, 0x64, 0xc7, 0xfa, 0x52, 0x6d, 0xe3,
	0x79, 0x47, 0x79, 0xe7, 0x9c, 0xeb, 0xb4, 0xcd, 0x90, 0xf2, 0xdd, 0xb7, 0x61, 0x39, 0xa6, 0x56,
	0x21, 0x5d, 0x2d, 0x48, 0x86, 0xb1, 0x43, 0xcb, 0xf3, 0x5b, 0xba, 0xcd, 0x4e, 0xfe, 0x79, 0x4d,
	0x7c, 0xaa, 0x7f, 0x50, 0x80, 0x62, 0xdc, 0xbc, 0x0f, 0xc7, 0x02, 0x99, 0x90, 0xe7, 0x5e, 0xd8,
	0x32, 0x59, 0x0a, 0xbb, 0x54, 0x5b, 0xa7, 0x44, 0x18, 0x07, 0x8c, 0xc8, 0xf2, 0x39, 0x88, 0x04,
	0xd0, 0xda, 0x18, 0x43, 0xbd, 0x6e, 0xd2, 0xdd, 0xc5, 0xf3, 0xab, 0xcc, 0xc8, 0xe5, 0xb5, 0xe0,
	0x0b, 0xb5, 0xa0, 0xbc, 0x8f, 0xdb, 0xf5, 0xd0, 0x06, 0x12, 0x39, 0xc7, 0x54, 0x6a, 0xf3, 0xb8,
	0xa3, 0x14, 0x37, 0x70, 0x5b, 0x18, 0x32, 0x72, 0x51, 0x43, 0x58, 0xdc, 0x0f, 0x91, 0x99, 0x04,
	0xd9, 0x30, 0x13, 0x23, 0x6b, 0x5a, 0x1e, 0x36, 0xa8, 0x92, 0x13, 0x79, 0x64, 0x3e, 0xbb, 0x50,
	0x7e, 0xfb, 0xb3, 0x83, 0x25, 0xf1, 0xab, 0xab, 0x02, 0x81, 0x36, 0x15, 0x92, 0x09, 0xdb, 0x08,
	0x3b, 0x1b, 0x52, 0x72, 0xa4, 0xb5, 0xbb, 0x6b, 0x3d, 0x8b, 0x4f, 0x76, 0x94, 0x4d, 0xf6, 0xf1,
	0x71, 0x47, 0x41, 0x1b, 0xb8, 0xbd, 0xcd, 0xfa, 0x2f, 0x6d, 0xca, 0x68, 0xbf, 0x0b, 0xa5, 0x49,
	0xd0, 0xd7, 0x01, 0x91, 0x3d, 0xdd, 0x33, 0xb1, 0x59, 0x37, 0x31, 0x31, 0x3c, 0xab, 0xe9, 0xbb,
	0x5e, 0x90, 0x6b, 0xee, 0x0e, 0xbc, 0xc4, 0x35, 0x4d, 0xa0, 0xda, 0x1c, 0x6c, 0x35, 0x84, 0xd2,
	0x26, 0x49, 0x77, 0x13, 0xfa, 0xa6, 0x04, 0x88, 0xf8, 0xae, 0x67, 0x39, 0x8d, 0xf8, 0x34, 0xf3,
	0x6c, 0x9a, 0xdb, 0xc7, 0x1d, 0xa5, 0xb2, 0xcd, 0x7b, 0x2f, 0x6d, 0x92, 0x15, 0x92, 0x40, 0x68,
	0x12, 0xf4, 0x6d, 0x09, 0xa6, 0xa9, 0x59, 0x70, 0x89, 0xe5, 0xe3, 0x38, 0x17, 0x85, 0x48, 0xd8,
	0x2b, 0xa2, 0xff, 0xf2, 0x84, 0x6d, 0x74, 0xa1, 0x34, 0x09, 0xf5, 0x5b, 0x96, 0x73, 0x88, 0x3d,
	0x1f, 0x9b, 0x81, 0x53, 0x09, 0xbf, 0xa9, 0x5b, 0x31, 0x5c, 0xc7, 0x68, 0x79, 0x34, 0x22, 0xb1,
	0xdb, 0xc2, 0xad, 0xc4, 0xdb, 0xd0, 0x11, 0x4c, 0x10, 0xb7, 0xe5, 0x51, 0x5b, 0x2b, 0x76, 0x28,
	0x77, 0x25, 0x74, 0x77, 0x94, 0xb6, 0x59, 0xd7, 0xe5, 0xec, 0xd3, 0x12, 0x89, 0x21, 0x33, 0xd5,
	0x39, 0x28, 0x84, 0xea, 0x8b, 0xc6, 0x20, 0x7b, 0x6f, 0x7b, 0xa5, 0x72, 0x03, 0xe5, 0x21, 0xb7,
	0xba, 0xb6, 0xbd, 0x52, 0x91, 0xd4, 0x3f, 0x2e, 0x40, 0x39, 0x19, 0x7a, 0xbe, 0xb2, 0x55, 0x57,
	0x66, 0xab, 0x9c, 0x17, 0xdb, 0xaa, 0xe5, 0x41, 0x6f, 0x01, 0x5f, 0x59, 0xab, 0x57, 0xd6, 0xea,
	0x87, 0xca, 0x5a, 0xfd, 0x55, 0x16, 0x50, 0xef, 0xa5, 0xf4, 0x4b, 0x38, 0xdf, 0x65, 0xae, 0xf2,
	0x7c, 0x67, 0xc3, 0x78, 0x2c, 0x34, 0x8f, 0x9d, 0x25, 0x21, 0x8a, 0xca, 0x2f, 0x36, 0x29, 0x20,
	0x61, 0x40, 0x8e, 0xde, 0x0d, 0x8e, 0x70, 0xf4, 0x20, 0x59, 0x4e, 0x73, 0xf3, 0xd9, 0xbb, 0x00,
	0xb1, 0xeb, 0x39, 0xf5, 0x0d, 0xc8, 0xb1, 0x63, 0xcb, 0x38, 0x8c, 0x3d, 0x7e, 0xb8, 0xf1, 0x70,
	0xf3, 0xc9, 0x43, 0xbe, 0x82, 0x8f, 0xb7, 0xd7, 0xb6, 0x2b, 0x12, 0xfd, 0xb5, 0xf9, 0xe4, 0xe1,
	0x76, 0x25, 0xa3, 0xfe, 0x5d, 0x16, 0x2a, 0xdd, 0x89, 0x0d, 0xf4, 0x53, 0x89, 0x6b, 0x00, 0xc6,
	0x97, 0xc4, 0xf8, 0x1a, 0xe8, 0x1a, 0x80, 0xb1, 0x13, 0x4b, 0xeb, 0x33, 0x86, 0xde, 0x4a, 0x24,
	0x73, 0x5c, 0xcf, 0xb4, 0x1c, 0xdd, 0xe6, 0x0b, 0x19, 0xcf, 0x9e, 0x6c, 0xf2, 0x8e, 0x84, 0x4e,
	0x65, 0x87, 0xe1, 0x05, 0x73, 0x57, 0xe6, 0x05, 0xf7, 0x01, 0x62, 0xd6, 0x68, 0x84, 0x59, 0xa3,
	0x07, 0xc7, 0x1d, 0xa5, 0x70, 0x69, 0x46, 0xa8, 0x20, 0x74, 0x97, 0xa8, 0x7f, 0x92, 0x85, 0x89,
	0xae, 0xec, 0xd4, 0x0f, 0xdb, 0xaa, 0x22, 0xc8, 0xb1, 0x74, 0x49, 0x8e, 0x1d, 0x6c, 0xd9, 0x6f,
	0xda, 0xc6, 0x0e, 0xbb, 0x3c, 0x85, 0xc2, 0x7e, 0x77, 0xad, 0xcb, 0xe8, 0x95, 0xae, 0x0b, 0xba,
	0x03, 0x85, 0x43, 0xdd, 0xb6, 0x4c, 0x9d, 0x3a, 0x05, 0x9e, 0x7a, 0x89, 0x1a, 0xd4, 0x67, 0x90,
	0x17, 0xdb, 0xba, 0xdb, 0xfc, 0x48, 0x57, 0x6a, 0x7e, 0xd4, 0x6f, 0x65, 0x61, 0xb2, 0xe7, 0x95,
	0xca, 0x75, 0xb3, 0xe8, 0x7d, 0x33, 0x2e, 0xd9, 0x61, 0x65, 0x5c, 0xba, 0x13, 0x6b, 0xb9, 0x9e,
	0xc4, 0x9a, 0xba, 0x0f, 0xb9, 0xaf, 0x58, 0xf8, 0x68, 0x28, 0x72, 0x57, 0x6d, 0x18, 0x61, 0x08,
	0x87, 0x43, 0xed, 0x6f, 0x32, 0x70, 0xfb, 0xd4, 0x1b, 0xd0, 0xeb, 0xa6, 0x68, 0x3f, 0x0d, 0x63,
	0xec, 0xce, 0x2d, 0x34, 0x6f, 0xef, 0x1c, 0x77, 0x94, 0x51, 0x3a, 0xe5, 0x8b, 0x4e, 0x66, 0x94,
	0xe2, 0x0d, 0xc4, 0x79, 0xea, 0xd5, 0xed, 0x2b, 0x71, 0x0e, 0x2a, 0xce, 0xbf, 0xce, 0x80, 0x7c,
	0xda, 0x6b, 0x81, 0x57, 0xd2, 0x1c, 0x54, 0x9a, 0x7f, 0x99, 0x81, 0xa9, 0x3e, 0xb7, 0xe8, 0xaf,
	0x04, 0x39, 0xa8, 0x20, 0x7f, 0x3b, 0x03, 0x77, 0x5e, 0x74, 0x09, 0x3f, 0x1c, 0x89, 0x0e, 0x18,
	0xdc, 0x5d, 0xbd, 0x58, 0xfe, 0x51, 0x82, 0xc9, 0x9e, 0x67, 0x22, 0xc3, 0x91, 0xc5, 0xd5, 0x4f,
	0xee, 0xcf, 0x46, 0x00, 0x62, 0xcf, 0x54, 0x77, 0xa1, 0xe0, 0x7a, 0x56, 0xc3, 0x72, 0xa2, 0x69,
	0xd1, 0xc3, 0x49, 0x7e, 0x93, 0x35, 0x5e, 0x94, 0x68, 0x9e, 0xe3, 0x5e, 0x37, 0xd1, 0x2e, 0x94,
	0x03, 0x3a, 0x5c, 0xbf, 0x45, 0x60, 0xf4, 0xc5, 0x8b, 0xee, 0x97, 0x12, 0x47, 0xcb, 0xbf, 0x09,
	0x72, 0xa1, 0x18, 0xbe, 0x44, 0x89, 0xce, 0x5b, 0x0f, 0xd8, 0xdd, 0xb2, 0x68, 0xbf, 0xe8, 0xac,
	0xc6, 0x43, 0x0a, 0xec, 0x18, 0x3f, 0x19, 0x11, 0x14, 0x73, 0x1b, 0xb9, 0x9c, 0xb9, 0x55, 0x42,
	0xcc, 0x62, 0x7a, 0x3e, 0x14, 0xc2, 0xab, 0x51, 0x76, 0x1d, 0x5b, 0xaa, 0x3d, 0x61, 0xcb, 0x15,
	0x84, 0x3e, 0x17, 0xb8, 0x0a, 0x8b, 0x94, 0xe2, 0x1e, 0x4f, 0x36, 0xe6, 0xc5, 0x75, 0x6b, 0x40,
	0xd5, 0xc4, 0x36, 0xf6, 0xf9, 0x85, 0x6e, 0x48, 0x75, 0x95, 0xb5, 0x5d, 0x32, 0x55, 0x8e, 0x34,
	0x3c, 0x60, 0xe5, 0xa3, 0x03, 0x96, 0xfa, 0x0f, 0x23, 0x70, 0xeb, 0x94, 0x37, 0xd9, 0x43, 0x53,
	0xe5, 0xa3, 0x53, 0x54, 0x99, 0xc6, 0xf8, 0xa5, 0xcd, 0xb8, 0x36, 0xfe, 0x7f, 0xd7, 0xed, 0x6f,
	0x48, 0xa7, 0x2b, 0x37, 0x4b, 0xb7, 0x6a, 0x5d, 0xfa, 0x79, 0xf9, 0x0a, 0xbf, 0xd7, 0xab, 0xf0,
	0x1b, 0x57, 0xa3, 0xe4, 0x7b, 0xbd, 0x4a, 0xbe, 0x31, 0x3c, 0xc5, 0xfe, 0x6f, 0x09, 0x26, 0xba,
	0x5e, 0xdb, 0x0f, 0xf7, 0x88, 0x8e, 0x08, 0x94, 0xd9, 0x73, 0xeb, 0x7a, 0xe8, 0xe5, 0x78, 0x74,
	0xf3, 0xee, 0x71, 0x47, 0x29, 0xb2, 0x57, 0xdc, 0x97, 0xe2, 0xea, 0x8a, 0x6e, 0x84, 0xca, 0x54,
	0xff, 0x3e, 0x03, 0xd3, 0xfd, 0x8a, 0x1c, 0x86, 0xe3, 0x6d, 0x1d, 0x18, 0x8f, 0x55, 0x66, 0xc4,
	0xe7, 0x1b, 0xe7, 0xe5, 0x82, 0x22, 0x36, 0x43, 0x54, 0xc3, 0x7b, 0x3c, 0xa4, 0xee, 0x05, 0xf9,
	0xd9, 0x58, 0x3c, 0x21, 0x5d, 0x4d, 0x3c, 0xf1, 0x9f, 0x12, 0x8c, 0xf2, 0xf7, 0x82, 0xd4, 0x00,
	0x07, 0x8f, 0x11, 0x93, 0x06, 0x98, 0x77, 0x5f, 0xd8, 0x00, 0x73, 0xdc, 0xeb, 0x26, 0xfa, 0x39,
	0x98, 0x14, 0x75, 0x6e, 0x7e, 0xdd, 0xdd, 0x79, 0x0f, 0x1b, 0xbe, 0xb0, 0xc1, 0x5f, 0xa6, 0x56,
	0x49, 0xa4, 0xac, 0xfd, 0x4d, 0xde, 0x77, 0x31, 0xba, 0x15, 0xb3, 0x0b, 0x9d, 0xfa, 0xcf, 0x12,
	0xe4, 0xc5, 0x93, 0x38, 0xba, 0x49, 0xc3, 0xe7, 0x77, 0xc9, 0x4d, 0x2a, 0x86, 0x5c, 0x78, 0x93,
	0x0a, 0xfc, 0xeb, 0x26, 0x7a, 0xef, 0xf4, 0xa9, 0x7f, 0xe1, 0xb2, 0xa7, 0xf9, 0xab, 0x59, 0x98,
	0xec, 0x29, 0x61, 0xb9, 0x4e, 0xf7, 0xc6, 0x7f, 0xd4, 0x5d, 0xd9, 0x93, 0xed, 0xfb, 0xe6, 0x33,
	0x79, 0x51, 0x19, 0x17, 0x46, 0x74, 0x35, 0x59, 0xfb, 0xf2, 0xf3, 0x8e, 0xf2, 0xee, 0x39, 0x5d,
	0x45, 0x7f, 0x94, 0xc9, 0x0a, 0x20, 0xf5, 0x5f, 0x33, 0x50, 0x08, 0xcb, 0x79, 0x86, 0xac, 0x75,
	0x89, 0x8d, 0x9d, 0xb9, 0xba, 0x8d, 0xed, 0x41, 0x29, 0xba, 0x36, 0x8e, 0x6c, 0x64, 0x60, 0x91,
	0x45, 0xc7, 0x85, 0x3d, 0x50, 0x44, 0xa3, 0x7f, 0x1a, 0x5f, 0x7d, 0x5f, 0x82, 0x11, 0x5e, 0xc2,
	0xd6, 0xc3, 0x91, 0x74, 0xf5, 0x1c, 0x4d, 0x8b, 0x1a, 0xab, 0x0c, 0x63, 0x89, 0x7f, 0xa8, 0x7f,
	0x21, 0x41, 0x39, 0x59, 0xcb, 0xf4, 0x52, 0x98, 0x9b, 0x85, 0x7c, 0x8b, 0x60, 0x8f, 0x89, 0x8c,
	0xf3, 0x17, 0x7e, 0xa3, 0x39, 0x80, 0x58, 0x85, 0x16, 0x5b, 0x3b, 0x2d, 0xd6, 0xa2, 0x7e, 0x27,
	0x03, 0x79, 0x51, 0xa0, 0xf4, 0x52, 0x98, 0xff, 0x2d, 0x29, 0x56, 0x53, 0x95, 0xe9, 0x5b, 0xf5,
	0x94, 0xdc, 0xec, 0x82, 0xdb, 0x15, 0xd7, 0xd9, 0xb5, 0x1a, 0xb5, 0xf5, 0xe7, 0x1d, 0x65, 0xed,
	0x9c, 0x9b, 0x3c, 0x89, 0x2a, 0xaa, 0xc5, 0x52, 0xff, 0x56, 0x82, 0xf8, 0xb3, 0xe7, 0xe1, 0x18,
	0xd8, 0xaf, 0x77, 0x3f, 0xd9, 0xce, 0xf4, 0xad, 0xb2, 0x4c, 0x4a, 0x23, 0xfe, 0x5a, 0x7b, 0xa2,
	0xeb, 0xb5, 0x76, 0xe2, 0x6d, 0xb6, 0xfa, 0x1f, 0x12, 0x40, 0x54, 0xeb, 0x76, 0xdd, 0x12, 0x73,
	0xc2, 0x64, 0x64, 0x63, 0x26, 0xe3, 0xdf, 0x24, 0x28, 0x84, 0xe5, 0x71, 0xd7, 0xc9, 0x49, 0xf6,
	0x9b, 0xec, 0x77, 0x32, 0x50, 0x4e, 0x96, 0xe3, 0x0d, 0x67, 0xc6, 0x7d, 0x6e, 0x98, 0x33, 0x57,
	0x7a, 0xc3, 0x9c, 0x3d, 0x2d, 0x09, 0xd9, 0xcf, 0x6b, 0xfc, 0x60, 0x04, 0x2a, 0x41, 0x92, 0x3f,
	0x34, 0xd2, 0x2f, 0xc5, 0xcc, 0x19, 0x50, 0xc2, 0xcf, 0x9a, 0xb6, 0x65, 0x58, 0x3e, 0xab, 0x08,
	0x09, 0x36, 0xf7, 0x8f, 0x77, 0x0b, 0xe9, 0xa9, 0x4d, 0xfd, 0x7b, 0xb5, 0x9b, 0x67, 0x72, 0xdf,
	0xf5, 0x34, 0xd7, 0xc6, 0xd5, 0xb5, 0x00, 0x09, 0xfd, 0xf8, 0xd2, 0x0d, 0xad, 0x88, 0x63, 0xdf,
	0x68, 0x1f, 0x4a, 0xbb, 0xae, 0x57, 0xd7, 0x6d, 0x9b, 0xd1, 0x20, 0x41, 0xf0, 0xb4, 0x36, 0x28,
	0x91, 0xfb, 0xae, 0x77, 0xcf, 0xb6, 0xe9, 0x4f, 0xb2, 0x45, 0x70, 0xcb, 0x74, 0x03, 0x6a, 0xe3,
	0xbb, 0x51, 0x07, 0xfa, 0x79, 0x98, 0x89, 0xfc, 0x48, 0xbd, 0x89, 0xbd, 0x20, 0xf6, 0x65, 0x0f,
	0xfa, 0xc6, 0xdf, 0xde, 0x48, 0x5d, 0xab, 0x19, 0xd2, 0xaf, 0x46, 0x9c, 0x6c, 0x61, 0x8f, 0x87,
	0xbc, 0xac, 0xc4, 0x4d, 0x9b, 0x6a, 0xf6, 0xf6, 0xcc, 0xbe, 0x07, 0x37, 0x03, 0x0c, 0xbc, 0x21,
	0x5a, 0xe0, 0xad, 0x84, 0xd3, 0x93, 0x18, 0x3f, 0x03, 0x97, 0x25, 0xc7, 0xdd, 0xe4, 0xec, 0xfb,
	0x12, 0xc8, 0xa7, 0x71, 0x87, 0x2a, 0x90, 0xdd, 0xc7, 0x6d, 0xae, 0x45, 0x1a, 0xfd, 0x89, 0xea,
	0x30, 0x72, 0xa8, 0xdb, 0x2d, 0xb1, 0xca, 0xeb, 0xe7, 0x90, 0x45, 0xff, 0xa9, 0x69, 0x1c, 0xef,
	0x72, 0xe6, 0xb3, 0x52, 0x6d, 0x14, 0x72, 0x74, 0x95, 0xd5, 0x7f, 0x97, 0x60, 0xaa, 0x4f, 0x0d,
	0xe1, 0xf5, 0x8c, 0x47, 0xd5, 0x5f, 0x97, 0xa0, 0x18, 0xaf, 0x0a, 0x1c, 0x8e, 0x95, 0x93, 0x61,
	0x4c, 0x14, 0xa1, 0xf1, 0x08, 0x4b, 0x7c, 0xaa, 0xbf, 0x2b, 0xc1, 0x44, 0x57, 0xa5, 0xe0, 0x90,
	0x25, 0x7f, 0x3a, 0x6f, 0xef, 0x4b, 0x50, 0x4a, 0x94, 0x14, 0x0e, 0x2d, 0x1d, 0x70, 0x3a, 0x4f,
	0xff, 0x25, 0x41, 0x31, 0x5e, 0x7a, 0x78, 0x9d, 0xfc, 0x72, 0x6c, 0xd6, 0xd9, 0xe4, 0xac, 0xff,
	0x47, 0x82, 0x52, 0xa2, 0x0c, 0xf2, 0xba, 0xc5, 0x5f, 0xa7, 0x4f, 0xfd, 0xd7, 0x32, 0x30, 0xd9,
	0x53, 0x8f, 0x39, 0x9c, 0xe9, 0x3f, 0x83, 0x52, 0x2c, 0x80, 0x08, 0x45, 0xb0, 0x4d, 0x1d, 0x7d,
	0xc4, 0x12, 0x23, 0xf7, 0xc5, 0x73, 0x89, 0x21, 0x42, 0xc1, 0xde, 0xf1, 0x8a, 0xaf, 0x17, 0x89,
	0xe3, 0xf7, 0x63, 0xd6, 0x3a, 0x5e, 0xb0, 0x39, 0x5c, 0x9b, 0xf1, 0x11, 0x28, 0xb0, 0xba, 0xd4,
	0xf8, 0x99, 0x91, 0x36, 0xd0, 0xb8, 0x71, 0x39, 0xf7, 0x2f, 0xdf, 0x55, 0xa4, 0x37, 0xbf, 0x1a,
	0x8f, 0x27, 0xc5, 0xc3, 0xd2, 0x75, 0x87, 0xbd, 0x5c, 0xab, 0xdc, 0x40, 0x37, 0x01, 0xf1, 0x37,
	0xa4, 0x4f, 0x2c, 0x7f, 0xcf, 0x6d, 0xf9, 0x6c, 0x33, 0x54, 0x24, 0x54, 0x80, 0x11, 0x76, 0x7d,
	0x5d, 0xc9, 0xa0, 0x51, 0xc8, 0xdc, 0xdf, 0xa8, 0x64, 0x51, 0x19, 0x20, 0xa8, 0xf4, 0xd9, 0xc0,
	0xed, 0x4a, 0xae, 0xf6, 0xe6, 0x07, 0x3f, 0x98, 0xbb, 0xf1, 0x87, 0xc7, 0x73, 0xd2, 0x07, 0xc7,
	0x73, 0xd2, 0xf7, 0x8e, 0xe7, 0xa4, 0xef, 0x1f, 0xcf, 0x49, 0xff, 0x74, 0x3c, 0x27, 0xfd, 0xe6,
	0x87, 0x73, 0x37, 0xbe, 0xf7, 0xe1, 0xdc, 0x8d, 0xef, 0x7f, 0x38, 0x77, 0xe3, 0x6b, 0x39, 0xea,
	0x17, 0x77, 0x46, 0xd9, 0xdf, 0x23, 0xfb, 0xd4, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x01, 0x89,
	0x7e, 0x40, 0x4b, 0x4d, 0x00, 0x00,
}

func (this *ElementProto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto)
	if !ok {
		that2, ok := that.(ElementProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Column.Equal(that1.Column) {
		return false
	}
	if !this.PrimaryIndex.Equal(that1.PrimaryIndex) {
		return false
	}
	if !this.SecondaryIndex.Equal(that1.SecondaryIndex) {
		return false
	}
	if !this.SequenceDependency.Equal(that1.SequenceDependency) {
		return false
	}
	if !this.UniqueConstraint.Equal(that1.UniqueConstraint) {
		return false
	}
	if !this.CheckConstraint.Equal(that1.CheckConstraint) {
		return false
	}
	if !this.Sequence.Equal(that1.Sequence) {
		return false
	}
	if !this.DefaultExpression.Equal(that1.DefaultExpression) {
		return false
	}
	if !this.View.Equal(that1.View) {
		return false
	}
	if !this.Table.Equal(that1.Table) {
		return false
	}
	if !this.OutForeignKey.Equal(that1.OutForeignKey) {
		return false
	}
	if !this.InForeignKey.Equal(that1.InForeignKey) {
		return false
	}
	if !this.RelationDependedOnBy.Equal(that1.RelationDependedOnBy) {
		return false
	}
	if !this.SequenceOwner.Equal(that1.SequenceOwner) {
		return false
	}
	if !this.Type.Equal(that1.Type) {
		return false
	}
	if !this.Schema.Equal(that1.Schema) {
		return false
	}
	if !this.Database.Equal(that1.Database) {
		return false
	}
	if !this.Partitioning.Equal(that1.Partitioning) {
		return false
	}
	if !this.Namespace.Equal(that1.Namespace) {
		return false
	}
	if !this.Owner.Equal(that1.Owner) {
		return false
	}
	if !this.UserPrivileges.Equal(that1.UserPrivileges) {
		return false
	}
	if !this.ColumnName.Equal(that1.ColumnName) {
		return false
	}
	if !this.Locality.Equal(that1.Locality) {
		return false
	}
	if !this.IndexName.Equal(that1.IndexName) {
		return false
	}
	if !this.ConstraintName.Equal(that1.ConstraintName) {
		return false
	}
	if !this.DefaultExprTypeRef.Equal(that1.DefaultExprTypeRef) {
		return false
	}
	if !this.OnUpdateTypeReference.Equal(that1.OnUpdateTypeReference) {
		return false
	}
	if !this.ComputedExprTypeReference.Equal(that1.ComputedExprTypeReference) {
		return false
	}
	if !this.ViewDependsOnType.Equal(that1.ViewDependsOnType) {
		return false
	}
	if !this.ColumnTypeReference.Equal(that1.ColumnTypeReference) {
		return false
	}
	if !this.SchemaEntry.Equal(that1.SchemaEntry) {
		return false
	}
	if !this.CheckConstraintTypeReference.Equal(that1.CheckConstraintTypeReference) {
		return false
	}
	if !this.TableComment.Equal(that1.TableComment) {
		return false
	}
	if !this.DatabaseComment.Equal(that1.DatabaseComment) {
		return false
	}
	if !this.SchemaComment.Equal(that1.SchemaComment) {
		return false
	}
	if !this.IndexComment.Equal(that1.IndexComment) {
		return false
	}
	if !this.ColumnComment.Equal(that1.ColumnComment) {
		return false
	}
	if !this.ConstraintComment.Equal(that1.ConstraintComment) {
		return false
	}
	if !this.DatabaseRoleSetting.Equal(that1.DatabaseRoleSetting) {
		return false
	}
	if !this.RowLevelTTL.Equal(that1.RowLevelTTL) {
		return false
	}
	return true
}
func (this *Column) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Column)
	if !ok {
		that2, ok := that.(Column)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.FamilyID != that1.FamilyID {
		return false
	}
	if this.FamilyName != that1.FamilyName {
		return false
	}
	if !this.Type.Equal(that1.Type) {
		return false
	}
	if this.Nullable != that1.Nullable {
		return false
	}
	if this.DefaultExpr != that1.DefaultExpr {
		return false
	}
	if this.OnUpdateExpr != that1.OnUpdateExpr {
		return false
	}
	if this.Hidden != that1.Hidden {
		return false
	}
	if this.Inaccessible != that1.Inaccessible {
		return false
	}
	if this.GeneratedAsIdentityType != that1.GeneratedAsIdentityType {
		return false
	}
	if this.GeneratedAsIdentitySequenceOption != that1.GeneratedAsIdentitySequenceOption {
		return false
	}
	if len(this.UsesSequenceIDs) != len(that1.UsesSequenceIDs) {
		return false
	}
	for i := range this.UsesSequenceIDs {
		if this.UsesSequenceIDs[i] != that1.UsesSequenceIDs[i] {
			return false
		}
	}
	if this.ComputerExpr != that1.ComputerExpr {
		return false
	}
	if this.PgAttributeNum != that1.PgAttributeNum {
		return false
	}
	if this.SystemColumnKind != that1.SystemColumnKind {
		return false
	}
	if this.Virtual != that1.Virtual {
		return false
	}
	return true
}
func (this *PrimaryIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PrimaryIndex)
	if !ok {
		that2, ok := that.(PrimaryIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if this.Unique != that1.Unique {
		return false
	}
	if len(this.KeyColumnIDs) != len(that1.KeyColumnIDs) {
		return false
	}
	for i := range this.KeyColumnIDs {
		if this.KeyColumnIDs[i] != that1.KeyColumnIDs[i] {
			return false
		}
	}
	if len(this.KeyColumnDirections) != len(that1.KeyColumnDirections) {
		return false
	}
	for i := range this.KeyColumnDirections {
		if this.KeyColumnDirections[i] != that1.KeyColumnDirections[i] {
			return false
		}
	}
	if len(this.KeySuffixColumnIDs) != len(that1.KeySuffixColumnIDs) {
		return false
	}
	for i := range this.KeySuffixColumnIDs {
		if this.KeySuffixColumnIDs[i] != that1.KeySuffixColumnIDs[i] {
			return false
		}
	}
	if !this.ShardedDescriptor.Equal(that1.ShardedDescriptor) {
		return false
	}
	if len(this.StoringColumnIDs) != len(that1.StoringColumnIDs) {
		return false
	}
	for i := range this.StoringColumnIDs {
		if this.StoringColumnIDs[i] != that1.StoringColumnIDs[i] {
			return false
		}
	}
	if len(this.CompositeColumnIDs) != len(that1.CompositeColumnIDs) {
		return false
	}
	for i := range this.CompositeColumnIDs {
		if this.CompositeColumnIDs[i] != that1.CompositeColumnIDs[i] {
			return false
		}
	}
	if this.Inverted != that1.Inverted {
		return false
	}
	if this.Concurrently != that1.Concurrently {
		return false
	}
	if this.SourceIndexID != that1.SourceIndexID {
		return false
	}
	return true
}
func (this *SecondaryIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecondaryIndex)
	if !ok {
		that2, ok := that.(SecondaryIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if this.Unique != that1.Unique {
		return false
	}
	if len(this.KeyColumnIDs) != len(that1.KeyColumnIDs) {
		return false
	}
	for i := range this.KeyColumnIDs {
		if this.KeyColumnIDs[i] != that1.KeyColumnIDs[i] {
			return false
		}
	}
	if len(this.KeyColumnDirections) != len(that1.KeyColumnDirections) {
		return false
	}
	for i := range this.KeyColumnDirections {
		if this.KeyColumnDirections[i] != that1.KeyColumnDirections[i] {
			return false
		}
	}
	if len(this.KeySuffixColumnIDs) != len(that1.KeySuffixColumnIDs) {
		return false
	}
	for i := range this.KeySuffixColumnIDs {
		if this.KeySuffixColumnIDs[i] != that1.KeySuffixColumnIDs[i] {
			return false
		}
	}
	if !this.ShardedDescriptor.Equal(that1.ShardedDescriptor) {
		return false
	}
	if len(this.StoringColumnIDs) != len(that1.StoringColumnIDs) {
		return false
	}
	for i := range this.StoringColumnIDs {
		if this.StoringColumnIDs[i] != that1.StoringColumnIDs[i] {
			return false
		}
	}
	if len(this.CompositeColumnIDs) != len(that1.CompositeColumnIDs) {
		return false
	}
	for i := range this.CompositeColumnIDs {
		if this.CompositeColumnIDs[i] != that1.CompositeColumnIDs[i] {
			return false
		}
	}
	if this.Inverted != that1.Inverted {
		return false
	}
	if this.Concurrently != that1.Concurrently {
		return false
	}
	if this.SourceIndexID != that1.SourceIndexID {
		return false
	}
	return true
}
func (this *SequenceDependency) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SequenceDependency)
	if !ok {
		that2, ok := that.(SequenceDependency)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.SequenceID != that1.SequenceID {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *UniqueConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UniqueConstraint)
	if !ok {
		that2, ok := that.(UniqueConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ConstraintType != that1.ConstraintType {
		return false
	}
	if this.ConstraintOrdinal != that1.ConstraintOrdinal {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	return true
}
func (this *CheckConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckConstraint)
	if !ok {
		that2, ok := that.(CheckConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ConstraintType != that1.ConstraintType {
		return false
	}
	if this.ConstraintOrdinal != that1.ConstraintOrdinal {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Expr != that1.Expr {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	if this.Validated != that1.Validated {
		return false
	}
	return true
}
func (this *Sequence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Sequence)
	if !ok {
		that2, ok := that.(Sequence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SequenceID != that1.SequenceID {
		return false
	}
	return true
}
func (this *DefaultExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultExpression)
	if !ok {
		that2, ok := that.(DefaultExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if len(this.UsesSequenceIDs) != len(that1.UsesSequenceIDs) {
		return false
	}
	for i := range this.UsesSequenceIDs {
		if this.UsesSequenceIDs[i] != that1.UsesSequenceIDs[i] {
			return false
		}
	}
	if this.DefaultExpr != that1.DefaultExpr {
		return false
	}
	return true
}
func (this *View) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*View)
	if !ok {
		that2, ok := that.(View)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	return true
}
func (this *Table) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Table)
	if !ok {
		that2, ok := that.(Table)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	return true
}
func (this *OnUpdateExprTypeReference) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OnUpdateExprTypeReference)
	if !ok {
		that2, ok := that.(OnUpdateExprTypeReference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.TypeID != that1.TypeID {
		return false
	}
	return true
}
func (this *ComputedExprTypeReference) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ComputedExprTypeReference)
	if !ok {
		that2, ok := that.(ComputedExprTypeReference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.TypeID != that1.TypeID {
		return false
	}
	return true
}
func (this *DefaultExprTypeReference) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultExprTypeReference)
	if !ok {
		that2, ok := that.(DefaultExprTypeReference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.TypeID != that1.TypeID {
		return false
	}
	return true
}
func (this *ColumnTypeReference) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnTypeReference)
	if !ok {
		that2, ok := that.(ColumnTypeReference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.TypeID != that1.TypeID {
		return false
	}
	return true
}
func (this *CheckConstraintTypeReference) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckConstraintTypeReference)
	if !ok {
		that2, ok := that.(CheckConstraintTypeReference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintOrdinal != that1.ConstraintOrdinal {
		return false
	}
	if this.TypeID != that1.TypeID {
		return false
	}
	return true
}
func (this *ViewDependsOnType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ViewDependsOnType)
	if !ok {
		that2, ok := that.(ViewDependsOnType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.TypeID != that1.TypeID {
		return false
	}
	return true
}
func (this *ForeignKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ForeignKey)
	if !ok {
		that2, ok := that.(ForeignKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OriginID != that1.OriginID {
		return false
	}
	if len(this.OriginColumns) != len(that1.OriginColumns) {
		return false
	}
	for i := range this.OriginColumns {
		if this.OriginColumns[i] != that1.OriginColumns[i] {
			return false
		}
	}
	if this.ReferenceID != that1.ReferenceID {
		return false
	}
	if len(this.ReferenceColumns) != len(that1.ReferenceColumns) {
		return false
	}
	for i := range this.ReferenceColumns {
		if this.ReferenceColumns[i] != that1.ReferenceColumns[i] {
			return false
		}
	}
	if this.OnUpdate != that1.OnUpdate {
		return false
	}
	if this.OnDelete != that1.OnDelete {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *ForeignKeyBackReference) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ForeignKeyBackReference)
	if !ok {
		that2, ok := that.(ForeignKeyBackReference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OriginID != that1.OriginID {
		return false
	}
	if len(this.OriginColumns) != len(that1.OriginColumns) {
		return false
	}
	for i := range this.OriginColumns {
		if this.OriginColumns[i] != that1.OriginColumns[i] {
			return false
		}
	}
	if this.ReferenceID != that1.ReferenceID {
		return false
	}
	if len(this.ReferenceColumns) != len(that1.ReferenceColumns) {
		return false
	}
	for i := range this.ReferenceColumns {
		if this.ReferenceColumns[i] != that1.ReferenceColumns[i] {
			return false
		}
	}
	if this.OnUpdate != that1.OnUpdate {
		return false
	}
	if this.OnDelete != that1.OnDelete {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *SequenceOwnedBy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SequenceOwnedBy)
	if !ok {
		that2, ok := that.(SequenceOwnedBy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SequenceID != that1.SequenceID {
		return false
	}
	if this.OwnerTableID != that1.OwnerTableID {
		return false
	}
	return true
}
func (this *RelationDependedOnBy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RelationDependedOnBy)
	if !ok {
		that2, ok := that.(RelationDependedOnBy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.DependedOnBy != that1.DependedOnBy {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	return true
}
func (this *Type) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Type)
	if !ok {
		that2, ok := that.(Type)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TypeID != that1.TypeID {
		return false
	}
	return true
}
func (this *Schema) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Schema)
	if !ok {
		that2, ok := that.(Schema)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SchemaID != that1.SchemaID {
		return false
	}
	if len(this.DependentObjects) != len(that1.DependentObjects) {
		return false
	}
	for i := range this.DependentObjects {
		if this.DependentObjects[i] != that1.DependentObjects[i] {
			return false
		}
	}
	return true
}
func (this *Database) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Database)
	if !ok {
		that2, ok := that.(Database)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	if len(this.DependentObjects) != len(that1.DependentObjects) {
		return false
	}
	for i := range this.DependentObjects {
		if this.DependentObjects[i] != that1.DependentObjects[i] {
			return false
		}
	}
	return true
}
func (this *IndexPartitioning) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndexPartitioning)
	if !ok {
		that2, ok := that.(IndexPartitioning)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if !this.Partitioning.Equal(that1.Partitioning) {
		return false
	}
	return true
}
func (this *Namespace) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Namespace)
	if !ok {
		that2, ok := that.(Namespace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	if this.SchemaID != that1.SchemaID {
		return false
	}
	if this.DescriptorID != that1.DescriptorID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *Owner) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Owner)
	if !ok {
		that2, ok := that.(Owner)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DescriptorID != that1.DescriptorID {
		return false
	}
	if this.Owner != that1.Owner {
		return false
	}
	return true
}
func (this *UserPrivileges) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserPrivileges)
	if !ok {
		that2, ok := that.(UserPrivileges)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DescriptorID != that1.DescriptorID {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if this.Privileges != that1.Privileges {
		return false
	}
	return true
}
func (this *Locality) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Locality)
	if !ok {
		that2, ok := that.(Locality)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DescriptorID != that1.DescriptorID {
		return false
	}
	if !this.Locality.Equal(that1.Locality) {
		return false
	}
	return true
}
func (this *RowLevelTTL) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RowLevelTTL)
	if !ok {
		that2, ok := that.(RowLevelTTL)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if !this.RowLevelTTL.Equal(that1.RowLevelTTL) {
		return false
	}
	return true
}
func (this *ColumnName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnName)
	if !ok {
		that2, ok := that.(ColumnName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *IndexName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndexName)
	if !ok {
		that2, ok := that.(IndexName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *ConstraintName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConstraintName)
	if !ok {
		that2, ok := that.(ConstraintName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintType != that1.ConstraintType {
		return false
	}
	if this.ConstraintOrdinal != that1.ConstraintOrdinal {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *DefaultPrivilege) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultPrivilege)
	if !ok {
		that2, ok := that.(DefaultPrivilege)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DescriptorID != that1.DescriptorID {
		return false
	}
	if that1.Role == nil {
		if this.Role != nil {
			return false
		}
	} else if this.Role == nil {
		return false
	} else if !this.Role.Equal(that1.Role) {
		return false
	}
	if len(this.PrivilegesPerObject) != len(that1.PrivilegesPerObject) {
		return false
	}
	for i := range this.PrivilegesPerObject {
		if !this.PrivilegesPerObject[i].Equal(that1.PrivilegesPerObject[i]) {
			return false
		}
	}
	return true
}
func (this *DefaultPrivilege_ExplicitRole) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultPrivilege_ExplicitRole)
	if !ok {
		that2, ok := that.(DefaultPrivilege_ExplicitRole)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExplicitRole.Equal(that1.ExplicitRole) {
		return false
	}
	return true
}
func (this *DefaultPrivilege_ForAllRoles) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultPrivilege_ForAllRoles)
	if !ok {
		that2, ok := that.(DefaultPrivilege_ForAllRoles)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ForAllRoles.Equal(that1.ForAllRoles) {
		return false
	}
	return true
}
func (this *DefaultPrivilege_DefaultObjectPrivilege) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultPrivilege_DefaultObjectPrivilege)
	if !ok {
		that2, ok := that.(DefaultPrivilege_DefaultObjectPrivilege)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Privileges) != len(that1.Privileges) {
		return false
	}
	for i := range this.Privileges {
		if !this.Privileges[i].Equal(that1.Privileges[i]) {
			return false
		}
	}
	return true
}
func (this *DatabaseSchemaEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DatabaseSchemaEntry)
	if !ok {
		that2, ok := that.(DatabaseSchemaEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	if this.SchemaID != that1.SchemaID {
		return false
	}
	return true
}
func (this *TableComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableComment)
	if !ok {
		that2, ok := that.(TableComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *DatabaseComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DatabaseComment)
	if !ok {
		that2, ok := that.(DatabaseComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *SchemaComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SchemaComment)
	if !ok {
		that2, ok := that.(SchemaComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SchemaID != that1.SchemaID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *IndexComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndexComment)
	if !ok {
		that2, ok := that.(IndexComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *ColumnComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnComment)
	if !ok {
		that2, ok := that.(ColumnComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *ConstraintComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConstraintComment)
	if !ok {
		that2, ok := that.(ConstraintComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *DatabaseRoleSetting) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DatabaseRoleSetting)
	if !ok {
		that2, ok := that.(DatabaseRoleSetting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	if this.RoleName != that1.RoleName {
		return false
	}
	return true
}
func (m *ElementProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ElementProto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SequenceOwner != nil {
		{
			size, err := m.SequenceOwner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	if m.RowLevelTTL != nil {
		{
			size, err := m.RowLevelTTL.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if m.DatabaseRoleSetting != nil {
		{
			size, err := m.DatabaseRoleSetting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.ConstraintComment != nil {
		{
			size, err := m.ConstraintComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if m.ColumnComment != nil {
		{
			size, err := m.ColumnComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	if m.IndexComment != nil {
		{
			size, err := m.IndexComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if m.SchemaComment != nil {
		{
			size, err := m.SchemaComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if m.DatabaseComment != nil {
		{
			size, err := m.DatabaseComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.TableComment != nil {
		{
			size, err := m.TableComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if m.CheckConstraintTypeReference != nil {
		{
			size, err := m.CheckConstraintTypeReference.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.SchemaEntry != nil {
		{
			size, err := m.SchemaEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.ColumnTypeReference != nil {
		{
			size, err := m.ColumnTypeReference.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.ViewDependsOnType != nil {
		{
			size, err := m.ViewDependsOnType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.ComputedExprTypeReference != nil {
		{
			size, err := m.ComputedExprTypeReference.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.OnUpdateTypeReference != nil {
		{
			size, err := m.OnUpdateTypeReference.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.DefaultExprTypeRef != nil {
		{
			size, err := m.DefaultExprTypeRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.ConstraintName != nil {
		{
			size, err := m.ConstraintName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.IndexName != nil {
		{
			size, err := m.IndexName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.Locality != nil {
		{
			size, err := m.Locality.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.ColumnName != nil {
		{
			size, err := m.ColumnName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.UserPrivileges != nil {
		{
			size, err := m.UserPrivileges.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.Owner != nil {
		{
			size, err := m.Owner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Namespace != nil {
		{
			size, err := m.Namespace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.Partitioning != nil {
		{
			size, err := m.Partitioning.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.Database != nil {
		{
			size, err := m.Database.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.Schema != nil {
		{
			size, err := m.Schema.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.RelationDependedOnBy != nil {
		{
			size, err := m.RelationDependedOnBy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.InForeignKey != nil {
		{
			size, err := m.InForeignKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.OutForeignKey != nil {
		{
			size, err := m.OutForeignKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Table != nil {
		{
			size, err := m.Table.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.View != nil {
		{
			size, err := m.View.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.DefaultExpression != nil {
		{
			size, err := m.DefaultExpression.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Sequence != nil {
		{
			size, err := m.Sequence.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.CheckConstraint != nil {
		{
			size, err := m.CheckConstraint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.UniqueConstraint != nil {
		{
			size, err := m.UniqueConstraint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.SequenceDependency != nil {
		{
			size, err := m.SequenceDependency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SecondaryIndex != nil {
		{
			size, err := m.SecondaryIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PrimaryIndex != nil {
		{
			size, err := m.PrimaryIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Column != nil {
		{
			size, err := m.Column.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Column) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Virtual {
		i--
		if m.Virtual {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.SystemColumnKind != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SystemColumnKind))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.PgAttributeNum != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.PgAttributeNum))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.ComputerExpr) > 0 {
		i -= len(m.ComputerExpr)
		copy(dAtA[i:], m.ComputerExpr)
		i = encodeVarintElements(dAtA, i, uint64(len(m.ComputerExpr)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.UsesSequenceIDs) > 0 {
		dAtA42 := make([]byte, len(m.UsesSequenceIDs)*10)
		var j41 int
		for _, num := range m.UsesSequenceIDs {
			for num >= 1<<7 {
				dAtA42[j41] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j41++
			}
			dAtA42[j41] = uint8(num)
			j41++
		}
		i -= j41
		copy(dAtA[i:], dAtA42[:j41])
		i = encodeVarintElements(dAtA, i, uint64(j41))
		i--
		dAtA[i] = 0x72
	}
	if len(m.GeneratedAsIdentitySequenceOption) > 0 {
		i -= len(m.GeneratedAsIdentitySequenceOption)
		copy(dAtA[i:], m.GeneratedAsIdentitySequenceOption)
		i = encodeVarintElements(dAtA, i, uint64(len(m.GeneratedAsIdentitySequenceOption)))
		i--
		dAtA[i] = 0x6a
	}
	if m.GeneratedAsIdentityType != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.GeneratedAsIdentityType))
		i--
		dAtA[i] = 0x60
	}
	if m.Inaccessible {
		i--
		if m.Inaccessible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.Hidden {
		i--
		if m.Hidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.OnUpdateExpr) > 0 {
		i -= len(m.OnUpdateExpr)
		copy(dAtA[i:], m.OnUpdateExpr)
		i = encodeVarintElements(dAtA, i, uint64(len(m.OnUpdateExpr)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DefaultExpr) > 0 {
		i -= len(m.DefaultExpr)
		copy(dAtA[i:], m.DefaultExpr)
		i = encodeVarintElements(dAtA, i, uint64(len(m.DefaultExpr)))
		i--
		dAtA[i] = 0x42
	}
	if m.Nullable {
		i--
		if m.Nullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.FamilyName) > 0 {
		i -= len(m.FamilyName)
		copy(dAtA[i:], m.FamilyName)
		i = encodeVarintElements(dAtA, i, uint64(len(m.FamilyName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.FamilyID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FamilyID))
		i--
		dAtA[i] = 0x20
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x18
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrimaryIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimaryIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrimaryIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SourceIndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SourceIndexID))
		i--
		dAtA[i] = 0x60
	}
	if m.Concurrently {
		i--
		if m.Concurrently {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.Inverted {
		i--
		if m.Inverted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.CompositeColumnIDs) > 0 {
		dAtA45 := make([]byte, len(m.CompositeColumnIDs)*10)
		var j44 int
		for _, num := range m.CompositeColumnIDs {
			for num >= 1<<7 {
				dAtA45[j44] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j44++
			}
			dAtA45[j44] = uint8(num)
			j44++
		}
		i -= j44
		copy(dAtA[i:], dAtA45[:j44])
		i = encodeVarintElements(dAtA, i, uint64(j44))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.StoringColumnIDs) > 0 {
		dAtA47 := make([]byte, len(m.StoringColumnIDs)*10)
		var j46 int
		for _, num := range m.StoringColumnIDs {
			for num >= 1<<7 {
				dAtA47[j46] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j46++
			}
			dAtA47[j46] = uint8(num)
			j46++
		}
		i -= j46
		copy(dAtA[i:], dAtA47[:j46])
		i = encodeVarintElements(dAtA, i, uint64(j46))
		i--
		dAtA[i] = 0x42
	}
	if m.ShardedDescriptor != nil {
		{
			size, err := m.ShardedDescriptor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.KeySuffixColumnIDs) > 0 {
		dAtA50 := make([]byte, len(m.KeySuffixColumnIDs)*10)
		var j49 int
		for _, num := range m.KeySuffixColumnIDs {
			for num >= 1<<7 {
				dAtA50[j49] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j49++
			}
			dAtA50[j49] = uint8(num)
			j49++
		}
		i -= j49
		copy(dAtA[i:], dAtA50[:j49])
		i = encodeVarintElements(dAtA, i, uint64(j49))
		i--
		dAtA[i] = 0x32
	}
	if len(m.KeyColumnDirections) > 0 {
		dAtA52 := make([]byte, len(m.KeyColumnDirections)*10)
		var j51 int
		for _, num := range m.KeyColumnDirections {
			for num >= 1<<7 {
				dAtA52[j51] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j51++
			}
			dAtA52[j51] = uint8(num)
			j51++
		}
		i -= j51
		copy(dAtA[i:], dAtA52[:j51])
		i = encodeVarintElements(dAtA, i, uint64(j51))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.KeyColumnIDs) > 0 {
		dAtA54 := make([]byte, len(m.KeyColumnIDs)*10)
		var j53 int
		for _, num := range m.KeyColumnIDs {
			for num >= 1<<7 {
				dAtA54[j53] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j53++
			}
			dAtA54[j53] = uint8(num)
			j53++
		}
		i -= j53
		copy(dAtA[i:], dAtA54[:j53])
		i = encodeVarintElements(dAtA, i, uint64(j53))
		i--
		dAtA[i] = 0x22
	}
	if m.Unique {
		i--
		if m.Unique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SecondaryIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecondaryIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecondaryIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SourceIndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SourceIndexID))
		i--
		dAtA[i] = 0x60
	}
	if m.Concurrently {
		i--
		if m.Concurrently {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.Inverted {
		i--
		if m.Inverted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.CompositeColumnIDs) > 0 {
		dAtA56 := make([]byte, len(m.CompositeColumnIDs)*10)
		var j55 int
		for _, num := range m.CompositeColumnIDs {
			for num >= 1<<7 {
				dAtA56[j55] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j55++
			}
			dAtA56[j55] = uint8(num)
			j55++
		}
		i -= j55
		copy(dAtA[i:], dAtA56[:j55])
		i = encodeVarintElements(dAtA, i, uint64(j55))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.StoringColumnIDs) > 0 {
		dAtA58 := make([]byte, len(m.StoringColumnIDs)*10)
		var j57 int
		for _, num := range m.StoringColumnIDs {
			for num >= 1<<7 {
				dAtA58[j57] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j57++
			}
			dAtA58[j57] = uint8(num)
			j57++
		}
		i -= j57
		copy(dAtA[i:], dAtA58[:j57])
		i = encodeVarintElements(dAtA, i, uint64(j57))
		i--
		dAtA[i] = 0x42
	}
	if m.ShardedDescriptor != nil {
		{
			size, err := m.ShardedDescriptor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.KeySuffixColumnIDs) > 0 {
		dAtA61 := make([]byte, len(m.KeySuffixColumnIDs)*10)
		var j60 int
		for _, num := range m.KeySuffixColumnIDs {
			for num >= 1<<7 {
				dAtA61[j60] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j60++
			}
			dAtA61[j60] = uint8(num)
			j60++
		}
		i -= j60
		copy(dAtA[i:], dAtA61[:j60])
		i = encodeVarintElements(dAtA, i, uint64(j60))
		i--
		dAtA[i] = 0x32
	}
	if len(m.KeyColumnDirections) > 0 {
		dAtA63 := make([]byte, len(m.KeyColumnDirections)*10)
		var j62 int
		for _, num := range m.KeyColumnDirections {
			for num >= 1<<7 {
				dAtA63[j62] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j62++
			}
			dAtA63[j62] = uint8(num)
			j62++
		}
		i -= j62
		copy(dAtA[i:], dAtA63[:j62])
		i = encodeVarintElements(dAtA, i, uint64(j62))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.KeyColumnIDs) > 0 {
		dAtA65 := make([]byte, len(m.KeyColumnIDs)*10)
		var j64 int
		for _, num := range m.KeyColumnIDs {
			for num >= 1<<7 {
				dAtA65[j64] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j64++
			}
			dAtA65[j64] = uint8(num)
			j64++
		}
		i -= j64
		copy(dAtA[i:], dAtA65[:j64])
		i = encodeVarintElements(dAtA, i, uint64(j64))
		i--
		dAtA[i] = 0x22
	}
	if m.Unique {
		i--
		if m.Unique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SequenceDependency) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SequenceDependency) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SequenceDependency) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.SequenceID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SequenceID))
		i--
		dAtA[i] = 0x18
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UniqueConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UniqueConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UniqueConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ColumnIDs) > 0 {
		dAtA67 := make([]byte, len(m.ColumnIDs)*10)
		var j66 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA67[j66] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j66++
			}
			dAtA67[j66] = uint8(num)
			j66++
		}
		i -= j66
		copy(dAtA[i:], dAtA67[:j66])
		i = encodeVarintElements(dAtA, i, uint64(j66))
		i--
		dAtA[i] = 0x2a
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x20
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x18
	}
	if m.ConstraintOrdinal != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintOrdinal))
		i--
		dAtA[i] = 0x10
	}
	if m.ConstraintType != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CheckConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Validated {
		i--
		if m.Validated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.ColumnIDs) > 0 {
		dAtA69 := make([]byte, len(m.ColumnIDs)*10)
		var j68 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA69[j68] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j68++
			}
			dAtA69[j68] = uint8(num)
			j68++
		}
		i -= j68
		copy(dAtA[i:], dAtA69[:j68])
		i = encodeVarintElements(dAtA, i, uint64(j68))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Expr) > 0 {
		i -= len(m.Expr)
		copy(dAtA[i:], m.Expr)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Expr)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x18
	}
	if m.ConstraintOrdinal != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintOrdinal))
		i--
		dAtA[i] = 0x10
	}
	if m.ConstraintType != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Sequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SequenceID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SequenceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DefaultExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DefaultExpr) > 0 {
		i -= len(m.DefaultExpr)
		copy(dAtA[i:], m.DefaultExpr)
		i = encodeVarintElements(dAtA, i, uint64(len(m.DefaultExpr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.UsesSequenceIDs) > 0 {
		dAtA71 := make([]byte, len(m.UsesSequenceIDs)*10)
		var j70 int
		for _, num := range m.UsesSequenceIDs {
			for num >= 1<<7 {
				dAtA71[j70] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j70++
			}
			dAtA71[j70] = uint8(num)
			j70++
		}
		i -= j70
		copy(dAtA[i:], dAtA71[:j70])
		i = encodeVarintElements(dAtA, i, uint64(j70))
		i--
		dAtA[i] = 0x1a
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *View) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *View) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *View) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Table) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Table) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Table) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OnUpdateExprTypeReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnUpdateExprTypeReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OnUpdateExprTypeReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x18
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ComputedExprTypeReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComputedExprTypeReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComputedExprTypeReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x18
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DefaultExprTypeReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultExprTypeReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultExprTypeReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x18
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnTypeReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnTypeReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnTypeReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x18
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CheckConstraintTypeReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckConstraintTypeReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckConstraintTypeReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x18
	}
	if m.ConstraintOrdinal != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintOrdinal))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ViewDependsOnType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewDependsOnType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewDependsOnType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x18
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ForeignKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForeignKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForeignKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x42
	}
	if m.OnDelete != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.OnDelete))
		i--
		dAtA[i] = 0x38
	}
	if m.OnUpdate != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.OnUpdate))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ReferenceColumns) > 0 {
		dAtA73 := make([]byte, len(m.ReferenceColumns)*10)
		var j72 int
		for _, num := range m.ReferenceColumns {
			for num >= 1<<7 {
				dAtA73[j72] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j72++
			}
			dAtA73[j72] = uint8(num)
			j72++
		}
		i -= j72
		copy(dAtA[i:], dAtA73[:j72])
		i = encodeVarintElements(dAtA, i, uint64(j72))
		i--
		dAtA[i] = 0x2a
	}
	if m.ReferenceID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ReferenceID))
		i--
		dAtA[i] = 0x20
	}
	if len(m.OriginColumns) > 0 {
		dAtA75 := make([]byte, len(m.OriginColumns)*10)
		var j74 int
		for _, num := range m.OriginColumns {
			for num >= 1<<7 {
				dAtA75[j74] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j74++
			}
			dAtA75[j74] = uint8(num)
			j74++
		}
		i -= j74
		copy(dAtA[i:], dAtA75[:j74])
		i = encodeVarintElements(dAtA, i, uint64(j74))
		i--
		dAtA[i] = 0x1a
	}
	if m.OriginID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.OriginID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ForeignKeyBackReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForeignKeyBackReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForeignKeyBackReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x42
	}
	if m.OnDelete != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.OnDelete))
		i--
		dAtA[i] = 0x38
	}
	if m.OnUpdate != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.OnUpdate))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ReferenceColumns) > 0 {
		dAtA77 := make([]byte, len(m.ReferenceColumns)*10)
		var j76 int
		for _, num := range m.ReferenceColumns {
			for num >= 1<<7 {
				dAtA77[j76] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j76++
			}
			dAtA77[j76] = uint8(num)
			j76++
		}
		i -= j76
		copy(dAtA[i:], dAtA77[:j76])
		i = encodeVarintElements(dAtA, i, uint64(j76))
		i--
		dAtA[i] = 0x2a
	}
	if m.ReferenceID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ReferenceID))
		i--
		dAtA[i] = 0x20
	}
	if len(m.OriginColumns) > 0 {
		dAtA79 := make([]byte, len(m.OriginColumns)*10)
		var j78 int
		for _, num := range m.OriginColumns {
			for num >= 1<<7 {
				dAtA79[j78] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j78++
			}
			dAtA79[j78] = uint8(num)
			j78++
		}
		i -= j78
		copy(dAtA[i:], dAtA79[:j78])
		i = encodeVarintElements(dAtA, i, uint64(j78))
		i--
		dAtA[i] = 0x1a
	}
	if m.OriginID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.OriginID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SequenceOwnedBy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SequenceOwnedBy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SequenceOwnedBy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OwnerTableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.OwnerTableID))
		i--
		dAtA[i] = 0x10
	}
	if m.SequenceID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SequenceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RelationDependedOnBy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelationDependedOnBy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RelationDependedOnBy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x18
	}
	if m.DependedOnBy != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DependedOnBy))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Type) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Type) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Schema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Schema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DependentObjects) > 0 {
		dAtA81 := make([]byte, len(m.DependentObjects)*10)
		var j80 int
		for _, num := range m.DependentObjects {
			for num >= 1<<7 {
				dAtA81[j80] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j80++
			}
			dAtA81[j80] = uint8(num)
			j80++
		}
		i -= j80
		copy(dAtA[i:], dAtA81[:j80])
		i = encodeVarintElements(dAtA, i, uint64(j80))
		i--
		dAtA[i] = 0x1a
	}
	if m.SchemaID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SchemaID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Database) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Database) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Database) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DependentObjects) > 0 {
		dAtA83 := make([]byte, len(m.DependentObjects)*10)
		var j82 int
		for _, num := range m.DependentObjects {
			for num >= 1<<7 {
				dAtA83[j82] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j82++
			}
			dAtA83[j82] = uint8(num)
			j82++
		}
		i -= j82
		copy(dAtA[i:], dAtA83[:j82])
		i = encodeVarintElements(dAtA, i, uint64(j82))
		i--
		dAtA[i] = 0x1a
	}
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexPartitioning) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexPartitioning) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexPartitioning) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Partitioning != nil {
		{
			size, err := m.Partitioning.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Namespace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Namespace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Namespace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.DescriptorID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DescriptorID))
		i--
		dAtA[i] = 0x18
	}
	if m.SchemaID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SchemaID))
		i--
		dAtA[i] = 0x10
	}
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Owner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Owner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Owner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if m.DescriptorID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DescriptorID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserPrivileges) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPrivileges) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserPrivileges) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Privileges != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.Privileges))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x12
	}
	if m.DescriptorID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DescriptorID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Locality) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Locality) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Locality) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Locality != nil {
		{
			size, err := m.Locality.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DescriptorID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DescriptorID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RowLevelTTL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowLevelTTL) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowLevelTTL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RowLevelTTL != nil {
		{
			size, err := m.RowLevelTTL.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConstraintName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConstraintName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConstraintName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.ConstraintOrdinal != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintOrdinal))
		i--
		dAtA[i] = 0x18
	}
	if m.ConstraintType != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintType))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DefaultPrivilege) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultPrivilege) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultPrivilege) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrivilegesPerObject) > 0 {
		keysForPrivilegesPerObject := make([]uint32, 0, len(m.PrivilegesPerObject))
		for k := range m.PrivilegesPerObject {
			keysForPrivilegesPerObject = append(keysForPrivilegesPerObject, uint32(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint32s(keysForPrivilegesPerObject)
		for iNdEx := len(keysForPrivilegesPerObject) - 1; iNdEx >= 0; iNdEx-- {
			v := m.PrivilegesPerObject[uint32(keysForPrivilegesPerObject[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintElements(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintElements(dAtA, i, uint64(keysForPrivilegesPerObject[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintElements(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Role != nil {
		{
			size := m.Role.Size()
			i -= size
			if _, err := m.Role.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DescriptorID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DescriptorID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DefaultPrivilege_ExplicitRole) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultPrivilege_ExplicitRole) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExplicitRole != nil {
		{
			size, err := m.ExplicitRole.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DefaultPrivilege_ForAllRoles) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultPrivilege_ForAllRoles) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ForAllRoles != nil {
		{
			size, err := m.ForAllRoles.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DefaultPrivilege_DefaultObjectPrivilege) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultPrivilege_DefaultObjectPrivilege) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultPrivilege_DefaultObjectPrivilege) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Privileges) > 0 {
		for iNdEx := len(m.Privileges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Privileges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintElements(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseSchemaEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseSchemaEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseSchemaEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SchemaID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SchemaID))
		i--
		dAtA[i] = 0x10
	}
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x12
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SchemaComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x12
	}
	if m.SchemaID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SchemaID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConstraintComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConstraintComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConstraintComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseRoleSetting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseRoleSetting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseRoleSetting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RoleName) > 0 {
		i -= len(m.RoleName)
		copy(dAtA[i:], m.RoleName)
		i = encodeVarintElements(dAtA, i, uint64(len(m.RoleName)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintElements(dAtA []byte, offset int, v uint64) int {
	offset -= sovElements(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ElementProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Column != nil {
		l = m.Column.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.PrimaryIndex != nil {
		l = m.PrimaryIndex.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.SecondaryIndex != nil {
		l = m.SecondaryIndex.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.SequenceDependency != nil {
		l = m.SequenceDependency.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.UniqueConstraint != nil {
		l = m.UniqueConstraint.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.CheckConstraint != nil {
		l = m.CheckConstraint.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.Sequence != nil {
		l = m.Sequence.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.DefaultExpression != nil {
		l = m.DefaultExpression.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.View != nil {
		l = m.View.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.Table != nil {
		l = m.Table.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.OutForeignKey != nil {
		l = m.OutForeignKey.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.InForeignKey != nil {
		l = m.InForeignKey.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.RelationDependedOnBy != nil {
		l = m.RelationDependedOnBy.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.Schema != nil {
		l = m.Schema.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.Database != nil {
		l = m.Database.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.Partitioning != nil {
		l = m.Partitioning.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.Namespace != nil {
		l = m.Namespace.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.Owner != nil {
		l = m.Owner.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.UserPrivileges != nil {
		l = m.UserPrivileges.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.ColumnName != nil {
		l = m.ColumnName.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.Locality != nil {
		l = m.Locality.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.IndexName != nil {
		l = m.IndexName.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.ConstraintName != nil {
		l = m.ConstraintName.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.DefaultExprTypeRef != nil {
		l = m.DefaultExprTypeRef.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.OnUpdateTypeReference != nil {
		l = m.OnUpdateTypeReference.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.ComputedExprTypeReference != nil {
		l = m.ComputedExprTypeReference.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.ViewDependsOnType != nil {
		l = m.ViewDependsOnType.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.ColumnTypeReference != nil {
		l = m.ColumnTypeReference.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.SchemaEntry != nil {
		l = m.SchemaEntry.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.CheckConstraintTypeReference != nil {
		l = m.CheckConstraintTypeReference.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.TableComment != nil {
		l = m.TableComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.DatabaseComment != nil {
		l = m.DatabaseComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.SchemaComment != nil {
		l = m.SchemaComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.IndexComment != nil {
		l = m.IndexComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.ColumnComment != nil {
		l = m.ColumnComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.ConstraintComment != nil {
		l = m.ConstraintComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.DatabaseRoleSetting != nil {
		l = m.DatabaseRoleSetting.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.RowLevelTTL != nil {
		l = m.RowLevelTTL.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.SequenceOwner != nil {
		l = m.SequenceOwner.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}

func (m *Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	if m.FamilyID != 0 {
		n += 1 + sovElements(uint64(m.FamilyID))
	}
	l = len(m.FamilyName)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.Nullable {
		n += 2
	}
	l = len(m.DefaultExpr)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	l = len(m.OnUpdateExpr)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	if m.Hidden {
		n += 2
	}
	if m.Inaccessible {
		n += 2
	}
	if m.GeneratedAsIdentityType != 0 {
		n += 1 + sovElements(uint64(m.GeneratedAsIdentityType))
	}
	l = len(m.GeneratedAsIdentitySequenceOption)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	if len(m.UsesSequenceIDs) > 0 {
		l = 0
		for _, e := range m.UsesSequenceIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	l = len(m.ComputerExpr)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	if m.PgAttributeNum != 0 {
		n += 2 + sovElements(uint64(m.PgAttributeNum))
	}
	if m.SystemColumnKind != 0 {
		n += 2 + sovElements(uint64(m.SystemColumnKind))
	}
	if m.Virtual {
		n += 3
	}
	return n
}

func (m *PrimaryIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	if m.Unique {
		n += 2
	}
	if len(m.KeyColumnIDs) > 0 {
		l = 0
		for _, e := range m.KeyColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.KeyColumnDirections) > 0 {
		l = 0
		for _, e := range m.KeyColumnDirections {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.KeySuffixColumnIDs) > 0 {
		l = 0
		for _, e := range m.KeySuffixColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.ShardedDescriptor != nil {
		l = m.ShardedDescriptor.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if len(m.StoringColumnIDs) > 0 {
		l = 0
		for _, e := range m.StoringColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.CompositeColumnIDs) > 0 {
		l = 0
		for _, e := range m.CompositeColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.Inverted {
		n += 2
	}
	if m.Concurrently {
		n += 2
	}
	if m.SourceIndexID != 0 {
		n += 1 + sovElements(uint64(m.SourceIndexID))
	}
	return n
}

func (m *SecondaryIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	if m.Unique {
		n += 2
	}
	if len(m.KeyColumnIDs) > 0 {
		l = 0
		for _, e := range m.KeyColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.KeyColumnDirections) > 0 {
		l = 0
		for _, e := range m.KeyColumnDirections {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.KeySuffixColumnIDs) > 0 {
		l = 0
		for _, e := range m.KeySuffixColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.ShardedDescriptor != nil {
		l = m.ShardedDescriptor.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if len(m.StoringColumnIDs) > 0 {
		l = 0
		for _, e := range m.StoringColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.CompositeColumnIDs) > 0 {
		l = 0
		for _, e := range m.CompositeColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.Inverted {
		n += 2
	}
	if m.Concurrently {
		n += 2
	}
	if m.SourceIndexID != 0 {
		n += 1 + sovElements(uint64(m.SourceIndexID))
	}
	return n
}

func (m *SequenceDependency) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	if m.SequenceID != 0 {
		n += 1 + sovElements(uint64(m.SequenceID))
	}
	if m.Type != 0 {
		n += 1 + sovElements(uint64(m.Type))
	}
	return n
}

func (m *UniqueConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConstraintType != 0 {
		n += 1 + sovElements(uint64(m.ConstraintType))
	}
	if m.ConstraintOrdinal != 0 {
		n += 1 + sovElements(uint64(m.ConstraintOrdinal))
	}
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	return n
}

func (m *CheckConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConstraintType != 0 {
		n += 1 + sovElements(uint64(m.ConstraintType))
	}
	if m.ConstraintOrdinal != 0 {
		n += 1 + sovElements(uint64(m.ConstraintOrdinal))
	}
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	l = len(m.Expr)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.Validated {
		n += 2
	}
	return n
}

func (m *Sequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SequenceID != 0 {
		n += 1 + sovElements(uint64(m.SequenceID))
	}
	return n
}

func (m *DefaultExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	if len(m.UsesSequenceIDs) > 0 {
		l = 0
		for _, e := range m.UsesSequenceIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	l = len(m.DefaultExpr)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *View) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	return n
}

func (m *Table) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	return n
}

func (m *OnUpdateExprTypeReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	if m.TypeID != 0 {
		n += 1 + sovElements(uint64(m.TypeID))
	}
	return n
}

func (m *ComputedExprTypeReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	if m.TypeID != 0 {
		n += 1 + sovElements(uint64(m.TypeID))
	}
	return n
}

func (m *DefaultExprTypeReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	if m.TypeID != 0 {
		n += 1 + sovElements(uint64(m.TypeID))
	}
	return n
}

func (m *ColumnTypeReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	if m.TypeID != 0 {
		n += 1 + sovElements(uint64(m.TypeID))
	}
	return n
}

func (m *CheckConstraintTypeReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintOrdinal != 0 {
		n += 1 + sovElements(uint64(m.ConstraintOrdinal))
	}
	if m.TypeID != 0 {
		n += 1 + sovElements(uint64(m.TypeID))
	}
	return n
}

func (m *ViewDependsOnType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.TypeID != 0 {
		n += 1 + sovElements(uint64(m.TypeID))
	}
	return n
}

func (m *ForeignKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OriginID != 0 {
		n += 1 + sovElements(uint64(m.OriginID))
	}
	if len(m.OriginColumns) > 0 {
		l = 0
		for _, e := range m.OriginColumns {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.ReferenceID != 0 {
		n += 1 + sovElements(uint64(m.ReferenceID))
	}
	if len(m.ReferenceColumns) > 0 {
		l = 0
		for _, e := range m.ReferenceColumns {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.OnUpdate != 0 {
		n += 1 + sovElements(uint64(m.OnUpdate))
	}
	if m.OnDelete != 0 {
		n += 1 + sovElements(uint64(m.OnDelete))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *ForeignKeyBackReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OriginID != 0 {
		n += 1 + sovElements(uint64(m.OriginID))
	}
	if len(m.OriginColumns) > 0 {
		l = 0
		for _, e := range m.OriginColumns {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.ReferenceID != 0 {
		n += 1 + sovElements(uint64(m.ReferenceID))
	}
	if len(m.ReferenceColumns) > 0 {
		l = 0
		for _, e := range m.ReferenceColumns {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.OnUpdate != 0 {
		n += 1 + sovElements(uint64(m.OnUpdate))
	}
	if m.OnDelete != 0 {
		n += 1 + sovElements(uint64(m.OnDelete))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *SequenceOwnedBy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SequenceID != 0 {
		n += 1 + sovElements(uint64(m.SequenceID))
	}
	if m.OwnerTableID != 0 {
		n += 1 + sovElements(uint64(m.OwnerTableID))
	}
	return n
}

func (m *RelationDependedOnBy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.DependedOnBy != 0 {
		n += 1 + sovElements(uint64(m.DependedOnBy))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	return n
}

func (m *Type) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeID != 0 {
		n += 1 + sovElements(uint64(m.TypeID))
	}
	return n
}

func (m *Schema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaID != 0 {
		n += 1 + sovElements(uint64(m.SchemaID))
	}
	if len(m.DependentObjects) > 0 {
		l = 0
		for _, e := range m.DependentObjects {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	return n
}

func (m *Database) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	if len(m.DependentObjects) > 0 {
		l = 0
		for _, e := range m.DependentObjects {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	return n
}

func (m *IndexPartitioning) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	if m.Partitioning != nil {
		l = m.Partitioning.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *Namespace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	if m.SchemaID != 0 {
		n += 1 + sovElements(uint64(m.SchemaID))
	}
	if m.DescriptorID != 0 {
		n += 1 + sovElements(uint64(m.DescriptorID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *Owner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DescriptorID != 0 {
		n += 1 + sovElements(uint64(m.DescriptorID))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *UserPrivileges) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DescriptorID != 0 {
		n += 1 + sovElements(uint64(m.DescriptorID))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	if m.Privileges != 0 {
		n += 1 + sovElements(uint64(m.Privileges))
	}
	return n
}

func (m *Locality) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DescriptorID != 0 {
		n += 1 + sovElements(uint64(m.DescriptorID))
	}
	if m.Locality != nil {
		l = m.Locality.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *RowLevelTTL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.RowLevelTTL != nil {
		l = m.RowLevelTTL.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *ColumnName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *IndexName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *ConstraintName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintType != 0 {
		n += 1 + sovElements(uint64(m.ConstraintType))
	}
	if m.ConstraintOrdinal != 0 {
		n += 1 + sovElements(uint64(m.ConstraintOrdinal))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *DefaultPrivilege) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DescriptorID != 0 {
		n += 1 + sovElements(uint64(m.DescriptorID))
	}
	if m.Role != nil {
		n += m.Role.Size()
	}
	if len(m.PrivilegesPerObject) > 0 {
		for k, v := range m.PrivilegesPerObject {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovElements(uint64(l))
			}
			mapEntrySize := 1 + sovElements(uint64(k)) + l
			n += mapEntrySize + 1 + sovElements(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DefaultPrivilege_ExplicitRole) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExplicitRole != nil {
		l = m.ExplicitRole.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}
func (m *DefaultPrivilege_ForAllRoles) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForAllRoles != nil {
		l = m.ForAllRoles.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}
func (m *DefaultPrivilege_DefaultObjectPrivilege) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Privileges) > 0 {
		for _, e := range m.Privileges {
			l = e.Size()
			n += 1 + l + sovElements(uint64(l))
		}
	}
	return n
}

func (m *DatabaseSchemaEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	if m.SchemaID != 0 {
		n += 1 + sovElements(uint64(m.SchemaID))
	}
	return n
}

func (m *TableComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *DatabaseComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *SchemaComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaID != 0 {
		n += 1 + sovElements(uint64(m.SchemaID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *IndexComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *ColumnComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *ConstraintComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *DatabaseRoleSetting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	l = len(m.RoleName)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func sovElements(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozElements(x uint64) (n int) {
	return sovElements(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ElementProto) GetValue() interface{} {
	if this.Column != nil {
		return this.Column
	}
	if this.PrimaryIndex != nil {
		return this.PrimaryIndex
	}
	if this.SecondaryIndex != nil {
		return this.SecondaryIndex
	}
	if this.SequenceDependency != nil {
		return this.SequenceDependency
	}
	if this.UniqueConstraint != nil {
		return this.UniqueConstraint
	}
	if this.CheckConstraint != nil {
		return this.CheckConstraint
	}
	if this.Sequence != nil {
		return this.Sequence
	}
	if this.DefaultExpression != nil {
		return this.DefaultExpression
	}
	if this.View != nil {
		return this.View
	}
	if this.Table != nil {
		return this.Table
	}
	if this.OutForeignKey != nil {
		return this.OutForeignKey
	}
	if this.InForeignKey != nil {
		return this.InForeignKey
	}
	if this.RelationDependedOnBy != nil {
		return this.RelationDependedOnBy
	}
	if this.Type != nil {
		return this.Type
	}
	if this.Schema != nil {
		return this.Schema
	}
	if this.Database != nil {
		return this.Database
	}
	if this.Partitioning != nil {
		return this.Partitioning
	}
	if this.Namespace != nil {
		return this.Namespace
	}
	if this.Owner != nil {
		return this.Owner
	}
	if this.UserPrivileges != nil {
		return this.UserPrivileges
	}
	if this.ColumnName != nil {
		return this.ColumnName
	}
	if this.Locality != nil {
		return this.Locality
	}
	if this.IndexName != nil {
		return this.IndexName
	}
	if this.ConstraintName != nil {
		return this.ConstraintName
	}
	if this.DefaultExprTypeRef != nil {
		return this.DefaultExprTypeRef
	}
	if this.OnUpdateTypeReference != nil {
		return this.OnUpdateTypeReference
	}
	if this.ComputedExprTypeReference != nil {
		return this.ComputedExprTypeReference
	}
	if this.ViewDependsOnType != nil {
		return this.ViewDependsOnType
	}
	if this.ColumnTypeReference != nil {
		return this.ColumnTypeReference
	}
	if this.SchemaEntry != nil {
		return this.SchemaEntry
	}
	if this.CheckConstraintTypeReference != nil {
		return this.CheckConstraintTypeReference
	}
	if this.TableComment != nil {
		return this.TableComment
	}
	if this.DatabaseComment != nil {
		return this.DatabaseComment
	}
	if this.SchemaComment != nil {
		return this.SchemaComment
	}
	if this.IndexComment != nil {
		return this.IndexComment
	}
	if this.ColumnComment != nil {
		return this.ColumnComment
	}
	if this.ConstraintComment != nil {
		return this.ConstraintComment
	}
	if this.DatabaseRoleSetting != nil {
		return this.DatabaseRoleSetting
	}
	if this.RowLevelTTL != nil {
		return this.RowLevelTTL
	}
	if this.SequenceOwner != nil {
		return this.SequenceOwner
	}
	return nil
}

func (this *ElementProto) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *Column:
		this.Column = vt
	case *PrimaryIndex:
		this.PrimaryIndex = vt
	case *SecondaryIndex:
		this.SecondaryIndex = vt
	case *SequenceDependency:
		this.SequenceDependency = vt
	case *UniqueConstraint:
		this.UniqueConstraint = vt
	case *CheckConstraint:
		this.CheckConstraint = vt
	case *Sequence:
		this.Sequence = vt
	case *DefaultExpression:
		this.DefaultExpression = vt
	case *View:
		this.View = vt
	case *Table:
		this.Table = vt
	case *ForeignKey:
		this.OutForeignKey = vt
	case *ForeignKeyBackReference:
		this.InForeignKey = vt
	case *RelationDependedOnBy:
		this.RelationDependedOnBy = vt
	case *Type:
		this.Type = vt
	case *Schema:
		this.Schema = vt
	case *Database:
		this.Database = vt
	case *IndexPartitioning:
		this.Partitioning = vt
	case *Namespace:
		this.Namespace = vt
	case *Owner:
		this.Owner = vt
	case *UserPrivileges:
		this.UserPrivileges = vt
	case *ColumnName:
		this.ColumnName = vt
	case *Locality:
		this.Locality = vt
	case *IndexName:
		this.IndexName = vt
	case *ConstraintName:
		this.ConstraintName = vt
	case *DefaultExprTypeReference:
		this.DefaultExprTypeRef = vt
	case *OnUpdateExprTypeReference:
		this.OnUpdateTypeReference = vt
	case *ComputedExprTypeReference:
		this.ComputedExprTypeReference = vt
	case *ViewDependsOnType:
		this.ViewDependsOnType = vt
	case *ColumnTypeReference:
		this.ColumnTypeReference = vt
	case *DatabaseSchemaEntry:
		this.SchemaEntry = vt
	case *CheckConstraintTypeReference:
		this.CheckConstraintTypeReference = vt
	case *TableComment:
		this.TableComment = vt
	case *DatabaseComment:
		this.DatabaseComment = vt
	case *SchemaComment:
		this.SchemaComment = vt
	case *IndexComment:
		this.IndexComment = vt
	case *ColumnComment:
		this.ColumnComment = vt
	case *ConstraintComment:
		this.ConstraintComment = vt
	case *DatabaseRoleSetting:
		this.DatabaseRoleSetting = vt
	case *RowLevelTTL:
		this.RowLevelTTL = vt
	case *SequenceOwnedBy:
		this.SequenceOwner = vt
	default:
		return false
	}
	return true
}
func (m *ElementProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ElementProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ElementProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Column == nil {
				m.Column = &Column{}
			}
			if err := m.Column.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrimaryIndex == nil {
				m.PrimaryIndex = &PrimaryIndex{}
			}
			if err := m.PrimaryIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecondaryIndex == nil {
				m.SecondaryIndex = &SecondaryIndex{}
			}
			if err := m.SecondaryIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceDependency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SequenceDependency == nil {
				m.SequenceDependency = &SequenceDependency{}
			}
			if err := m.SequenceDependency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueConstraint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UniqueConstraint == nil {
				m.UniqueConstraint = &UniqueConstraint{}
			}
			if err := m.UniqueConstraint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckConstraint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CheckConstraint == nil {
				m.CheckConstraint = &CheckConstraint{}
			}
			if err := m.CheckConstraint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sequence == nil {
				m.Sequence = &Sequence{}
			}
			if err := m.Sequence.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultExpression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultExpression == nil {
				m.DefaultExpression = &DefaultExpression{}
			}
			if err := m.DefaultExpression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.View == nil {
				m.View = &View{}
			}
			if err := m.View.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Table == nil {
				m.Table = &Table{}
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutForeignKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutForeignKey == nil {
				m.OutForeignKey = &ForeignKey{}
			}
			if err := m.OutForeignKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InForeignKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InForeignKey == nil {
				m.InForeignKey = &ForeignKeyBackReference{}
			}
			if err := m.InForeignKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelationDependedOnBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RelationDependedOnBy == nil {
				m.RelationDependedOnBy = &RelationDependedOnBy{}
			}
			if err := m.RelationDependedOnBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &Type{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schema == nil {
				m.Schema = &Schema{}
			}
			if err := m.Schema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Database == nil {
				m.Database = &Database{}
			}
			if err := m.Database.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitioning", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Partitioning == nil {
				m.Partitioning = &IndexPartitioning{}
			}
			if err := m.Partitioning.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Namespace == nil {
				m.Namespace = &Namespace{}
			}
			if err := m.Namespace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Owner == nil {
				m.Owner = &Owner{}
			}
			if err := m.Owner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPrivileges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserPrivileges == nil {
				m.UserPrivileges = &UserPrivileges{}
			}
			if err := m.UserPrivileges.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColumnName == nil {
				m.ColumnName = &ColumnName{}
			}
			if err := m.ColumnName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Locality == nil {
				m.Locality = &Locality{}
			}
			if err := m.Locality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexName == nil {
				m.IndexName = &IndexName{}
			}
			if err := m.IndexName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConstraintName == nil {
				m.ConstraintName = &ConstraintName{}
			}
			if err := m.ConstraintName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultExprTypeRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultExprTypeRef == nil {
				m.DefaultExprTypeRef = &DefaultExprTypeReference{}
			}
			if err := m.DefaultExprTypeRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnUpdateTypeReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OnUpdateTypeReference == nil {
				m.OnUpdateTypeReference = &OnUpdateExprTypeReference{}
			}
			if err := m.OnUpdateTypeReference.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputedExprTypeReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ComputedExprTypeReference == nil {
				m.ComputedExprTypeReference = &ComputedExprTypeReference{}
			}
			if err := m.ComputedExprTypeReference.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewDependsOnType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ViewDependsOnType == nil {
				m.ViewDependsOnType = &ViewDependsOnType{}
			}
			if err := m.ViewDependsOnType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnTypeReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColumnTypeReference == nil {
				m.ColumnTypeReference = &ColumnTypeReference{}
			}
			if err := m.ColumnTypeReference.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SchemaEntry == nil {
				m.SchemaEntry = &DatabaseSchemaEntry{}
			}
			if err := m.SchemaEntry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckConstraintTypeReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CheckConstraintTypeReference == nil {
				m.CheckConstraintTypeReference = &CheckConstraintTypeReference{}
			}
			if err := m.CheckConstraintTypeReference.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableComment == nil {
				m.TableComment = &TableComment{}
			}
			if err := m.TableComment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatabaseComment == nil {
				m.DatabaseComment = &DatabaseComment{}
			}
			if err := m.DatabaseComment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SchemaComment == nil {
				m.SchemaComment = &SchemaComment{}
			}
			if err := m.SchemaComment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexComment == nil {
				m.IndexComment = &IndexComment{}
			}
			if err := m.IndexComment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColumnComment == nil {
				m.ColumnComment = &ColumnComment{}
			}
			if err := m.ColumnComment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConstraintComment == nil {
				m.ConstraintComment = &ConstraintComment{}
			}
			if err := m.ConstraintComment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseRoleSetting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatabaseRoleSetting == nil {
				m.DatabaseRoleSetting = &DatabaseRoleSetting{}
			}
			if err := m.DatabaseRoleSetting.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowLevelTTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RowLevelTTL == nil {
				m.RowLevelTTL = &RowLevelTTL{}
			}
			if err := m.RowLevelTTL.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceOwner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SequenceOwner == nil {
				m.SequenceOwner = &SequenceOwnedBy{}
			}
			if err := m.SequenceOwner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FamilyID", wireType)
			}
			m.FamilyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FamilyID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.FamilyID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FamilyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FamilyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &types.T{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nullable = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultExpr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultExpr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnUpdateExpr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnUpdateExpr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hidden = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inaccessible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inaccessible = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedAsIdentityType", wireType)
			}
			m.GeneratedAsIdentityType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GeneratedAsIdentityType |= github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.GeneratedAsIdentityType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedAsIdentitySequenceOption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeneratedAsIdentitySequenceOption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesSequenceIDs = append(m.UsesSequenceIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UsesSequenceIDs) == 0 {
					m.UsesSequenceIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesSequenceIDs = append(m.UsesSequenceIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesSequenceIDs", wireType)
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputerExpr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ComputerExpr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgAttributeNum", wireType)
			}
			m.PgAttributeNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PgAttributeNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemColumnKind", wireType)
			}
			m.SystemColumnKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SystemColumnKind |= github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.SystemColumnKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Virtual", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Virtual = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimaryIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimaryIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimaryIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unique = bool(v != 0)
		case 4:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KeyColumnIDs = append(m.KeyColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.KeyColumnIDs) == 0 {
					m.KeyColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KeyColumnIDs = append(m.KeyColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyColumnIDs", wireType)
			}
		case 5:
			if wireType == 0 {
				var v PrimaryIndex_Direction
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= PrimaryIndex_Direction(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KeyColumnDirections = append(m.KeyColumnDirections, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.KeyColumnDirections) == 0 {
					m.KeyColumnDirections = make([]PrimaryIndex_Direction, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v PrimaryIndex_Direction
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= PrimaryIndex_Direction(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KeyColumnDirections = append(m.KeyColumnDirections, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyColumnDirections", wireType)
			}
		case 6:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KeySuffixColumnIDs = append(m.KeySuffixColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.KeySuffixColumnIDs) == 0 {
					m.KeySuffixColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KeySuffixColumnIDs = append(m.KeySuffixColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeySuffixColumnIDs", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardedDescriptor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardedDescriptor == nil {
				m.ShardedDescriptor = &catpb.ShardedDescriptor{}
			}
			if err := m.ShardedDescriptor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StoringColumnIDs = append(m.StoringColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.StoringColumnIDs) == 0 {
					m.StoringColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StoringColumnIDs = append(m.StoringColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StoringColumnIDs", wireType)
			}
		case 9:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CompositeColumnIDs = append(m.CompositeColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CompositeColumnIDs) == 0 {
					m.CompositeColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CompositeColumnIDs = append(m.CompositeColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeColumnIDs", wireType)
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inverted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inverted = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Concurrently", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Concurrently = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIndexID", wireType)
			}
			m.SourceIndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceIndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecondaryIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecondaryIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecondaryIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unique = bool(v != 0)
		case 4:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KeyColumnIDs = append(m.KeyColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.KeyColumnIDs) == 0 {
					m.KeyColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KeyColumnIDs = append(m.KeyColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyColumnIDs", wireType)
			}
		case 5:
			if wireType == 0 {
				var v SecondaryIndex_Direction
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= SecondaryIndex_Direction(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KeyColumnDirections = append(m.KeyColumnDirections, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.KeyColumnDirections) == 0 {
					m.KeyColumnDirections = make([]SecondaryIndex_Direction, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v SecondaryIndex_Direction
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= SecondaryIndex_Direction(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KeyColumnDirections = append(m.KeyColumnDirections, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyColumnDirections", wireType)
			}
		case 6:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KeySuffixColumnIDs = append(m.KeySuffixColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.KeySuffixColumnIDs) == 0 {
					m.KeySuffixColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KeySuffixColumnIDs = append(m.KeySuffixColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeySuffixColumnIDs", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardedDescriptor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardedDescriptor == nil {
				m.ShardedDescriptor = &catpb.ShardedDescriptor{}
			}
			if err := m.ShardedDescriptor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StoringColumnIDs = append(m.StoringColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.StoringColumnIDs) == 0 {
					m.StoringColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StoringColumnIDs = append(m.StoringColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StoringColumnIDs", wireType)
			}
		case 9:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CompositeColumnIDs = append(m.CompositeColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CompositeColumnIDs) == 0 {
					m.CompositeColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CompositeColumnIDs = append(m.CompositeColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeColumnIDs", wireType)
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inverted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Inverted = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Concurrently", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Concurrently = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIndexID", wireType)
			}
			m.SourceIndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceIndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SequenceDependency) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequenceDependency: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequenceDependency: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceID", wireType)
			}
			m.SequenceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= SequenceDependency_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UniqueConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UniqueConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UniqueConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintType", wireType)
			}
			m.ConstraintType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintType |= ConstraintType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintOrdinal", wireType)
			}
			m.ConstraintOrdinal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintOrdinal |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintType", wireType)
			}
			m.ConstraintType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintType |= ConstraintType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintOrdinal", wireType)
			}
			m.ConstraintOrdinal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintOrdinal |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Validated = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceID", wireType)
			}
			m.SequenceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefaultExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesSequenceIDs = append(m.UsesSequenceIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UsesSequenceIDs) == 0 {
					m.UsesSequenceIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesSequenceIDs = append(m.UsesSequenceIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesSequenceIDs", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultExpr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultExpr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *View) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: View: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: View: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Table) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Table: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Table: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnUpdateExprTypeReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnUpdateExprTypeReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnUpdateExprTypeReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComputedExprTypeReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComputedExprTypeReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComputedExprTypeReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefaultExprTypeReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultExprTypeReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultExprTypeReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnTypeReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnTypeReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnTypeReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckConstraintTypeReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckConstraintTypeReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckConstraintTypeReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintOrdinal", wireType)
			}
			m.ConstraintOrdinal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintOrdinal |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewDependsOnType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewDependsOnType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewDependsOnType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForeignKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForeignKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForeignKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginID", wireType)
			}
			m.OriginID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OriginColumns = append(m.OriginColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OriginColumns) == 0 {
					m.OriginColumns = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OriginColumns = append(m.OriginColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginColumns", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceID", wireType)
			}
			m.ReferenceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReferenceID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ReferenceColumns = append(m.ReferenceColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ReferenceColumns) == 0 {
					m.ReferenceColumns = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ReferenceColumns = append(m.ReferenceColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceColumns", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnUpdate", wireType)
			}
			m.OnUpdate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnUpdate |= github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.ForeignKeyAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDelete", wireType)
			}
			m.OnDelete = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnDelete |= github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.ForeignKeyAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForeignKeyBackReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForeignKeyBackReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForeignKeyBackReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginID", wireType)
			}
			m.OriginID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OriginColumns = append(m.OriginColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OriginColumns) == 0 {
					m.OriginColumns = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OriginColumns = append(m.OriginColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginColumns", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceID", wireType)
			}
			m.ReferenceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReferenceID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ReferenceColumns = append(m.ReferenceColumns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ReferenceColumns) == 0 {
					m.ReferenceColumns = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ReferenceColumns = append(m.ReferenceColumns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceColumns", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnUpdate", wireType)
			}
			m.OnUpdate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnUpdate |= github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.ForeignKeyAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDelete", wireType)
			}
			m.OnDelete = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnDelete |= github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.ForeignKeyAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SequenceOwnedBy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequenceOwnedBy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequenceOwnedBy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceID", wireType)
			}
			m.SequenceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerTableID", wireType)
			}
			m.OwnerTableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerTableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelationDependedOnBy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelationDependedOnBy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelationDependedOnBy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DependedOnBy", wireType)
			}
			m.DependedOnBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DependedOnBy |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Schema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Schema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaID", wireType)
			}
			m.SchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DependentObjects = append(m.DependentObjects, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DependentObjects) == 0 {
					m.DependentObjects = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DependentObjects = append(m.DependentObjects, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DependentObjects", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Database) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Database: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Database: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DependentObjects = append(m.DependentObjects, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DependentObjects) == 0 {
					m.DependentObjects = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DependentObjects = append(m.DependentObjects, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DependentObjects", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexPartitioning) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexPartitioning: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexPartitioning: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitioning", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Partitioning == nil {
				m.Partitioning = &github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.PartitioningDescriptor{}
			}
			if err := m.Partitioning.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Namespace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Namespace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Namespace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaID", wireType)
			}
			m.SchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorID", wireType)
			}
			m.DescriptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Owner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Owner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Owner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorID", wireType)
			}
			m.DescriptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPrivileges) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPrivileges: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPrivileges: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorID", wireType)
			}
			m.DescriptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileges", wireType)
			}
			m.Privileges = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Privileges |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Locality) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Locality: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Locality: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorID", wireType)
			}
			m.DescriptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Locality == nil {
				m.Locality = &github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.LocalityConfig{}
			}
			if err := m.Locality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowLevelTTL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowLevelTTL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowLevelTTL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowLevelTTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RowLevelTTL == nil {
				m.RowLevelTTL = &catpb.RowLevelTTL{}
			}
			if err := m.RowLevelTTL.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConstraintName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConstraintName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConstraintName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintType", wireType)
			}
			m.ConstraintType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintType |= ConstraintType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintOrdinal", wireType)
			}
			m.ConstraintOrdinal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintOrdinal |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefaultPrivilege) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultPrivilege: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultPrivilege: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorID", wireType)
			}
			m.DescriptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExplicitRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &catpb.DefaultPrivilegesForRole_ExplicitRole{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Role = &DefaultPrivilege_ExplicitRole{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForAllRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &catpb.DefaultPrivilegesForRole_ForAllRolesPseudoRole{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Role = &DefaultPrivilege_ForAllRoles{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivilegesPerObject", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrivilegesPerObject == nil {
				m.PrivilegesPerObject = make(map[uint32]*DefaultPrivilege_DefaultObjectPrivilege)
			}
			var mapkey uint32
			var mapvalue *DefaultPrivilege_DefaultObjectPrivilege
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthElements
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthElements
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DefaultPrivilege_DefaultObjectPrivilege{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipElements(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthElements
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PrivilegesPerObject[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefaultPrivilege_DefaultObjectPrivilege) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultObjectPrivilege: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultObjectPrivilege: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Privileges = append(m.Privileges, &UserPrivileges{})
			if err := m.Privileges[len(m.Privileges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseSchemaEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseSchemaEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseSchemaEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaID", wireType)
			}
			m.SchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaID", wireType)
			}
			m.SchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConstraintComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConstraintComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConstraintComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseRoleSetting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseRoleSetting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseRoleSetting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipElements(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowElements
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowElements
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowElements
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthElements
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupElements
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthElements
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthElements        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowElements          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupElements = fmt.Errorf("proto: unexpected end of group")
)
