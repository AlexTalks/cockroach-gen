// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/schemachanger/scpb/elements.proto

package scpb

import (
	bytes "bytes"
	encoding_binary "encoding/binary"
	fmt "fmt"
	geopb "github.com/cockroachdb/cockroach/pkg/geo/geopb"
	catenumpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/catenumpb"
	catpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb"
	github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb"
	github_com_cockroachdb_cockroach_pkg_sql_sem_catid "github.com/cockroachdb/cockroach/pkg/sql/sem/catid"
	semenumpb "github.com/cockroachdb/cockroach/pkg/sql/sem/semenumpb"
	types "github.com/cockroachdb/cockroach/pkg/sql/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type IndexColumn_Kind int32

const (
	IndexColumn_KEY        IndexColumn_Kind = 0
	IndexColumn_KEY_SUFFIX IndexColumn_Kind = 1
	IndexColumn_STORED     IndexColumn_Kind = 2
)

var IndexColumn_Kind_name = map[int32]string{
	0: "KEY",
	1: "KEY_SUFFIX",
	2: "STORED",
}

var IndexColumn_Kind_value = map[string]int32{
	"KEY":        0,
	"KEY_SUFFIX": 1,
	"STORED":     2,
}

func (x IndexColumn_Kind) String() string {
	return proto.EnumName(IndexColumn_Kind_name, int32(x))
}

func (IndexColumn_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{52, 0}
}

// ElementProto is the union type of all _elements_, which are the foundation
// of how we model schema changes in the declarative schema changer.
//
// A core design principle is that each element owns its back-references, that
// is to say, it is responsible for updating any back-references in the
// descriptors that it references as part of its lifecycle, i.e. going from
// ABSENT to PUBLIC or vice-versa. As a corollary, back-references are not
// modelled as elements at all, they exist purely as a side-effect. In an ideal
// world, they would be modelled as elements just like everything else, however
// we currently don't have 1:1 relationships between forward and back-references
// in all cases: we do for foreign keys for example, but we don't for type
// references (back-references are modelled as a set in the type descriptor).
//
// Regardless, this principle does have the inherent virtue of keeping the
// element model relatively simple, if at the expense of pushing the complexity
// down to the execution layer in scmutationexec. This trade-off is acceptable
// though: the back-reference update code is quite self-contained and the
// added complexity consists in making these operations work on a best-effort
// basis, i.e. with not many assumptions about whether something is dropped or
// not, etc.
//
// A less strong principle is that each element should remain immutable
// throughout its lifecycle. In practice we sometimes deviate from this for
// elements which have only just had targets defined for them and thus haven't
// yet undergone any status changes. In any case, that kind of hackery is best
// kept at a minimum.
type ElementProto struct {
	// Types that are valid to be assigned to ElementOneOf:
	//	*ElementProto_Database
	//	*ElementProto_Schema
	//	*ElementProto_View
	//	*ElementProto_Sequence
	//	*ElementProto_Table
	//	*ElementProto_EnumType
	//	*ElementProto_AliasType
	//	*ElementProto_CompositeType
	//	*ElementProto_Function
	//	*ElementProto_ColumnFamily
	//	*ElementProto_Column
	//	*ElementProto_PrimaryIndex
	//	*ElementProto_SecondaryIndex
	//	*ElementProto_TemporaryIndex
	//	*ElementProto_UniqueWithoutIndexConstraint
	//	*ElementProto_UniqueWithoutIndexConstraintUnvalidated
	//	*ElementProto_CheckConstraint
	//	*ElementProto_CheckConstraintUnvalidated
	//	*ElementProto_ForeignKeyConstraint
	//	*ElementProto_ForeignKeyConstraintUnvalidated
	//	*ElementProto_TableComment
	//	*ElementProto_RowLevelTTL
	//	*ElementProto_TableZoneConfig
	//	*ElementProto_IndexZoneConfig
	//	*ElementProto_TableData
	//	*ElementProto_TablePartitioning
	//	*ElementProto_TableSchemaLocked
	//	*ElementProto_TableLocalityGlobal
	//	*ElementProto_TableLocalityPrimaryRegion
	//	*ElementProto_TableLocalitySecondaryRegion
	//	*ElementProto_TableLocalityRegionalByRow
	//	*ElementProto_ColumnName
	//	*ElementProto_ColumnType
	//	*ElementProto_ColumnDefaultExpression
	//	*ElementProto_ColumnOnUpdateExpression
	//	*ElementProto_SequenceOwner
	//	*ElementProto_ColumnComment
	//	*ElementProto_ColumnNotNull
	//	*ElementProto_SequenceOption
	//	*ElementProto_IndexName
	//	*ElementProto_IndexPartitioning
	//	*ElementProto_SecondaryIndexPartial
	//	*ElementProto_IndexComment
	//	*ElementProto_IndexColumn
	//	*ElementProto_IndexData
	//	*ElementProto_ConstraintWithoutIndexName
	//	*ElementProto_ConstraintComment
	//	*ElementProto_Namespace
	//	*ElementProto_Owner
	//	*ElementProto_UserPrivileges
	//	*ElementProto_DatabaseRegionConfig
	//	*ElementProto_DatabaseRoleSetting
	//	*ElementProto_DatabaseComment
	//	*ElementProto_DatabaseData
	//	*ElementProto_SchemaParent
	//	*ElementProto_SchemaComment
	//	*ElementProto_SchemaChild
	//	*ElementProto_EnumTypeValue
	//	*ElementProto_CompositeTypeAttrType
	//	*ElementProto_CompositeTypeAttrName
	//	*ElementProto_FunctionName
	//	*ElementProto_FunctionVolatility
	//	*ElementProto_FunctionLeakProof
	//	*ElementProto_FunctionNullInputBehavior
	//	*ElementProto_FunctionBody
	ElementOneOf isElementProto_ElementOneOf `protobuf_oneof:"element_one_of"`
}

func (m *ElementProto) Reset()         { *m = ElementProto{} }
func (m *ElementProto) String() string { return proto.CompactTextString(m) }
func (*ElementProto) ProtoMessage()    {}
func (*ElementProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{0}
}
func (m *ElementProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ElementProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ElementProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ElementProto.Merge(m, src)
}
func (m *ElementProto) XXX_Size() int {
	return m.Size()
}
func (m *ElementProto) XXX_DiscardUnknown() {
	xxx_messageInfo_ElementProto.DiscardUnknown(m)
}

var xxx_messageInfo_ElementProto proto.InternalMessageInfo

type isElementProto_ElementOneOf interface {
	isElementProto_ElementOneOf()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ElementProto_Database struct {
	Database *Database `protobuf:"bytes,1,opt,name=database,proto3,oneof" json:"database,omitempty"`
}
type ElementProto_Schema struct {
	Schema *Schema `protobuf:"bytes,2,opt,name=schema,proto3,oneof" json:"schema,omitempty"`
}
type ElementProto_View struct {
	View *View `protobuf:"bytes,3,opt,name=view,proto3,oneof" json:"view,omitempty"`
}
type ElementProto_Sequence struct {
	Sequence *Sequence `protobuf:"bytes,4,opt,name=sequence,proto3,oneof" json:"sequence,omitempty"`
}
type ElementProto_Table struct {
	Table *Table `protobuf:"bytes,5,opt,name=table,proto3,oneof" json:"table,omitempty"`
}
type ElementProto_EnumType struct {
	EnumType *EnumType `protobuf:"bytes,6,opt,name=enum_type,json=enumType,proto3,oneof" json:"enum_type,omitempty"`
}
type ElementProto_AliasType struct {
	AliasType *AliasType `protobuf:"bytes,7,opt,name=alias_type,json=aliasType,proto3,oneof" json:"alias_type,omitempty"`
}
type ElementProto_CompositeType struct {
	CompositeType *CompositeType `protobuf:"bytes,8,opt,name=composite_type,json=compositeType,proto3,oneof" json:"composite_type,omitempty"`
}
type ElementProto_Function struct {
	Function *Function `protobuf:"bytes,9,opt,name=function,proto3,oneof" json:"function,omitempty"`
}
type ElementProto_ColumnFamily struct {
	ColumnFamily *ColumnFamily `protobuf:"bytes,20,opt,name=column_family,json=columnFamily,proto3,oneof" json:"column_family,omitempty" parent:"Table"`
}
type ElementProto_Column struct {
	Column *Column `protobuf:"bytes,21,opt,name=column,proto3,oneof" json:"column,omitempty" parent:"Table, View"`
}
type ElementProto_PrimaryIndex struct {
	PrimaryIndex *PrimaryIndex `protobuf:"bytes,22,opt,name=primary_index,json=primaryIndex,proto3,oneof" json:"primary_index,omitempty" parent:"Table, View"`
}
type ElementProto_SecondaryIndex struct {
	SecondaryIndex *SecondaryIndex `protobuf:"bytes,23,opt,name=secondary_index,json=secondaryIndex,proto3,oneof" json:"secondary_index,omitempty" parent:"Table, View"`
}
type ElementProto_TemporaryIndex struct {
	TemporaryIndex *TemporaryIndex `protobuf:"bytes,24,opt,name=temporary_index,json=temporaryIndex,proto3,oneof" json:"temporary_index,omitempty" parent:"Table, View"`
}
type ElementProto_UniqueWithoutIndexConstraint struct {
	UniqueWithoutIndexConstraint *UniqueWithoutIndexConstraint `protobuf:"bytes,25,opt,name=unique_without_index_constraint,json=uniqueWithoutIndexConstraint,proto3,oneof" json:"unique_without_index_constraint,omitempty" parent:"Table"`
}
type ElementProto_UniqueWithoutIndexConstraintUnvalidated struct {
	UniqueWithoutIndexConstraintUnvalidated *UniqueWithoutIndexConstraintUnvalidated `protobuf:"bytes,171,opt,name=unique_without_index_constraint_unvalidated,json=uniqueWithoutIndexConstraintUnvalidated,proto3,oneof" json:"unique_without_index_constraint_unvalidated,omitempty" parent:"Table"`
}
type ElementProto_CheckConstraint struct {
	CheckConstraint *CheckConstraint `protobuf:"bytes,26,opt,name=check_constraint,json=checkConstraint,proto3,oneof" json:"check_constraint,omitempty" parent:"Table"`
}
type ElementProto_CheckConstraintUnvalidated struct {
	CheckConstraintUnvalidated *CheckConstraintUnvalidated `protobuf:"bytes,170,opt,name=check_constraint_unvalidated,json=checkConstraintUnvalidated,proto3,oneof" json:"check_constraint_unvalidated,omitempty" parent:"Table"`
}
type ElementProto_ForeignKeyConstraint struct {
	ForeignKeyConstraint *ForeignKeyConstraint `protobuf:"bytes,27,opt,name=foreign_key_constraint,json=foreignKeyConstraint,proto3,oneof" json:"foreign_key_constraint,omitempty" parent:"Table"`
}
type ElementProto_ForeignKeyConstraintUnvalidated struct {
	ForeignKeyConstraintUnvalidated *ForeignKeyConstraintUnvalidated `protobuf:"bytes,172,opt,name=foreign_key_constraint_unvalidated,json=foreignKeyConstraintUnvalidated,proto3,oneof" json:"foreign_key_constraint_unvalidated,omitempty" parent:"Table"`
}
type ElementProto_TableComment struct {
	TableComment *TableComment `protobuf:"bytes,28,opt,name=table_comment,json=tableComment,proto3,oneof" json:"table_comment,omitempty" parent:"Table, View, Sequence"`
}
type ElementProto_RowLevelTTL struct {
	RowLevelTTL *RowLevelTTL `protobuf:"bytes,29,opt,name=row_level_ttl,json=rowLevelTtl,proto3,oneof" json:"row_level_ttl,omitempty" parent:"Table"`
}
type ElementProto_TableZoneConfig struct {
	TableZoneConfig *TableZoneConfig `protobuf:"bytes,121,opt,name=table_zone_config,json=tableZoneConfig,proto3,oneof" json:"table_zone_config,omitempty" parent:"Table, View"`
}
type ElementProto_IndexZoneConfig struct {
	IndexZoneConfig *IndexZoneConfig `protobuf:"bytes,122,opt,name=index_zone_config,json=indexZoneConfig,proto3,oneof" json:"index_zone_config,omitempty" parent:"Index"`
}
type ElementProto_TableData struct {
	TableData *TableData `protobuf:"bytes,131,opt,name=table_data,json=tableData,proto3,oneof" json:"table_data,omitempty" parent:"Table, View, Sequence"`
}
type ElementProto_TablePartitioning struct {
	TablePartitioning *TablePartitioning `protobuf:"bytes,132,opt,name=table_partitioning,json=tablePartitioning,proto3,oneof" json:"table_partitioning,omitempty" parent:"Table"`
}
type ElementProto_TableSchemaLocked struct {
	TableSchemaLocked *TableSchemaLocked `protobuf:"bytes,133,opt,name=table_schema_locked,json=tableSchemaLocked,proto3,oneof" json:"table_schema_locked,omitempty" parent:"Table"`
}
type ElementProto_TableLocalityGlobal struct {
	TableLocalityGlobal *TableLocalityGlobal `protobuf:"bytes,110,opt,name=table_locality_global,json=tableLocalityGlobal,proto3,oneof" json:"table_locality_global,omitempty" parent:"Table"`
}
type ElementProto_TableLocalityPrimaryRegion struct {
	TableLocalityPrimaryRegion *TableLocalityPrimaryRegion `protobuf:"bytes,111,opt,name=table_locality_primary_region,json=tableLocalityPrimaryRegion,proto3,oneof" json:"table_locality_primary_region,omitempty" parent:"Table"`
}
type ElementProto_TableLocalitySecondaryRegion struct {
	TableLocalitySecondaryRegion *TableLocalitySecondaryRegion `protobuf:"bytes,112,opt,name=table_locality_secondary_region,json=tableLocalitySecondaryRegion,proto3,oneof" json:"table_locality_secondary_region,omitempty" parent:"Table"`
}
type ElementProto_TableLocalityRegionalByRow struct {
	TableLocalityRegionalByRow *TableLocalityRegionalByRow `protobuf:"bytes,113,opt,name=table_locality_regional_by_row,json=tableLocalityRegionalByRow,proto3,oneof" json:"table_locality_regional_by_row,omitempty" parent:"Table"`
}
type ElementProto_ColumnName struct {
	ColumnName *ColumnName `protobuf:"bytes,30,opt,name=column_name,json=columnName,proto3,oneof" json:"column_name,omitempty" parent:"Column"`
}
type ElementProto_ColumnType struct {
	ColumnType *ColumnType `protobuf:"bytes,31,opt,name=column_type,json=columnType,proto3,oneof" json:"column_type,omitempty" parent:"Column"`
}
type ElementProto_ColumnDefaultExpression struct {
	ColumnDefaultExpression *ColumnDefaultExpression `protobuf:"bytes,32,opt,name=column_default_expression,json=columnDefaultExpression,proto3,oneof" json:"column_default_expression,omitempty" parent:"Column"`
}
type ElementProto_ColumnOnUpdateExpression struct {
	ColumnOnUpdateExpression *ColumnOnUpdateExpression `protobuf:"bytes,33,opt,name=column_on_update_expression,json=columnOnUpdateExpression,proto3,oneof" json:"column_on_update_expression,omitempty" parent:"Column"`
}
type ElementProto_SequenceOwner struct {
	SequenceOwner *SequenceOwner `protobuf:"bytes,34,opt,name=sequence_owner,json=sequenceOwner,proto3,oneof" json:"sequence_owner,omitempty" parent:"Column"`
}
type ElementProto_ColumnComment struct {
	ColumnComment *ColumnComment `protobuf:"bytes,35,opt,name=column_comment,json=columnComment,proto3,oneof" json:"column_comment,omitempty" parent:"Column"`
}
type ElementProto_ColumnNotNull struct {
	ColumnNotNull *ColumnNotNull `protobuf:"bytes,36,opt,name=column_not_null,json=columnNotNull,proto3,oneof" json:"column_not_null,omitempty" parent:"Column"`
}
type ElementProto_SequenceOption struct {
	SequenceOption *SequenceOption `protobuf:"bytes,37,opt,name=sequence_option,json=sequenceOption,proto3,oneof" json:"sequence_option,omitempty" parent:"Sequence"`
}
type ElementProto_IndexName struct {
	IndexName *IndexName `protobuf:"bytes,40,opt,name=index_name,json=indexName,proto3,oneof" json:"index_name,omitempty" parent:"PrimaryIndex, SecondaryIndex"`
}
type ElementProto_IndexPartitioning struct {
	IndexPartitioning *IndexPartitioning `protobuf:"bytes,41,opt,name=index_partitioning,json=indexPartitioning,proto3,oneof" json:"index_partitioning,omitempty" parent:"PrimaryIndex, SecondaryIndex"`
}
type ElementProto_SecondaryIndexPartial struct {
	SecondaryIndexPartial *SecondaryIndexPartial `protobuf:"bytes,42,opt,name=secondary_index_partial,json=secondaryIndexPartial,proto3,oneof" json:"secondary_index_partial,omitempty" parent:"SecondaryIndex"`
}
type ElementProto_IndexComment struct {
	IndexComment *IndexComment `protobuf:"bytes,43,opt,name=index_comment,json=indexComment,proto3,oneof" json:"index_comment,omitempty" parent:"PrimaryIndex, SecondaryIndex"`
}
type ElementProto_IndexColumn struct {
	IndexColumn *IndexColumn `protobuf:"bytes,44,opt,name=index_column,json=indexColumn,proto3,oneof" json:"index_column,omitempty" parent:"PrimaryIndex, SecondaryIndex, TemporaryIndex, Column"`
}
type ElementProto_IndexData struct {
	IndexData *IndexData `protobuf:"bytes,45,opt,name=index_data,json=indexData,proto3,oneof" json:"index_data,omitempty" parent:"PrimaryIndex, SecondaryIndex, TemporaryIndex"`
}
type ElementProto_ConstraintWithoutIndexName struct {
	ConstraintWithoutIndexName *ConstraintWithoutIndexName `protobuf:"bytes,51,opt,name=constraint_without_index_name,json=constraintWithoutIndexName,proto3,oneof" json:"constraint_without_index_name,omitempty" parent:"UniqueWithoutIndexConstraint, CheckConstraint, ForeignKeyConstraint"`
}
type ElementProto_ConstraintComment struct {
	ConstraintComment *ConstraintComment `protobuf:"bytes,52,opt,name=constraint_comment,json=constraintComment,proto3,oneof" json:"constraint_comment,omitempty" parent:"PrimaryIndex, SecondaryIndex, UniqueWithoutIndexConstraint, CheckConstraint, ForeignKeyConstraint"`
}
type ElementProto_Namespace struct {
	Namespace *Namespace `protobuf:"bytes,60,opt,name=namespace,proto3,oneof" json:"namespace,omitempty" parent:"Table, View, Sequence, Database, Schema, AliasType, EnumType"`
}
type ElementProto_Owner struct {
	Owner *Owner `protobuf:"bytes,61,opt,name=owner,proto3,oneof" json:"owner,omitempty" parent:"Table, View, Sequence, Database, Schema, AliasType, EnumType"`
}
type ElementProto_UserPrivileges struct {
	UserPrivileges *UserPrivileges `protobuf:"bytes,62,opt,name=user_privileges,json=userPrivileges,proto3,oneof" json:"user_privileges,omitempty" parent:"Table, View, Sequence, Database, Schema, AliasType, EnumType"`
}
type ElementProto_DatabaseRegionConfig struct {
	DatabaseRegionConfig *DatabaseRegionConfig `protobuf:"bytes,80,opt,name=database_region_config,json=databaseRegionConfig,proto3,oneof" json:"database_region_config,omitempty" parent:"Database"`
}
type ElementProto_DatabaseRoleSetting struct {
	DatabaseRoleSetting *DatabaseRoleSetting `protobuf:"bytes,81,opt,name=database_role_setting,json=databaseRoleSetting,proto3,oneof" json:"database_role_setting,omitempty" parent:"Database"`
}
type ElementProto_DatabaseComment struct {
	DatabaseComment *DatabaseComment `protobuf:"bytes,82,opt,name=database_comment,json=databaseComment,proto3,oneof" json:"database_comment,omitempty" parent:"Database"`
}
type ElementProto_DatabaseData struct {
	DatabaseData *DatabaseData `protobuf:"bytes,83,opt,name=database_data,json=databaseData,proto3,oneof" json:"database_data,omitempty" parent:"Database"`
}
type ElementProto_SchemaParent struct {
	SchemaParent *SchemaParent `protobuf:"bytes,90,opt,name=schema_parent,json=schemaParent,proto3,oneof" json:"schema_parent,omitempty" parent:"Schema"`
}
type ElementProto_SchemaComment struct {
	SchemaComment *SchemaComment `protobuf:"bytes,91,opt,name=schema_comment,json=schemaComment,proto3,oneof" json:"schema_comment,omitempty" parent:"Schema"`
}
type ElementProto_SchemaChild struct {
	SchemaChild *SchemaChild `protobuf:"bytes,100,opt,name=schema_child,json=schemaChild,proto3,oneof" json:"schema_child,omitempty" parent:"AliasType, EnumType, Table, View, Sequence"`
}
type ElementProto_EnumTypeValue struct {
	EnumTypeValue *EnumTypeValue `protobuf:"bytes,120,opt,name=enum_type_value,json=enumTypeValue,proto3,oneof" json:"enum_type_value,omitempty" parent:"EnumType"`
}
type ElementProto_CompositeTypeAttrType struct {
	CompositeTypeAttrType *CompositeTypeAttrType `protobuf:"bytes,140,opt,name=composite_type_attr_type,json=compositeTypeAttrType,proto3,oneof" json:"composite_type_attr_type,omitempty" parent:"CompositeType"`
}
type ElementProto_CompositeTypeAttrName struct {
	CompositeTypeAttrName *CompositeTypeAttrName `protobuf:"bytes,141,opt,name=composite_type_attr_name,json=compositeTypeAttrName,proto3,oneof" json:"composite_type_attr_name,omitempty" parent:"CompositeType"`
}
type ElementProto_FunctionName struct {
	FunctionName *FunctionName `protobuf:"bytes,160,opt,name=function_name,json=functionName,proto3,oneof" json:"function_name,omitempty" parent:"Function"`
}
type ElementProto_FunctionVolatility struct {
	FunctionVolatility *FunctionVolatility `protobuf:"bytes,161,opt,name=function_volatility,json=functionVolatility,proto3,oneof" json:"function_volatility,omitempty" parent:"Function"`
}
type ElementProto_FunctionLeakProof struct {
	FunctionLeakProof *FunctionLeakProof `protobuf:"bytes,162,opt,name=function_leak_proof,json=functionLeakProof,proto3,oneof" json:"function_leak_proof,omitempty" parent:"Function"`
}
type ElementProto_FunctionNullInputBehavior struct {
	FunctionNullInputBehavior *FunctionNullInputBehavior `protobuf:"bytes,163,opt,name=function_null_input_behavior,json=functionNullInputBehavior,proto3,oneof" json:"function_null_input_behavior,omitempty" parent:"Function"`
}
type ElementProto_FunctionBody struct {
	FunctionBody *FunctionBody `protobuf:"bytes,164,opt,name=function_body,json=functionBody,proto3,oneof" json:"function_body,omitempty" parent:"Function"`
}

func (*ElementProto_Database) isElementProto_ElementOneOf()                                {}
func (*ElementProto_Schema) isElementProto_ElementOneOf()                                  {}
func (*ElementProto_View) isElementProto_ElementOneOf()                                    {}
func (*ElementProto_Sequence) isElementProto_ElementOneOf()                                {}
func (*ElementProto_Table) isElementProto_ElementOneOf()                                   {}
func (*ElementProto_EnumType) isElementProto_ElementOneOf()                                {}
func (*ElementProto_AliasType) isElementProto_ElementOneOf()                               {}
func (*ElementProto_CompositeType) isElementProto_ElementOneOf()                           {}
func (*ElementProto_Function) isElementProto_ElementOneOf()                                {}
func (*ElementProto_ColumnFamily) isElementProto_ElementOneOf()                            {}
func (*ElementProto_Column) isElementProto_ElementOneOf()                                  {}
func (*ElementProto_PrimaryIndex) isElementProto_ElementOneOf()                            {}
func (*ElementProto_SecondaryIndex) isElementProto_ElementOneOf()                          {}
func (*ElementProto_TemporaryIndex) isElementProto_ElementOneOf()                          {}
func (*ElementProto_UniqueWithoutIndexConstraint) isElementProto_ElementOneOf()            {}
func (*ElementProto_UniqueWithoutIndexConstraintUnvalidated) isElementProto_ElementOneOf() {}
func (*ElementProto_CheckConstraint) isElementProto_ElementOneOf()                         {}
func (*ElementProto_CheckConstraintUnvalidated) isElementProto_ElementOneOf()              {}
func (*ElementProto_ForeignKeyConstraint) isElementProto_ElementOneOf()                    {}
func (*ElementProto_ForeignKeyConstraintUnvalidated) isElementProto_ElementOneOf()         {}
func (*ElementProto_TableComment) isElementProto_ElementOneOf()                            {}
func (*ElementProto_RowLevelTTL) isElementProto_ElementOneOf()                             {}
func (*ElementProto_TableZoneConfig) isElementProto_ElementOneOf()                         {}
func (*ElementProto_IndexZoneConfig) isElementProto_ElementOneOf()                         {}
func (*ElementProto_TableData) isElementProto_ElementOneOf()                               {}
func (*ElementProto_TablePartitioning) isElementProto_ElementOneOf()                       {}
func (*ElementProto_TableSchemaLocked) isElementProto_ElementOneOf()                       {}
func (*ElementProto_TableLocalityGlobal) isElementProto_ElementOneOf()                     {}
func (*ElementProto_TableLocalityPrimaryRegion) isElementProto_ElementOneOf()              {}
func (*ElementProto_TableLocalitySecondaryRegion) isElementProto_ElementOneOf()            {}
func (*ElementProto_TableLocalityRegionalByRow) isElementProto_ElementOneOf()              {}
func (*ElementProto_ColumnName) isElementProto_ElementOneOf()                              {}
func (*ElementProto_ColumnType) isElementProto_ElementOneOf()                              {}
func (*ElementProto_ColumnDefaultExpression) isElementProto_ElementOneOf()                 {}
func (*ElementProto_ColumnOnUpdateExpression) isElementProto_ElementOneOf()                {}
func (*ElementProto_SequenceOwner) isElementProto_ElementOneOf()                           {}
func (*ElementProto_ColumnComment) isElementProto_ElementOneOf()                           {}
func (*ElementProto_ColumnNotNull) isElementProto_ElementOneOf()                           {}
func (*ElementProto_SequenceOption) isElementProto_ElementOneOf()                          {}
func (*ElementProto_IndexName) isElementProto_ElementOneOf()                               {}
func (*ElementProto_IndexPartitioning) isElementProto_ElementOneOf()                       {}
func (*ElementProto_SecondaryIndexPartial) isElementProto_ElementOneOf()                   {}
func (*ElementProto_IndexComment) isElementProto_ElementOneOf()                            {}
func (*ElementProto_IndexColumn) isElementProto_ElementOneOf()                             {}
func (*ElementProto_IndexData) isElementProto_ElementOneOf()                               {}
func (*ElementProto_ConstraintWithoutIndexName) isElementProto_ElementOneOf()              {}
func (*ElementProto_ConstraintComment) isElementProto_ElementOneOf()                       {}
func (*ElementProto_Namespace) isElementProto_ElementOneOf()                               {}
func (*ElementProto_Owner) isElementProto_ElementOneOf()                                   {}
func (*ElementProto_UserPrivileges) isElementProto_ElementOneOf()                          {}
func (*ElementProto_DatabaseRegionConfig) isElementProto_ElementOneOf()                    {}
func (*ElementProto_DatabaseRoleSetting) isElementProto_ElementOneOf()                     {}
func (*ElementProto_DatabaseComment) isElementProto_ElementOneOf()                         {}
func (*ElementProto_DatabaseData) isElementProto_ElementOneOf()                            {}
func (*ElementProto_SchemaParent) isElementProto_ElementOneOf()                            {}
func (*ElementProto_SchemaComment) isElementProto_ElementOneOf()                           {}
func (*ElementProto_SchemaChild) isElementProto_ElementOneOf()                             {}
func (*ElementProto_EnumTypeValue) isElementProto_ElementOneOf()                           {}
func (*ElementProto_CompositeTypeAttrType) isElementProto_ElementOneOf()                   {}
func (*ElementProto_CompositeTypeAttrName) isElementProto_ElementOneOf()                   {}
func (*ElementProto_FunctionName) isElementProto_ElementOneOf()                            {}
func (*ElementProto_FunctionVolatility) isElementProto_ElementOneOf()                      {}
func (*ElementProto_FunctionLeakProof) isElementProto_ElementOneOf()                       {}
func (*ElementProto_FunctionNullInputBehavior) isElementProto_ElementOneOf()               {}
func (*ElementProto_FunctionBody) isElementProto_ElementOneOf()                            {}

func (m *ElementProto) GetElementOneOf() isElementProto_ElementOneOf {
	if m != nil {
		return m.ElementOneOf
	}
	return nil
}

func (m *ElementProto) GetDatabase() *Database {
	if x, ok := m.GetElementOneOf().(*ElementProto_Database); ok {
		return x.Database
	}
	return nil
}

func (m *ElementProto) GetSchema() *Schema {
	if x, ok := m.GetElementOneOf().(*ElementProto_Schema); ok {
		return x.Schema
	}
	return nil
}

func (m *ElementProto) GetView() *View {
	if x, ok := m.GetElementOneOf().(*ElementProto_View); ok {
		return x.View
	}
	return nil
}

func (m *ElementProto) GetSequence() *Sequence {
	if x, ok := m.GetElementOneOf().(*ElementProto_Sequence); ok {
		return x.Sequence
	}
	return nil
}

func (m *ElementProto) GetTable() *Table {
	if x, ok := m.GetElementOneOf().(*ElementProto_Table); ok {
		return x.Table
	}
	return nil
}

func (m *ElementProto) GetEnumType() *EnumType {
	if x, ok := m.GetElementOneOf().(*ElementProto_EnumType); ok {
		return x.EnumType
	}
	return nil
}

func (m *ElementProto) GetAliasType() *AliasType {
	if x, ok := m.GetElementOneOf().(*ElementProto_AliasType); ok {
		return x.AliasType
	}
	return nil
}

func (m *ElementProto) GetCompositeType() *CompositeType {
	if x, ok := m.GetElementOneOf().(*ElementProto_CompositeType); ok {
		return x.CompositeType
	}
	return nil
}

func (m *ElementProto) GetFunction() *Function {
	if x, ok := m.GetElementOneOf().(*ElementProto_Function); ok {
		return x.Function
	}
	return nil
}

func (m *ElementProto) GetColumnFamily() *ColumnFamily {
	if x, ok := m.GetElementOneOf().(*ElementProto_ColumnFamily); ok {
		return x.ColumnFamily
	}
	return nil
}

func (m *ElementProto) GetColumn() *Column {
	if x, ok := m.GetElementOneOf().(*ElementProto_Column); ok {
		return x.Column
	}
	return nil
}

func (m *ElementProto) GetPrimaryIndex() *PrimaryIndex {
	if x, ok := m.GetElementOneOf().(*ElementProto_PrimaryIndex); ok {
		return x.PrimaryIndex
	}
	return nil
}

func (m *ElementProto) GetSecondaryIndex() *SecondaryIndex {
	if x, ok := m.GetElementOneOf().(*ElementProto_SecondaryIndex); ok {
		return x.SecondaryIndex
	}
	return nil
}

func (m *ElementProto) GetTemporaryIndex() *TemporaryIndex {
	if x, ok := m.GetElementOneOf().(*ElementProto_TemporaryIndex); ok {
		return x.TemporaryIndex
	}
	return nil
}

func (m *ElementProto) GetUniqueWithoutIndexConstraint() *UniqueWithoutIndexConstraint {
	if x, ok := m.GetElementOneOf().(*ElementProto_UniqueWithoutIndexConstraint); ok {
		return x.UniqueWithoutIndexConstraint
	}
	return nil
}

func (m *ElementProto) GetUniqueWithoutIndexConstraintUnvalidated() *UniqueWithoutIndexConstraintUnvalidated {
	if x, ok := m.GetElementOneOf().(*ElementProto_UniqueWithoutIndexConstraintUnvalidated); ok {
		return x.UniqueWithoutIndexConstraintUnvalidated
	}
	return nil
}

func (m *ElementProto) GetCheckConstraint() *CheckConstraint {
	if x, ok := m.GetElementOneOf().(*ElementProto_CheckConstraint); ok {
		return x.CheckConstraint
	}
	return nil
}

func (m *ElementProto) GetCheckConstraintUnvalidated() *CheckConstraintUnvalidated {
	if x, ok := m.GetElementOneOf().(*ElementProto_CheckConstraintUnvalidated); ok {
		return x.CheckConstraintUnvalidated
	}
	return nil
}

func (m *ElementProto) GetForeignKeyConstraint() *ForeignKeyConstraint {
	if x, ok := m.GetElementOneOf().(*ElementProto_ForeignKeyConstraint); ok {
		return x.ForeignKeyConstraint
	}
	return nil
}

func (m *ElementProto) GetForeignKeyConstraintUnvalidated() *ForeignKeyConstraintUnvalidated {
	if x, ok := m.GetElementOneOf().(*ElementProto_ForeignKeyConstraintUnvalidated); ok {
		return x.ForeignKeyConstraintUnvalidated
	}
	return nil
}

func (m *ElementProto) GetTableComment() *TableComment {
	if x, ok := m.GetElementOneOf().(*ElementProto_TableComment); ok {
		return x.TableComment
	}
	return nil
}

func (m *ElementProto) GetRowLevelTTL() *RowLevelTTL {
	if x, ok := m.GetElementOneOf().(*ElementProto_RowLevelTTL); ok {
		return x.RowLevelTTL
	}
	return nil
}

func (m *ElementProto) GetTableZoneConfig() *TableZoneConfig {
	if x, ok := m.GetElementOneOf().(*ElementProto_TableZoneConfig); ok {
		return x.TableZoneConfig
	}
	return nil
}

func (m *ElementProto) GetIndexZoneConfig() *IndexZoneConfig {
	if x, ok := m.GetElementOneOf().(*ElementProto_IndexZoneConfig); ok {
		return x.IndexZoneConfig
	}
	return nil
}

func (m *ElementProto) GetTableData() *TableData {
	if x, ok := m.GetElementOneOf().(*ElementProto_TableData); ok {
		return x.TableData
	}
	return nil
}

func (m *ElementProto) GetTablePartitioning() *TablePartitioning {
	if x, ok := m.GetElementOneOf().(*ElementProto_TablePartitioning); ok {
		return x.TablePartitioning
	}
	return nil
}

func (m *ElementProto) GetTableSchemaLocked() *TableSchemaLocked {
	if x, ok := m.GetElementOneOf().(*ElementProto_TableSchemaLocked); ok {
		return x.TableSchemaLocked
	}
	return nil
}

func (m *ElementProto) GetTableLocalityGlobal() *TableLocalityGlobal {
	if x, ok := m.GetElementOneOf().(*ElementProto_TableLocalityGlobal); ok {
		return x.TableLocalityGlobal
	}
	return nil
}

func (m *ElementProto) GetTableLocalityPrimaryRegion() *TableLocalityPrimaryRegion {
	if x, ok := m.GetElementOneOf().(*ElementProto_TableLocalityPrimaryRegion); ok {
		return x.TableLocalityPrimaryRegion
	}
	return nil
}

func (m *ElementProto) GetTableLocalitySecondaryRegion() *TableLocalitySecondaryRegion {
	if x, ok := m.GetElementOneOf().(*ElementProto_TableLocalitySecondaryRegion); ok {
		return x.TableLocalitySecondaryRegion
	}
	return nil
}

func (m *ElementProto) GetTableLocalityRegionalByRow() *TableLocalityRegionalByRow {
	if x, ok := m.GetElementOneOf().(*ElementProto_TableLocalityRegionalByRow); ok {
		return x.TableLocalityRegionalByRow
	}
	return nil
}

func (m *ElementProto) GetColumnName() *ColumnName {
	if x, ok := m.GetElementOneOf().(*ElementProto_ColumnName); ok {
		return x.ColumnName
	}
	return nil
}

func (m *ElementProto) GetColumnType() *ColumnType {
	if x, ok := m.GetElementOneOf().(*ElementProto_ColumnType); ok {
		return x.ColumnType
	}
	return nil
}

func (m *ElementProto) GetColumnDefaultExpression() *ColumnDefaultExpression {
	if x, ok := m.GetElementOneOf().(*ElementProto_ColumnDefaultExpression); ok {
		return x.ColumnDefaultExpression
	}
	return nil
}

func (m *ElementProto) GetColumnOnUpdateExpression() *ColumnOnUpdateExpression {
	if x, ok := m.GetElementOneOf().(*ElementProto_ColumnOnUpdateExpression); ok {
		return x.ColumnOnUpdateExpression
	}
	return nil
}

func (m *ElementProto) GetSequenceOwner() *SequenceOwner {
	if x, ok := m.GetElementOneOf().(*ElementProto_SequenceOwner); ok {
		return x.SequenceOwner
	}
	return nil
}

func (m *ElementProto) GetColumnComment() *ColumnComment {
	if x, ok := m.GetElementOneOf().(*ElementProto_ColumnComment); ok {
		return x.ColumnComment
	}
	return nil
}

func (m *ElementProto) GetColumnNotNull() *ColumnNotNull {
	if x, ok := m.GetElementOneOf().(*ElementProto_ColumnNotNull); ok {
		return x.ColumnNotNull
	}
	return nil
}

func (m *ElementProto) GetSequenceOption() *SequenceOption {
	if x, ok := m.GetElementOneOf().(*ElementProto_SequenceOption); ok {
		return x.SequenceOption
	}
	return nil
}

func (m *ElementProto) GetIndexName() *IndexName {
	if x, ok := m.GetElementOneOf().(*ElementProto_IndexName); ok {
		return x.IndexName
	}
	return nil
}

func (m *ElementProto) GetIndexPartitioning() *IndexPartitioning {
	if x, ok := m.GetElementOneOf().(*ElementProto_IndexPartitioning); ok {
		return x.IndexPartitioning
	}
	return nil
}

func (m *ElementProto) GetSecondaryIndexPartial() *SecondaryIndexPartial {
	if x, ok := m.GetElementOneOf().(*ElementProto_SecondaryIndexPartial); ok {
		return x.SecondaryIndexPartial
	}
	return nil
}

func (m *ElementProto) GetIndexComment() *IndexComment {
	if x, ok := m.GetElementOneOf().(*ElementProto_IndexComment); ok {
		return x.IndexComment
	}
	return nil
}

func (m *ElementProto) GetIndexColumn() *IndexColumn {
	if x, ok := m.GetElementOneOf().(*ElementProto_IndexColumn); ok {
		return x.IndexColumn
	}
	return nil
}

func (m *ElementProto) GetIndexData() *IndexData {
	if x, ok := m.GetElementOneOf().(*ElementProto_IndexData); ok {
		return x.IndexData
	}
	return nil
}

func (m *ElementProto) GetConstraintWithoutIndexName() *ConstraintWithoutIndexName {
	if x, ok := m.GetElementOneOf().(*ElementProto_ConstraintWithoutIndexName); ok {
		return x.ConstraintWithoutIndexName
	}
	return nil
}

func (m *ElementProto) GetConstraintComment() *ConstraintComment {
	if x, ok := m.GetElementOneOf().(*ElementProto_ConstraintComment); ok {
		return x.ConstraintComment
	}
	return nil
}

func (m *ElementProto) GetNamespace() *Namespace {
	if x, ok := m.GetElementOneOf().(*ElementProto_Namespace); ok {
		return x.Namespace
	}
	return nil
}

func (m *ElementProto) GetOwner() *Owner {
	if x, ok := m.GetElementOneOf().(*ElementProto_Owner); ok {
		return x.Owner
	}
	return nil
}

func (m *ElementProto) GetUserPrivileges() *UserPrivileges {
	if x, ok := m.GetElementOneOf().(*ElementProto_UserPrivileges); ok {
		return x.UserPrivileges
	}
	return nil
}

func (m *ElementProto) GetDatabaseRegionConfig() *DatabaseRegionConfig {
	if x, ok := m.GetElementOneOf().(*ElementProto_DatabaseRegionConfig); ok {
		return x.DatabaseRegionConfig
	}
	return nil
}

func (m *ElementProto) GetDatabaseRoleSetting() *DatabaseRoleSetting {
	if x, ok := m.GetElementOneOf().(*ElementProto_DatabaseRoleSetting); ok {
		return x.DatabaseRoleSetting
	}
	return nil
}

func (m *ElementProto) GetDatabaseComment() *DatabaseComment {
	if x, ok := m.GetElementOneOf().(*ElementProto_DatabaseComment); ok {
		return x.DatabaseComment
	}
	return nil
}

func (m *ElementProto) GetDatabaseData() *DatabaseData {
	if x, ok := m.GetElementOneOf().(*ElementProto_DatabaseData); ok {
		return x.DatabaseData
	}
	return nil
}

func (m *ElementProto) GetSchemaParent() *SchemaParent {
	if x, ok := m.GetElementOneOf().(*ElementProto_SchemaParent); ok {
		return x.SchemaParent
	}
	return nil
}

func (m *ElementProto) GetSchemaComment() *SchemaComment {
	if x, ok := m.GetElementOneOf().(*ElementProto_SchemaComment); ok {
		return x.SchemaComment
	}
	return nil
}

func (m *ElementProto) GetSchemaChild() *SchemaChild {
	if x, ok := m.GetElementOneOf().(*ElementProto_SchemaChild); ok {
		return x.SchemaChild
	}
	return nil
}

func (m *ElementProto) GetEnumTypeValue() *EnumTypeValue {
	if x, ok := m.GetElementOneOf().(*ElementProto_EnumTypeValue); ok {
		return x.EnumTypeValue
	}
	return nil
}

func (m *ElementProto) GetCompositeTypeAttrType() *CompositeTypeAttrType {
	if x, ok := m.GetElementOneOf().(*ElementProto_CompositeTypeAttrType); ok {
		return x.CompositeTypeAttrType
	}
	return nil
}

func (m *ElementProto) GetCompositeTypeAttrName() *CompositeTypeAttrName {
	if x, ok := m.GetElementOneOf().(*ElementProto_CompositeTypeAttrName); ok {
		return x.CompositeTypeAttrName
	}
	return nil
}

func (m *ElementProto) GetFunctionName() *FunctionName {
	if x, ok := m.GetElementOneOf().(*ElementProto_FunctionName); ok {
		return x.FunctionName
	}
	return nil
}

func (m *ElementProto) GetFunctionVolatility() *FunctionVolatility {
	if x, ok := m.GetElementOneOf().(*ElementProto_FunctionVolatility); ok {
		return x.FunctionVolatility
	}
	return nil
}

func (m *ElementProto) GetFunctionLeakProof() *FunctionLeakProof {
	if x, ok := m.GetElementOneOf().(*ElementProto_FunctionLeakProof); ok {
		return x.FunctionLeakProof
	}
	return nil
}

func (m *ElementProto) GetFunctionNullInputBehavior() *FunctionNullInputBehavior {
	if x, ok := m.GetElementOneOf().(*ElementProto_FunctionNullInputBehavior); ok {
		return x.FunctionNullInputBehavior
	}
	return nil
}

func (m *ElementProto) GetFunctionBody() *FunctionBody {
	if x, ok := m.GetElementOneOf().(*ElementProto_FunctionBody); ok {
		return x.FunctionBody
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ElementProto) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ElementProto_Database)(nil),
		(*ElementProto_Schema)(nil),
		(*ElementProto_View)(nil),
		(*ElementProto_Sequence)(nil),
		(*ElementProto_Table)(nil),
		(*ElementProto_EnumType)(nil),
		(*ElementProto_AliasType)(nil),
		(*ElementProto_CompositeType)(nil),
		(*ElementProto_Function)(nil),
		(*ElementProto_ColumnFamily)(nil),
		(*ElementProto_Column)(nil),
		(*ElementProto_PrimaryIndex)(nil),
		(*ElementProto_SecondaryIndex)(nil),
		(*ElementProto_TemporaryIndex)(nil),
		(*ElementProto_UniqueWithoutIndexConstraint)(nil),
		(*ElementProto_UniqueWithoutIndexConstraintUnvalidated)(nil),
		(*ElementProto_CheckConstraint)(nil),
		(*ElementProto_CheckConstraintUnvalidated)(nil),
		(*ElementProto_ForeignKeyConstraint)(nil),
		(*ElementProto_ForeignKeyConstraintUnvalidated)(nil),
		(*ElementProto_TableComment)(nil),
		(*ElementProto_RowLevelTTL)(nil),
		(*ElementProto_TableZoneConfig)(nil),
		(*ElementProto_IndexZoneConfig)(nil),
		(*ElementProto_TableData)(nil),
		(*ElementProto_TablePartitioning)(nil),
		(*ElementProto_TableSchemaLocked)(nil),
		(*ElementProto_TableLocalityGlobal)(nil),
		(*ElementProto_TableLocalityPrimaryRegion)(nil),
		(*ElementProto_TableLocalitySecondaryRegion)(nil),
		(*ElementProto_TableLocalityRegionalByRow)(nil),
		(*ElementProto_ColumnName)(nil),
		(*ElementProto_ColumnType)(nil),
		(*ElementProto_ColumnDefaultExpression)(nil),
		(*ElementProto_ColumnOnUpdateExpression)(nil),
		(*ElementProto_SequenceOwner)(nil),
		(*ElementProto_ColumnComment)(nil),
		(*ElementProto_ColumnNotNull)(nil),
		(*ElementProto_SequenceOption)(nil),
		(*ElementProto_IndexName)(nil),
		(*ElementProto_IndexPartitioning)(nil),
		(*ElementProto_SecondaryIndexPartial)(nil),
		(*ElementProto_IndexComment)(nil),
		(*ElementProto_IndexColumn)(nil),
		(*ElementProto_IndexData)(nil),
		(*ElementProto_ConstraintWithoutIndexName)(nil),
		(*ElementProto_ConstraintComment)(nil),
		(*ElementProto_Namespace)(nil),
		(*ElementProto_Owner)(nil),
		(*ElementProto_UserPrivileges)(nil),
		(*ElementProto_DatabaseRegionConfig)(nil),
		(*ElementProto_DatabaseRoleSetting)(nil),
		(*ElementProto_DatabaseComment)(nil),
		(*ElementProto_DatabaseData)(nil),
		(*ElementProto_SchemaParent)(nil),
		(*ElementProto_SchemaComment)(nil),
		(*ElementProto_SchemaChild)(nil),
		(*ElementProto_EnumTypeValue)(nil),
		(*ElementProto_CompositeTypeAttrType)(nil),
		(*ElementProto_CompositeTypeAttrName)(nil),
		(*ElementProto_FunctionName)(nil),
		(*ElementProto_FunctionVolatility)(nil),
		(*ElementProto_FunctionLeakProof)(nil),
		(*ElementProto_FunctionNullInputBehavior)(nil),
		(*ElementProto_FunctionBody)(nil),
	}
}

// TypeT is a wrapper for a types.T which contains its user-defined type ID
// closure, explicitly keeping track of the IDs of all the type descriptors
// which will have a back-reference to the owner of the TypeT.
// For example, a wrapped type.Int will have an empty type ID closure, but
// a wrapped user-defined enum type will have the IDs of the enum type and
// its array alias type in the closure.
type TypeT struct {
	Type          *types.T                                                    `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	ClosedTypeIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,rep,packed,name=closed_type_ids,json=closedTypeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"closed_type_ids,omitempty"`
}

func (m *TypeT) Reset()         { *m = TypeT{} }
func (m *TypeT) String() string { return proto.CompactTextString(m) }
func (*TypeT) ProtoMessage()    {}
func (*TypeT) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{1}
}
func (m *TypeT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TypeT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeT.Merge(m, src)
}
func (m *TypeT) XXX_Size() int {
	return m.Size()
}
func (m *TypeT) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeT.DiscardUnknown(m)
}

var xxx_messageInfo_TypeT proto.InternalMessageInfo

// Expression is a wrapper for a column or check constraint expression, which,
// much like the TypeT wrapper, tracks its dependent descriptor IDs. Here these
// include also sequence descriptor IDs.
type Expression struct {
	Expr            github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.Expression `protobuf:"bytes,1,opt,name=expr,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.Expression" json:"expr,omitempty"`
	UsesTypeIDs     []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,2,rep,packed,name=uses_type_ids,json=usesTypeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_type_ids,omitempty"`
	UsesSequenceIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,3,rep,packed,name=uses_sequence_ids,json=usesSequenceIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_sequence_ids,omitempty"`
	// ReferencedColumnIDs stores the IDs of the columns referenced by the expression.
	ReferencedColumnIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,4,rep,packed,name=referenced_column_ids,json=referencedColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"referenced_column_ids,omitempty"`
	UsesFunctionIDs     []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,5,rep,packed,name=uses_function_ids,json=usesFunctionIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_function_ids,omitempty"`
}

func (m *Expression) Reset()         { *m = Expression{} }
func (m *Expression) String() string { return proto.CompactTextString(m) }
func (*Expression) ProtoMessage()    {}
func (*Expression) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{2}
}
func (m *Expression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Expression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Expression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expression.Merge(m, src)
}
func (m *Expression) XXX_Size() int {
	return m.Size()
}
func (m *Expression) XXX_DiscardUnknown() {
	xxx_messageInfo_Expression.DiscardUnknown(m)
}

var xxx_messageInfo_Expression proto.InternalMessageInfo

type Column struct {
	TableID                           github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID                      `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID                          github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID                    `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	IsHidden                          bool                                                                           `protobuf:"varint,3,opt,name=is_hidden,json=isHidden,proto3" json:"is_hidden,omitempty"`
	IsInaccessible                    bool                                                                           `protobuf:"varint,4,opt,name=is_inaccessible,json=isInaccessible,proto3" json:"is_inaccessible,omitempty"`
	GeneratedAsIdentityType           github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.GeneratedAsIdentityType `protobuf:"varint,5,opt,name=generated_as_identity_type,json=generatedAsIdentityType,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.GeneratedAsIdentityType" json:"generated_as_identity_type,omitempty"`
	GeneratedAsIdentitySequenceOption string                                                                         `protobuf:"bytes,6,opt,name=generated_as_identity_sequence_option,json=generatedAsIdentitySequenceOption,proto3" json:"generated_as_identity_sequence_option,omitempty"`
	PgAttributeNum                    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.PGAttributeNum              `protobuf:"varint,7,opt,name=pg_attribute_num,json=pgAttributeNum,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.PGAttributeNum" json:"pg_attribute_num,omitempty"`
	IsSystemColumn                    bool                                                                           `protobuf:"varint,8,opt,name=is_system_column,json=isSystemColumn,proto3" json:"is_system_column,omitempty"`
}

func (m *Column) Reset()         { *m = Column{} }
func (m *Column) String() string { return proto.CompactTextString(m) }
func (*Column) ProtoMessage()    {}
func (*Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{3}
}
func (m *Column) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Column.Merge(m, src)
}
func (m *Column) XXX_Size() int {
	return m.Size()
}
func (m *Column) XXX_DiscardUnknown() {
	xxx_messageInfo_Column.DiscardUnknown(m)
}

var xxx_messageInfo_Column proto.InternalMessageInfo

// ColumnType needs to be an element distinct from Column although they have a
// 1:1 relationship because their lifecycle is not the same.
// Column transitions through the two-version-invariant status path:
//
//	PUBLIC -> WRITE_ONLY -> DELETE_ONLY -> ABSENT
//
// regardless of whether only the column is dropped (meaning ABSENT is reached
// post-commit) or whether the whole table is dropped. We accommodate the
// latter case by having ColumnType reach ABSENT in the pre-commit phase
// independently of its sister column element. This is important, because this
// clears back-references in referenced type descriptors for columns which
// have user-defined types, or reference user-defined types in their compute
// expression.
type ColumnType struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	FamilyID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.FamilyID `protobuf:"varint,2,opt,name=family_id,json=familyId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.FamilyID" json:"family_id,omitempty"`
	ColumnID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,3,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	TypeT    `protobuf:"bytes,4,opt,name=embedded_type_t,json=embeddedTypeT,proto3,embedded=embedded_type_t" json:"embedded_type_t"`
	// Deprecated
	// We changed element modelling for NOT NULL constraint in V23_1 and thus
	// deprecated `is_nullable`. The new way is to handle NOT NULL constraint
	// through a newly introduced `ColumnNotNull` element. This change is
	// necessary to support adding/dropping NOT NULL constraint on an existing
	// column.
	IsNullable  bool        `protobuf:"varint,5,opt,name=is_nullable,json=isNullable,proto3" json:"is_nullable,omitempty"` // Deprecated: Do not use.
	ComputeExpr *Expression `protobuf:"bytes,6,opt,name=compute_expr,json=computeExpr,proto3" json:"compute_expr,omitempty"`
	IsVirtual   bool        `protobuf:"varint,7,opt,name=is_virtual,json=isVirtual,proto3" json:"is_virtual,omitempty"`
	// ElementCreationMetadata stores information about when this element is created.
	// It can be used in a similar way to version gates to ensure compatibility
	// in mixed version state.
	ElementCreationMetadata *ElementCreationMetadata `protobuf:"bytes,11,opt,name=element_creation_metadata,json=elementCreationMetadata,proto3" json:"element_creation_metadata,omitempty"`
}

func (m *ColumnType) Reset()         { *m = ColumnType{} }
func (m *ColumnType) String() string { return proto.CompactTextString(m) }
func (*ColumnType) ProtoMessage()    {}
func (*ColumnType) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{4}
}
func (m *ColumnType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnType.Merge(m, src)
}
func (m *ColumnType) XXX_Size() int {
	return m.Size()
}
func (m *ColumnType) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnType.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnType proto.InternalMessageInfo

type ColumnFamily struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	FamilyID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.FamilyID `protobuf:"varint,2,opt,name=family_id,json=familyId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.FamilyID" json:"family_id,omitempty"`
	Name     string                                                      `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ColumnFamily) Reset()         { *m = ColumnFamily{} }
func (m *ColumnFamily) String() string { return proto.CompactTextString(m) }
func (*ColumnFamily) ProtoMessage()    {}
func (*ColumnFamily) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{5}
}
func (m *ColumnFamily) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnFamily) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnFamily) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnFamily.Merge(m, src)
}
func (m *ColumnFamily) XXX_Size() int {
	return m.Size()
}
func (m *ColumnFamily) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnFamily.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnFamily proto.InternalMessageInfo

// Index is a wrapper for index definition data that gets embedded in both
// PrimaryIndex and SecondaryIndex. These two are not so different, but need
// to be distinguished by type (instead of, say, via a boolean flag in the
// element) to make for sane dependency rules.
type Index struct {
	TableID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	IsUnique   bool                                                       `protobuf:"varint,10,opt,name=is_unique,json=isUnique,proto3" json:"is_unique,omitempty"`
	IsInverted bool                                                       `protobuf:"varint,11,opt,name=is_inverted,json=isInverted,proto3" json:"is_inverted,omitempty"`
	Sharding   *catpb.ShardedDescriptor                                   `protobuf:"bytes,12,opt,name=sharding,proto3" json:"sharding,omitempty"`
	// IsCreatedExplicitly specifies whether this index was created explicitly
	// (i.e. via 'CREATE INDEX' statement) and not implicitly (i.e. created for
	// unique constraint).
	IsCreatedExplicitly bool `protobuf:"varint,13,opt,name=is_created_explicitly,json=isCreatedExplicitly,proto3" json:"is_created_explicitly,omitempty"`
	// ConstraintID is only set for primary keys and unique secondary indexes. It
	// can be used to uniquely identify a constraint.
	ConstraintID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,14,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	// Spec fields.
	// These fields only make sense if the element is for ABSENT -> PUBLIC.
	//
	// TODO(postamar): try to get rid of these altogether
	//
	//	Perhaps move these to the target metadata instead?
	IsConcurrently   bool                                                       `protobuf:"varint,20,opt,name=is_concurrently,json=isConcurrently,proto3" json:"is_concurrently,omitempty"`
	SourceIndexID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,21,opt,name=source_index_id,json=sourceIndexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"source_index_id,omitempty"`
	TemporaryIndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,22,opt,name=temporary_index_id,json=temporaryIndexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"temporary_index_id,omitempty"`
	GeoConfig        *geopb.Config                                              `protobuf:"bytes,24,opt,name=geo_config,json=geoConfig,proto3" json:"geo_config,omitempty"`
	// IsNotVisible specifies whether this index is not visible.
	// NOTE: THIS FIELD IS DEPRECATED in favor of invisibility.
	IsNotVisible bool `protobuf:"varint,23,opt,name=is_not_visible,json=isNotVisible,proto3" json:"is_not_visible,omitempty"` // Deprecated: Do not use.
	// Invisibility specifies index invisibility to the optimizer.
	Invisibility float64 `protobuf:"fixed64,25,opt,name=invisibility,proto3" json:"invisibility,omitempty"`
}

func (m *Index) Reset()         { *m = Index{} }
func (m *Index) String() string { return proto.CompactTextString(m) }
func (*Index) ProtoMessage()    {}
func (*Index) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{6}
}
func (m *Index) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Index) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Index) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Index.Merge(m, src)
}
func (m *Index) XXX_Size() int {
	return m.Size()
}
func (m *Index) XXX_DiscardUnknown() {
	xxx_messageInfo_Index.DiscardUnknown(m)
}

var xxx_messageInfo_Index proto.InternalMessageInfo

type PrimaryIndex struct {
	Index `protobuf:"bytes,1,opt,name=embedded_index,json=embeddedIndex,proto3,embedded=embedded_index" json:"embedded_index"`
}

func (m *PrimaryIndex) Reset()         { *m = PrimaryIndex{} }
func (m *PrimaryIndex) String() string { return proto.CompactTextString(m) }
func (*PrimaryIndex) ProtoMessage()    {}
func (*PrimaryIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{7}
}
func (m *PrimaryIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrimaryIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PrimaryIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrimaryIndex.Merge(m, src)
}
func (m *PrimaryIndex) XXX_Size() int {
	return m.Size()
}
func (m *PrimaryIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_PrimaryIndex.DiscardUnknown(m)
}

var xxx_messageInfo_PrimaryIndex proto.InternalMessageInfo

type SecondaryIndex struct {
	Index        `protobuf:"bytes,1,opt,name=embedded_index,json=embeddedIndex,proto3,embedded=embedded_index" json:"embedded_index"`
	EmbeddedExpr *Expression `protobuf:"bytes,3,opt,name=embedded_expr,json=embeddedExpr,proto3" json:"embedded_expr,omitempty"`
	// If an index is being recreated, this is the original
	// secondary index that we are trying to replace (this
	// is done for primary key changes).
	RecreateSourceIndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,4,opt,name=recreate_source_id,json=recreateSourceId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"recreate_source_id,omitempty"`
}

func (m *SecondaryIndex) Reset()         { *m = SecondaryIndex{} }
func (m *SecondaryIndex) String() string { return proto.CompactTextString(m) }
func (*SecondaryIndex) ProtoMessage()    {}
func (*SecondaryIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{8}
}
func (m *SecondaryIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecondaryIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SecondaryIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecondaryIndex.Merge(m, src)
}
func (m *SecondaryIndex) XXX_Size() int {
	return m.Size()
}
func (m *SecondaryIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_SecondaryIndex.DiscardUnknown(m)
}

var xxx_messageInfo_SecondaryIndex proto.InternalMessageInfo

type TemporaryIndex struct {
	Index                    `protobuf:"bytes,1,opt,name=embedded_index,json=embeddedIndex,proto3,embedded=embedded_index" json:"embedded_index"`
	IsUsingSecondaryEncoding bool        `protobuf:"varint,2,opt,name=is_using_secondary_encoding,json=isUsingSecondaryEncoding,proto3" json:"is_using_secondary_encoding,omitempty"`
	Expr                     *Expression `protobuf:"bytes,3,opt,name=expr,proto3" json:"expr,omitempty"`
}

func (m *TemporaryIndex) Reset()         { *m = TemporaryIndex{} }
func (m *TemporaryIndex) String() string { return proto.CompactTextString(m) }
func (*TemporaryIndex) ProtoMessage()    {}
func (*TemporaryIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{9}
}
func (m *TemporaryIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TemporaryIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TemporaryIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TemporaryIndex.Merge(m, src)
}
func (m *TemporaryIndex) XXX_Size() int {
	return m.Size()
}
func (m *TemporaryIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_TemporaryIndex.DiscardUnknown(m)
}

var xxx_messageInfo_TemporaryIndex proto.InternalMessageInfo

type SecondaryIndexPartial struct {
	TableID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	Expression `protobuf:"bytes,3,opt,name=embedded_expr,json=embeddedExpr,proto3,embedded=embedded_expr" json:"embedded_expr"`
}

func (m *SecondaryIndexPartial) Reset()         { *m = SecondaryIndexPartial{} }
func (m *SecondaryIndexPartial) String() string { return proto.CompactTextString(m) }
func (*SecondaryIndexPartial) ProtoMessage()    {}
func (*SecondaryIndexPartial) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{10}
}
func (m *SecondaryIndexPartial) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecondaryIndexPartial) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SecondaryIndexPartial) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecondaryIndexPartial.Merge(m, src)
}
func (m *SecondaryIndexPartial) XXX_Size() int {
	return m.Size()
}
func (m *SecondaryIndexPartial) XXX_DiscardUnknown() {
	xxx_messageInfo_SecondaryIndexPartial.DiscardUnknown(m)
}

var xxx_messageInfo_SecondaryIndexPartial proto.InternalMessageInfo

// SchemaParent models the schema to parent database relationship.
// Every schema has a parent, so there is a 1:1 relationship between
// the Schema and the SchemaParent relationship. This is modeled as a separate
// element because this one owns the updating of the corresponding
// back-reference in the parent database descriptor as part of its lifecycle.
type SchemaParent struct {
	SchemaID         github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=schema_id,json=schemaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"schema_id,omitempty"`
	ParentDatabaseID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=parent_database_id,json=parentDatabaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"parent_database_id,omitempty"`
}

func (m *SchemaParent) Reset()         { *m = SchemaParent{} }
func (m *SchemaParent) String() string { return proto.CompactTextString(m) }
func (*SchemaParent) ProtoMessage()    {}
func (*SchemaParent) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{11}
}
func (m *SchemaParent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaParent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SchemaParent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaParent.Merge(m, src)
}
func (m *SchemaParent) XXX_Size() int {
	return m.Size()
}
func (m *SchemaParent) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaParent.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaParent proto.InternalMessageInfo

// SchemaChild is like SchemaParent but for objects.
// This is a bit useless since schemas don't maintain a set of back-references
// to their children. Still, it exists as a convenient join relation.
type SchemaChild struct {
	ChildObjectID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=child_object_id,json=childObjectId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"child_object_id,omitempty"`
	SchemaID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=schema_id,json=schemaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"schema_id,omitempty"`
}

func (m *SchemaChild) Reset()         { *m = SchemaChild{} }
func (m *SchemaChild) String() string { return proto.CompactTextString(m) }
func (*SchemaChild) ProtoMessage()    {}
func (*SchemaChild) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{12}
}
func (m *SchemaChild) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaChild) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SchemaChild) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaChild.Merge(m, src)
}
func (m *SchemaChild) XXX_Size() int {
	return m.Size()
}
func (m *SchemaChild) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaChild.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaChild proto.InternalMessageInfo

type Sequence struct {
	SequenceID     github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=sequence_id,json=sequenceId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"sequence_id,omitempty"`
	RestartWith    int64                                                     `protobuf:"varint,2,opt,name=restart_with,json=restartWith,proto3" json:"restart_with,omitempty"`
	UseRestartWith bool                                                      `protobuf:"varint,3,opt,name=use_restart_with,json=useRestartWith,proto3" json:"use_restart_with,omitempty"`
	IsTemporary    bool                                                      `protobuf:"varint,10,opt,name=is_temporary,json=isTemporary,proto3" json:"is_temporary,omitempty"`
}

func (m *Sequence) Reset()         { *m = Sequence{} }
func (m *Sequence) String() string { return proto.CompactTextString(m) }
func (*Sequence) ProtoMessage()    {}
func (*Sequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{13}
}
func (m *Sequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Sequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sequence.Merge(m, src)
}
func (m *Sequence) XXX_Size() int {
	return m.Size()
}
func (m *Sequence) XXX_DiscardUnknown() {
	xxx_messageInfo_Sequence.DiscardUnknown(m)
}

var xxx_messageInfo_Sequence proto.InternalMessageInfo

type SequenceOption struct {
	SequenceID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=sequence_id,json=sequenceId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"sequence_id,omitempty"`
	Key        string                                                    `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value      string                                                    `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *SequenceOption) Reset()         { *m = SequenceOption{} }
func (m *SequenceOption) String() string { return proto.CompactTextString(m) }
func (*SequenceOption) ProtoMessage()    {}
func (*SequenceOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{14}
}
func (m *SequenceOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SequenceOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SequenceOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SequenceOption.Merge(m, src)
}
func (m *SequenceOption) XXX_Size() int {
	return m.Size()
}
func (m *SequenceOption) XXX_DiscardUnknown() {
	xxx_messageInfo_SequenceOption.DiscardUnknown(m)
}

var xxx_messageInfo_SequenceOption proto.InternalMessageInfo

type SequenceOwner struct {
	SequenceID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=sequence_id,json=sequenceId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"sequence_id,omitempty"`
	TableID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,2,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,3,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
}

func (m *SequenceOwner) Reset()         { *m = SequenceOwner{} }
func (m *SequenceOwner) String() string { return proto.CompactTextString(m) }
func (*SequenceOwner) ProtoMessage()    {}
func (*SequenceOwner) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{15}
}
func (m *SequenceOwner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SequenceOwner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SequenceOwner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SequenceOwner.Merge(m, src)
}
func (m *SequenceOwner) XXX_Size() int {
	return m.Size()
}
func (m *SequenceOwner) XXX_DiscardUnknown() {
	xxx_messageInfo_SequenceOwner.DiscardUnknown(m)
}

var xxx_messageInfo_SequenceOwner proto.InternalMessageInfo

type ColumnDefaultExpression struct {
	TableID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	Expression `protobuf:"bytes,3,opt,name=embedded_expr,json=embeddedExpr,proto3,embedded=embedded_expr" json:"embedded_expr"`
}

func (m *ColumnDefaultExpression) Reset()         { *m = ColumnDefaultExpression{} }
func (m *ColumnDefaultExpression) String() string { return proto.CompactTextString(m) }
func (*ColumnDefaultExpression) ProtoMessage()    {}
func (*ColumnDefaultExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{16}
}
func (m *ColumnDefaultExpression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnDefaultExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnDefaultExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnDefaultExpression.Merge(m, src)
}
func (m *ColumnDefaultExpression) XXX_Size() int {
	return m.Size()
}
func (m *ColumnDefaultExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnDefaultExpression.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnDefaultExpression proto.InternalMessageInfo

type ColumnOnUpdateExpression struct {
	TableID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	Expression `protobuf:"bytes,3,opt,name=embedded_expr,json=embeddedExpr,proto3,embedded=embedded_expr" json:"embedded_expr"`
}

func (m *ColumnOnUpdateExpression) Reset()         { *m = ColumnOnUpdateExpression{} }
func (m *ColumnOnUpdateExpression) String() string { return proto.CompactTextString(m) }
func (*ColumnOnUpdateExpression) ProtoMessage()    {}
func (*ColumnOnUpdateExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{17}
}
func (m *ColumnOnUpdateExpression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnOnUpdateExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnOnUpdateExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnOnUpdateExpression.Merge(m, src)
}
func (m *ColumnOnUpdateExpression) XXX_Size() int {
	return m.Size()
}
func (m *ColumnOnUpdateExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnOnUpdateExpression.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnOnUpdateExpression proto.InternalMessageInfo

type View struct {
	ViewID          github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=view_id,json=viewId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"view_id,omitempty"`
	UsesTypeIDs     []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,rep,packed,name=uses_type_ids,json=usesTypeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_type_ids,omitempty"`
	UsesRelationIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,3,rep,packed,name=uses_relation_ids,json=usesRelationIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_relation_ids,omitempty"`
	// all forward reference from this view -- it gives more details of those references than just
	// referenced relation ids (which is stored in `uses_relation_ids`).
	ForwardReferences []*View_Reference `protobuf:"bytes,4,rep,name=forward_references,json=forwardReferences,proto3" json:"forward_references,omitempty"`
	IsTemporary       bool              `protobuf:"varint,10,opt,name=is_temporary,json=isTemporary,proto3" json:"is_temporary,omitempty"`
	IsMaterialized    bool              `protobuf:"varint,11,opt,name=is_materialized,json=isMaterialized,proto3" json:"is_materialized,omitempty"`
}

func (m *View) Reset()         { *m = View{} }
func (m *View) String() string { return proto.CompactTextString(m) }
func (*View) ProtoMessage()    {}
func (*View) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{18}
}
func (m *View) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *View) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *View) XXX_Merge(src proto.Message) {
	xxx_messageInfo_View.Merge(m, src)
}
func (m *View) XXX_Size() int {
	return m.Size()
}
func (m *View) XXX_DiscardUnknown() {
	xxx_messageInfo_View.DiscardUnknown(m)
}

var xxx_messageInfo_View proto.InternalMessageInfo

// a reference from this view to another relation, tracked down to index/column level.
type View_Reference struct {
	ToID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=to_id,json=toId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"to_id,omitempty"`
	// If applicable, the ID of `ToID` relation's index that is referenced by this view.
	IndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	// The IDs of `ToID` relation's columns that are referenced by this view.
	ColumnIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,3,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
}

func (m *View_Reference) Reset()         { *m = View_Reference{} }
func (m *View_Reference) String() string { return proto.CompactTextString(m) }
func (*View_Reference) ProtoMessage()    {}
func (*View_Reference) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{18, 0}
}
func (m *View_Reference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *View_Reference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *View_Reference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_View_Reference.Merge(m, src)
}
func (m *View_Reference) XXX_Size() int {
	return m.Size()
}
func (m *View_Reference) XXX_DiscardUnknown() {
	xxx_messageInfo_View_Reference.DiscardUnknown(m)
}

var xxx_messageInfo_View_Reference proto.InternalMessageInfo

type Table struct {
	TableID     github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IsTemporary bool                                                      `protobuf:"varint,10,opt,name=is_temporary,json=isTemporary,proto3" json:"is_temporary,omitempty"`
}

func (m *Table) Reset()         { *m = Table{} }
func (m *Table) String() string { return proto.CompactTextString(m) }
func (*Table) ProtoMessage()    {}
func (*Table) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{19}
}
func (m *Table) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Table) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Table) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Table.Merge(m, src)
}
func (m *Table) XXX_Size() int {
	return m.Size()
}
func (m *Table) XXX_DiscardUnknown() {
	xxx_messageInfo_Table.DiscardUnknown(m)
}

var xxx_messageInfo_Table proto.InternalMessageInfo

type UniqueWithoutIndexConstraint struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	ColumnIDs    []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID   `protobuf:"varint,3,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
	// Predicate, if non-nil, means a partial uniqueness constraint.
	Predicate *Expression `protobuf:"bytes,4,opt,name=predicate,proto3" json:"predicate,omitempty"`
	// IndexIDForValidation is the index id to hint to the unique_without_index
	// constraint validation SQL query about which index to validate against.
	// It is used exclusively by sql.validateUniqueConstraint.
	IndexIDForValidation github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,5,opt,name=index_id_for_validation,json=indexIdForValidation,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id_for_validation,omitempty"`
}

func (m *UniqueWithoutIndexConstraint) Reset()         { *m = UniqueWithoutIndexConstraint{} }
func (m *UniqueWithoutIndexConstraint) String() string { return proto.CompactTextString(m) }
func (*UniqueWithoutIndexConstraint) ProtoMessage()    {}
func (*UniqueWithoutIndexConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{20}
}
func (m *UniqueWithoutIndexConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UniqueWithoutIndexConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UniqueWithoutIndexConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UniqueWithoutIndexConstraint.Merge(m, src)
}
func (m *UniqueWithoutIndexConstraint) XXX_Size() int {
	return m.Size()
}
func (m *UniqueWithoutIndexConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_UniqueWithoutIndexConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_UniqueWithoutIndexConstraint proto.InternalMessageInfo

type UniqueWithoutIndexConstraintUnvalidated struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	ColumnIDs    []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID   `protobuf:"varint,3,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
	// Predicate, if non-nil, means a partial uniqueness constraint.
	Predicate *Expression `protobuf:"bytes,4,opt,name=predicate,proto3" json:"predicate,omitempty"`
}

func (m *UniqueWithoutIndexConstraintUnvalidated) Reset() {
	*m = UniqueWithoutIndexConstraintUnvalidated{}
}
func (m *UniqueWithoutIndexConstraintUnvalidated) String() string { return proto.CompactTextString(m) }
func (*UniqueWithoutIndexConstraintUnvalidated) ProtoMessage()    {}
func (*UniqueWithoutIndexConstraintUnvalidated) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{21}
}
func (m *UniqueWithoutIndexConstraintUnvalidated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UniqueWithoutIndexConstraintUnvalidated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UniqueWithoutIndexConstraintUnvalidated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UniqueWithoutIndexConstraintUnvalidated.Merge(m, src)
}
func (m *UniqueWithoutIndexConstraintUnvalidated) XXX_Size() int {
	return m.Size()
}
func (m *UniqueWithoutIndexConstraintUnvalidated) XXX_DiscardUnknown() {
	xxx_messageInfo_UniqueWithoutIndexConstraintUnvalidated.DiscardUnknown(m)
}

var xxx_messageInfo_UniqueWithoutIndexConstraintUnvalidated proto.InternalMessageInfo

type CheckConstraint struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	ColumnIDs    []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID   `protobuf:"varint,3,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
	Expression   `protobuf:"bytes,4,opt,name=embedded_expr,json=embeddedExpr,proto3,embedded=embedded_expr" json:"embedded_expr"`
	// FromHashShardedColumn indicates whether this check constraint comes from a hash sharded column.
	FromHashShardedColumn bool `protobuf:"varint,5,opt,name=from_hash_sharded_column,json=fromHashShardedColumn,proto3" json:"from_hash_sharded_column,omitempty"`
	// IndexIDForValidation is the index id to hint to the check constraint validation SQL query about which index
	// to check against. It is used exclusively by sql.validateCheckExpr.
	IndexIDForValidation github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,6,opt,name=index_id_for_validation,json=indexIdForValidation,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id_for_validation,omitempty"`
}

func (m *CheckConstraint) Reset()         { *m = CheckConstraint{} }
func (m *CheckConstraint) String() string { return proto.CompactTextString(m) }
func (*CheckConstraint) ProtoMessage()    {}
func (*CheckConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{22}
}
func (m *CheckConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CheckConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckConstraint.Merge(m, src)
}
func (m *CheckConstraint) XXX_Size() int {
	return m.Size()
}
func (m *CheckConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_CheckConstraint proto.InternalMessageInfo

type CheckConstraintUnvalidated struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	ColumnIDs    []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID   `protobuf:"varint,3,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
	Expression   `protobuf:"bytes,4,opt,name=embedded_expr,json=embeddedExpr,proto3,embedded=embedded_expr" json:"embedded_expr"`
}

func (m *CheckConstraintUnvalidated) Reset()         { *m = CheckConstraintUnvalidated{} }
func (m *CheckConstraintUnvalidated) String() string { return proto.CompactTextString(m) }
func (*CheckConstraintUnvalidated) ProtoMessage()    {}
func (*CheckConstraintUnvalidated) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{23}
}
func (m *CheckConstraintUnvalidated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckConstraintUnvalidated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CheckConstraintUnvalidated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckConstraintUnvalidated.Merge(m, src)
}
func (m *CheckConstraintUnvalidated) XXX_Size() int {
	return m.Size()
}
func (m *CheckConstraintUnvalidated) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckConstraintUnvalidated.DiscardUnknown(m)
}

var xxx_messageInfo_CheckConstraintUnvalidated proto.InternalMessageInfo

type ForeignKeyConstraint struct {
	TableID                 github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID            github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	ColumnIDs               []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID   `protobuf:"varint,3,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
	ReferencedTableID       github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,4,opt,name=referenced_table_id,json=referencedTableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"referenced_table_id,omitempty"`
	ReferencedColumnIDs     []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID   `protobuf:"varint,5,rep,packed,name=referenced_column_ids,json=referencedColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"referenced_column_ids,omitempty"`
	OnUpdateAction          semenumpb.ForeignKeyAction                                      `protobuf:"varint,6,opt,name=on_update_action,json=onUpdateAction,proto3,enum=cockroach.sql.sem.semenumpb.ForeignKeyAction" json:"on_update_action,omitempty"`
	OnDeleteAction          semenumpb.ForeignKeyAction                                      `protobuf:"varint,7,opt,name=on_delete_action,json=onDeleteAction,proto3,enum=cockroach.sql.sem.semenumpb.ForeignKeyAction" json:"on_delete_action,omitempty"`
	CompositeKeyMatchMethod semenumpb.Match                                                 `protobuf:"varint,8,opt,name=composite_key_match_method,json=compositeKeyMatchMethod,proto3,enum=cockroach.sql.sem.semenumpb.Match" json:"composite_key_match_method,omitempty"`
	// IndexIDForValidation is the index id to hint to the foreign key constraint validation SQL query about which index
	// to validate against. It is used exclusively by sql.validateFKExpr.
	IndexIDForValidation github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,9,opt,name=index_id_for_validation,json=indexIdForValidation,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id_for_validation,omitempty"`
}

func (m *ForeignKeyConstraint) Reset()         { *m = ForeignKeyConstraint{} }
func (m *ForeignKeyConstraint) String() string { return proto.CompactTextString(m) }
func (*ForeignKeyConstraint) ProtoMessage()    {}
func (*ForeignKeyConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{24}
}
func (m *ForeignKeyConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForeignKeyConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ForeignKeyConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForeignKeyConstraint.Merge(m, src)
}
func (m *ForeignKeyConstraint) XXX_Size() int {
	return m.Size()
}
func (m *ForeignKeyConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_ForeignKeyConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_ForeignKeyConstraint proto.InternalMessageInfo

type ForeignKeyConstraintUnvalidated struct {
	TableID                 github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID            github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	ColumnIDs               []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID   `protobuf:"varint,3,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
	ReferencedTableID       github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,4,opt,name=referenced_table_id,json=referencedTableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"referenced_table_id,omitempty"`
	ReferencedColumnIDs     []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID   `protobuf:"varint,5,rep,packed,name=referenced_column_ids,json=referencedColumnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"referenced_column_ids,omitempty"`
	OnUpdateAction          semenumpb.ForeignKeyAction                                      `protobuf:"varint,6,opt,name=on_update_action,json=onUpdateAction,proto3,enum=cockroach.sql.sem.semenumpb.ForeignKeyAction" json:"on_update_action,omitempty"`
	OnDeleteAction          semenumpb.ForeignKeyAction                                      `protobuf:"varint,7,opt,name=on_delete_action,json=onDeleteAction,proto3,enum=cockroach.sql.sem.semenumpb.ForeignKeyAction" json:"on_delete_action,omitempty"`
	CompositeKeyMatchMethod semenumpb.Match                                                 `protobuf:"varint,8,opt,name=composite_key_match_method,json=compositeKeyMatchMethod,proto3,enum=cockroach.sql.sem.semenumpb.Match" json:"composite_key_match_method,omitempty"`
}

func (m *ForeignKeyConstraintUnvalidated) Reset()         { *m = ForeignKeyConstraintUnvalidated{} }
func (m *ForeignKeyConstraintUnvalidated) String() string { return proto.CompactTextString(m) }
func (*ForeignKeyConstraintUnvalidated) ProtoMessage()    {}
func (*ForeignKeyConstraintUnvalidated) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{25}
}
func (m *ForeignKeyConstraintUnvalidated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForeignKeyConstraintUnvalidated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ForeignKeyConstraintUnvalidated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForeignKeyConstraintUnvalidated.Merge(m, src)
}
func (m *ForeignKeyConstraintUnvalidated) XXX_Size() int {
	return m.Size()
}
func (m *ForeignKeyConstraintUnvalidated) XXX_DiscardUnknown() {
	xxx_messageInfo_ForeignKeyConstraintUnvalidated.DiscardUnknown(m)
}

var xxx_messageInfo_ForeignKeyConstraintUnvalidated proto.InternalMessageInfo

type EnumType struct {
	TypeID        github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=type_id,json=typeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"type_id,omitempty"`
	ArrayTypeID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=array_type_id,json=arrayTypeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"array_type_id,omitempty"`
	IsMultiRegion bool                                                      `protobuf:"varint,3,opt,name=is_multi_region,json=isMultiRegion,proto3" json:"is_multi_region,omitempty"`
}

func (m *EnumType) Reset()         { *m = EnumType{} }
func (m *EnumType) String() string { return proto.CompactTextString(m) }
func (*EnumType) ProtoMessage()    {}
func (*EnumType) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{26}
}
func (m *EnumType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnumType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EnumType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnumType.Merge(m, src)
}
func (m *EnumType) XXX_Size() int {
	return m.Size()
}
func (m *EnumType) XXX_DiscardUnknown() {
	xxx_messageInfo_EnumType.DiscardUnknown(m)
}

var xxx_messageInfo_EnumType proto.InternalMessageInfo

type AliasType struct {
	TypeID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=type_id,json=typeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"type_id,omitempty"`
	TypeT  `protobuf:"bytes,2,opt,name=embedded_type_t,json=embeddedTypeT,proto3,embedded=embedded_type_t" json:"embedded_type_t"`
}

func (m *AliasType) Reset()         { *m = AliasType{} }
func (m *AliasType) String() string { return proto.CompactTextString(m) }
func (*AliasType) ProtoMessage()    {}
func (*AliasType) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{27}
}
func (m *AliasType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AliasType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AliasType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AliasType.Merge(m, src)
}
func (m *AliasType) XXX_Size() int {
	return m.Size()
}
func (m *AliasType) XXX_DiscardUnknown() {
	xxx_messageInfo_AliasType.DiscardUnknown(m)
}

var xxx_messageInfo_AliasType proto.InternalMessageInfo

type CompositeType struct {
	TypeID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=type_id,json=typeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"type_id,omitempty"`
	ArrayTypeID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=array_type_id,json=arrayTypeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"array_type_id,omitempty"`
}

func (m *CompositeType) Reset()         { *m = CompositeType{} }
func (m *CompositeType) String() string { return proto.CompactTextString(m) }
func (*CompositeType) ProtoMessage()    {}
func (*CompositeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{28}
}
func (m *CompositeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompositeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CompositeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompositeType.Merge(m, src)
}
func (m *CompositeType) XXX_Size() int {
	return m.Size()
}
func (m *CompositeType) XXX_DiscardUnknown() {
	xxx_messageInfo_CompositeType.DiscardUnknown(m)
}

var xxx_messageInfo_CompositeType proto.InternalMessageInfo

type Schema struct {
	SchemaID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=schema_id,json=schemaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"schema_id,omitempty"`
	IsTemporary bool                                                      `protobuf:"varint,10,opt,name=is_temporary,json=isTemporary,proto3" json:"is_temporary,omitempty"`
	IsPublic    bool                                                      `protobuf:"varint,11,opt,name=is_public,json=isPublic,proto3" json:"is_public,omitempty"`
	IsVirtual   bool                                                      `protobuf:"varint,12,opt,name=is_virtual,json=isVirtual,proto3" json:"is_virtual,omitempty"`
}

func (m *Schema) Reset()         { *m = Schema{} }
func (m *Schema) String() string { return proto.CompactTextString(m) }
func (*Schema) ProtoMessage()    {}
func (*Schema) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{29}
}
func (m *Schema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Schema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Schema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schema.Merge(m, src)
}
func (m *Schema) XXX_Size() int {
	return m.Size()
}
func (m *Schema) XXX_DiscardUnknown() {
	xxx_messageInfo_Schema.DiscardUnknown(m)
}

var xxx_messageInfo_Schema proto.InternalMessageInfo

type Database struct {
	DatabaseID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
}

func (m *Database) Reset()         { *m = Database{} }
func (m *Database) String() string { return proto.CompactTextString(m) }
func (*Database) ProtoMessage()    {}
func (*Database) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{30}
}
func (m *Database) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Database) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Database) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Database.Merge(m, src)
}
func (m *Database) XXX_Size() int {
	return m.Size()
}
func (m *Database) XXX_DiscardUnknown() {
	xxx_messageInfo_Database.DiscardUnknown(m)
}

var xxx_messageInfo_Database proto.InternalMessageInfo

type Namespace struct {
	DatabaseID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
	SchemaID     github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=schema_id,json=schemaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"schema_id,omitempty"`
	DescriptorID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,3,opt,name=descriptor_id,json=descriptorId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"descriptor_id,omitempty"`
	Name         string                                                    `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Namespace) Reset()         { *m = Namespace{} }
func (m *Namespace) String() string { return proto.CompactTextString(m) }
func (*Namespace) ProtoMessage()    {}
func (*Namespace) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{31}
}
func (m *Namespace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Namespace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Namespace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Namespace.Merge(m, src)
}
func (m *Namespace) XXX_Size() int {
	return m.Size()
}
func (m *Namespace) XXX_DiscardUnknown() {
	xxx_messageInfo_Namespace.DiscardUnknown(m)
}

var xxx_messageInfo_Namespace proto.InternalMessageInfo

type Owner struct {
	DescriptorID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=descriptor_id,json=descriptorId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"descriptor_id,omitempty"`
	Owner        string                                                    `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *Owner) Reset()         { *m = Owner{} }
func (m *Owner) String() string { return proto.CompactTextString(m) }
func (*Owner) ProtoMessage()    {}
func (*Owner) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{32}
}
func (m *Owner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Owner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Owner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Owner.Merge(m, src)
}
func (m *Owner) XXX_Size() int {
	return m.Size()
}
func (m *Owner) XXX_DiscardUnknown() {
	xxx_messageInfo_Owner.DiscardUnknown(m)
}

var xxx_messageInfo_Owner proto.InternalMessageInfo

type UserPrivileges struct {
	DescriptorID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=descriptor_id,json=descriptorId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"descriptor_id,omitempty"`
	UserName        string                                                    `protobuf:"bytes,2,opt,name=user_name,json=userName,proto3" json:"user_name,omitempty"`
	Privileges      uint64                                                    `protobuf:"varint,3,opt,name=privileges,proto3" json:"privileges,omitempty"`
	WithGrantOption uint64                                                    `protobuf:"varint,4,opt,name=with_grant_option,json=withGrantOption,proto3" json:"with_grant_option,omitempty"`
}

func (m *UserPrivileges) Reset()         { *m = UserPrivileges{} }
func (m *UserPrivileges) String() string { return proto.CompactTextString(m) }
func (*UserPrivileges) ProtoMessage()    {}
func (*UserPrivileges) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{33}
}
func (m *UserPrivileges) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserPrivileges) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UserPrivileges) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserPrivileges.Merge(m, src)
}
func (m *UserPrivileges) XXX_Size() int {
	return m.Size()
}
func (m *UserPrivileges) XXX_DiscardUnknown() {
	xxx_messageInfo_UserPrivileges.DiscardUnknown(m)
}

var xxx_messageInfo_UserPrivileges proto.InternalMessageInfo

type TableLocalityGlobal struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
}

func (m *TableLocalityGlobal) Reset()         { *m = TableLocalityGlobal{} }
func (m *TableLocalityGlobal) String() string { return proto.CompactTextString(m) }
func (*TableLocalityGlobal) ProtoMessage()    {}
func (*TableLocalityGlobal) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{34}
}
func (m *TableLocalityGlobal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableLocalityGlobal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableLocalityGlobal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableLocalityGlobal.Merge(m, src)
}
func (m *TableLocalityGlobal) XXX_Size() int {
	return m.Size()
}
func (m *TableLocalityGlobal) XXX_DiscardUnknown() {
	xxx_messageInfo_TableLocalityGlobal.DiscardUnknown(m)
}

var xxx_messageInfo_TableLocalityGlobal proto.InternalMessageInfo

type TableLocalityPrimaryRegion struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
}

func (m *TableLocalityPrimaryRegion) Reset()         { *m = TableLocalityPrimaryRegion{} }
func (m *TableLocalityPrimaryRegion) String() string { return proto.CompactTextString(m) }
func (*TableLocalityPrimaryRegion) ProtoMessage()    {}
func (*TableLocalityPrimaryRegion) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{35}
}
func (m *TableLocalityPrimaryRegion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableLocalityPrimaryRegion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableLocalityPrimaryRegion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableLocalityPrimaryRegion.Merge(m, src)
}
func (m *TableLocalityPrimaryRegion) XXX_Size() int {
	return m.Size()
}
func (m *TableLocalityPrimaryRegion) XXX_DiscardUnknown() {
	xxx_messageInfo_TableLocalityPrimaryRegion.DiscardUnknown(m)
}

var xxx_messageInfo_TableLocalityPrimaryRegion proto.InternalMessageInfo

type TableLocalitySecondaryRegion struct {
	TableID          github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID         `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	RegionEnumTypeID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID         `protobuf:"varint,2,opt,name=region_enum_type_id,json=regionEnumTypeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"region_enum_type_id,omitempty"`
	RegionName       github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.RegionName `protobuf:"bytes,3,opt,name=region_name,json=regionName,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.RegionName" json:"region_name,omitempty"`
}

func (m *TableLocalitySecondaryRegion) Reset()         { *m = TableLocalitySecondaryRegion{} }
func (m *TableLocalitySecondaryRegion) String() string { return proto.CompactTextString(m) }
func (*TableLocalitySecondaryRegion) ProtoMessage()    {}
func (*TableLocalitySecondaryRegion) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{36}
}
func (m *TableLocalitySecondaryRegion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableLocalitySecondaryRegion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableLocalitySecondaryRegion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableLocalitySecondaryRegion.Merge(m, src)
}
func (m *TableLocalitySecondaryRegion) XXX_Size() int {
	return m.Size()
}
func (m *TableLocalitySecondaryRegion) XXX_DiscardUnknown() {
	xxx_messageInfo_TableLocalitySecondaryRegion.DiscardUnknown(m)
}

var xxx_messageInfo_TableLocalitySecondaryRegion proto.InternalMessageInfo

type TableLocalityRegionalByRow struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	As      string                                                    `protobuf:"bytes,2,opt,name=as,proto3" json:"as,omitempty"`
}

func (m *TableLocalityRegionalByRow) Reset()         { *m = TableLocalityRegionalByRow{} }
func (m *TableLocalityRegionalByRow) String() string { return proto.CompactTextString(m) }
func (*TableLocalityRegionalByRow) ProtoMessage()    {}
func (*TableLocalityRegionalByRow) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{37}
}
func (m *TableLocalityRegionalByRow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableLocalityRegionalByRow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableLocalityRegionalByRow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableLocalityRegionalByRow.Merge(m, src)
}
func (m *TableLocalityRegionalByRow) XXX_Size() int {
	return m.Size()
}
func (m *TableLocalityRegionalByRow) XXX_DiscardUnknown() {
	xxx_messageInfo_TableLocalityRegionalByRow.DiscardUnknown(m)
}

var xxx_messageInfo_TableLocalityRegionalByRow proto.InternalMessageInfo

type IndexPartitioning struct {
	TableID                      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID                      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	catpb.PartitioningDescriptor `protobuf:"bytes,3,opt,name=partitioning,proto3,embedded=partitioning" json:"partitioning"`
}

func (m *IndexPartitioning) Reset()         { *m = IndexPartitioning{} }
func (m *IndexPartitioning) String() string { return proto.CompactTextString(m) }
func (*IndexPartitioning) ProtoMessage()    {}
func (*IndexPartitioning) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{38}
}
func (m *IndexPartitioning) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexPartitioning) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexPartitioning) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexPartitioning.Merge(m, src)
}
func (m *IndexPartitioning) XXX_Size() int {
	return m.Size()
}
func (m *IndexPartitioning) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexPartitioning.DiscardUnknown(m)
}

var xxx_messageInfo_IndexPartitioning proto.InternalMessageInfo

type RowLevelTTL struct {
	TableID           github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	catpb.RowLevelTTL `protobuf:"bytes,2,opt,name=row_level_ttl,json=rowLevelTtl,proto3,embedded=row_level_ttl" json:"row_level_ttl"`
}

func (m *RowLevelTTL) Reset()         { *m = RowLevelTTL{} }
func (m *RowLevelTTL) String() string { return proto.CompactTextString(m) }
func (*RowLevelTTL) ProtoMessage()    {}
func (*RowLevelTTL) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{39}
}
func (m *RowLevelTTL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowLevelTTL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RowLevelTTL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowLevelTTL.Merge(m, src)
}
func (m *RowLevelTTL) XXX_Size() int {
	return m.Size()
}
func (m *RowLevelTTL) XXX_DiscardUnknown() {
	xxx_messageInfo_RowLevelTTL.DiscardUnknown(m)
}

var xxx_messageInfo_RowLevelTTL proto.InternalMessageInfo

type ColumnName struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	Name     string                                                      `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ColumnName) Reset()         { *m = ColumnName{} }
func (m *ColumnName) String() string { return proto.CompactTextString(m) }
func (*ColumnName) ProtoMessage()    {}
func (*ColumnName) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{40}
}
func (m *ColumnName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnName.Merge(m, src)
}
func (m *ColumnName) XXX_Size() int {
	return m.Size()
}
func (m *ColumnName) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnName.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnName proto.InternalMessageInfo

type IndexName struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	Name    string                                                     `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *IndexName) Reset()         { *m = IndexName{} }
func (m *IndexName) String() string { return proto.CompactTextString(m) }
func (*IndexName) ProtoMessage()    {}
func (*IndexName) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{41}
}
func (m *IndexName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexName.Merge(m, src)
}
func (m *IndexName) XXX_Size() int {
	return m.Size()
}
func (m *IndexName) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexName.DiscardUnknown(m)
}

var xxx_messageInfo_IndexName proto.InternalMessageInfo

type ConstraintWithoutIndexName struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	Name         string                                                          `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ConstraintWithoutIndexName) Reset()         { *m = ConstraintWithoutIndexName{} }
func (m *ConstraintWithoutIndexName) String() string { return proto.CompactTextString(m) }
func (*ConstraintWithoutIndexName) ProtoMessage()    {}
func (*ConstraintWithoutIndexName) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{42}
}
func (m *ConstraintWithoutIndexName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConstraintWithoutIndexName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConstraintWithoutIndexName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConstraintWithoutIndexName.Merge(m, src)
}
func (m *ConstraintWithoutIndexName) XXX_Size() int {
	return m.Size()
}
func (m *ConstraintWithoutIndexName) XXX_DiscardUnknown() {
	xxx_messageInfo_ConstraintWithoutIndexName.DiscardUnknown(m)
}

var xxx_messageInfo_ConstraintWithoutIndexName proto.InternalMessageInfo

type TableComment struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	Comment string                                                    `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *TableComment) Reset()         { *m = TableComment{} }
func (m *TableComment) String() string { return proto.CompactTextString(m) }
func (*TableComment) ProtoMessage()    {}
func (*TableComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{43}
}
func (m *TableComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableComment.Merge(m, src)
}
func (m *TableComment) XXX_Size() int {
	return m.Size()
}
func (m *TableComment) XXX_DiscardUnknown() {
	xxx_messageInfo_TableComment.DiscardUnknown(m)
}

var xxx_messageInfo_TableComment proto.InternalMessageInfo

type DatabaseComment struct {
	DatabaseID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
	Comment    string                                                    `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *DatabaseComment) Reset()         { *m = DatabaseComment{} }
func (m *DatabaseComment) String() string { return proto.CompactTextString(m) }
func (*DatabaseComment) ProtoMessage()    {}
func (*DatabaseComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{44}
}
func (m *DatabaseComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabaseComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseComment.Merge(m, src)
}
func (m *DatabaseComment) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseComment) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseComment.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseComment proto.InternalMessageInfo

type SchemaComment struct {
	SchemaID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=schema_id,json=schemaId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"schema_id,omitempty"`
	Comment  string                                                    `protobuf:"bytes,2,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *SchemaComment) Reset()         { *m = SchemaComment{} }
func (m *SchemaComment) String() string { return proto.CompactTextString(m) }
func (*SchemaComment) ProtoMessage()    {}
func (*SchemaComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{45}
}
func (m *SchemaComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SchemaComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaComment.Merge(m, src)
}
func (m *SchemaComment) XXX_Size() int {
	return m.Size()
}
func (m *SchemaComment) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaComment.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaComment proto.InternalMessageInfo

type IndexComment struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	Comment string                                                     `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *IndexComment) Reset()         { *m = IndexComment{} }
func (m *IndexComment) String() string { return proto.CompactTextString(m) }
func (*IndexComment) ProtoMessage()    {}
func (*IndexComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{46}
}
func (m *IndexComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexComment.Merge(m, src)
}
func (m *IndexComment) XXX_Size() int {
	return m.Size()
}
func (m *IndexComment) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexComment.DiscardUnknown(m)
}

var xxx_messageInfo_IndexComment proto.InternalMessageInfo

type ColumnComment struct {
	TableID        github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID         `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID       github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID       `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	Comment        string                                                            `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
	PgAttributeNum github_com_cockroachdb_cockroach_pkg_sql_sem_catid.PGAttributeNum `protobuf:"varint,4,opt,name=pg_attribute_num,json=pgAttributeNum,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.PGAttributeNum" json:"pg_attribute_num,omitempty"`
}

func (m *ColumnComment) Reset()         { *m = ColumnComment{} }
func (m *ColumnComment) String() string { return proto.CompactTextString(m) }
func (*ColumnComment) ProtoMessage()    {}
func (*ColumnComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{47}
}
func (m *ColumnComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnComment.Merge(m, src)
}
func (m *ColumnComment) XXX_Size() int {
	return m.Size()
}
func (m *ColumnComment) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnComment.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnComment proto.InternalMessageInfo

type ColumnNotNull struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	// IndexIDForValidation is the index id to hint to the check constraint validation SQL query about which index
	// to check against the not-null-ness of the column. It is used exclusively by sql.validateCheckExpr.
	IndexIDForValidation github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,3,opt,name=index_id_for_validation,json=indexIdForValidation,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id_for_validation,omitempty"`
}

func (m *ColumnNotNull) Reset()         { *m = ColumnNotNull{} }
func (m *ColumnNotNull) String() string { return proto.CompactTextString(m) }
func (*ColumnNotNull) ProtoMessage()    {}
func (*ColumnNotNull) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{48}
}
func (m *ColumnNotNull) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnNotNull) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ColumnNotNull) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnNotNull.Merge(m, src)
}
func (m *ColumnNotNull) XXX_Size() int {
	return m.Size()
}
func (m *ColumnNotNull) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnNotNull.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnNotNull proto.InternalMessageInfo

type ConstraintComment struct {
	TableID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID       `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ConstraintID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID `protobuf:"varint,2,opt,name=constraint_id,json=constraintId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ConstraintID" json:"constraint_id,omitempty"`
	Comment      string                                                          `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
}

func (m *ConstraintComment) Reset()         { *m = ConstraintComment{} }
func (m *ConstraintComment) String() string { return proto.CompactTextString(m) }
func (*ConstraintComment) ProtoMessage()    {}
func (*ConstraintComment) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{49}
}
func (m *ConstraintComment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConstraintComment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConstraintComment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConstraintComment.Merge(m, src)
}
func (m *ConstraintComment) XXX_Size() int {
	return m.Size()
}
func (m *ConstraintComment) XXX_DiscardUnknown() {
	xxx_messageInfo_ConstraintComment.DiscardUnknown(m)
}

var xxx_messageInfo_ConstraintComment proto.InternalMessageInfo

type DatabaseRegionConfig struct {
	DatabaseID       github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
	RegionEnumTypeID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=region_enum_type_id,json=regionEnumTypeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"region_enum_type_id,omitempty"`
}

func (m *DatabaseRegionConfig) Reset()         { *m = DatabaseRegionConfig{} }
func (m *DatabaseRegionConfig) String() string { return proto.CompactTextString(m) }
func (*DatabaseRegionConfig) ProtoMessage()    {}
func (*DatabaseRegionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{50}
}
func (m *DatabaseRegionConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseRegionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabaseRegionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseRegionConfig.Merge(m, src)
}
func (m *DatabaseRegionConfig) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseRegionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseRegionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseRegionConfig proto.InternalMessageInfo

type DatabaseRoleSetting struct {
	DatabaseID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
	RoleName   string                                                    `protobuf:"bytes,2,opt,name=role_name,json=roleName,proto3" json:"role_name,omitempty"`
}

func (m *DatabaseRoleSetting) Reset()         { *m = DatabaseRoleSetting{} }
func (m *DatabaseRoleSetting) String() string { return proto.CompactTextString(m) }
func (*DatabaseRoleSetting) ProtoMessage()    {}
func (*DatabaseRoleSetting) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{51}
}
func (m *DatabaseRoleSetting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseRoleSetting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabaseRoleSetting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseRoleSetting.Merge(m, src)
}
func (m *DatabaseRoleSetting) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseRoleSetting) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseRoleSetting.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseRoleSetting proto.InternalMessageInfo

// IndexColumn models column membership in an index.
type IndexColumn struct {
	TableID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID  `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	ColumnID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,3,opt,name=column_id,json=columnId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_id,omitempty"`
	// OrdinalInKind is the slice index of this column in the relevant slice
	// as indicated by the IndexColumn's Kind.
	OrdinalInKind uint32           `protobuf:"varint,4,opt,name=ordinal_in_kind,json=ordinalInKind,proto3" json:"ordinal_in_kind,omitempty"`
	Kind          IndexColumn_Kind `protobuf:"varint,5,opt,name=kind,proto3,enum=cockroach.sql.schemachanger.scpb.IndexColumn_Kind" json:"kind,omitempty"`
	// Direction is only populated for KEY columns.
	Direction catenumpb.IndexColumn_Direction `protobuf:"varint,6,opt,name=direction,proto3,enum=cockroach.sql.catalog.catpb.IndexColumn_Direction" json:"direction,omitempty"`
	// Indicates if this column is implicitly included within the index for
	// partitioning.
	Implicit bool `protobuf:"varint,7,opt,name=implicit,proto3" json:"implicit,omitempty"`
	// InvertedKind determines if this column is inverted and how the information
	// is stored.
	InvertedKind github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.InvertedIndexColumnKind `protobuf:"varint,8,opt,name=inverted_kind,json=invertedKind,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/catpb.InvertedIndexColumnKind" json:"inverted_kind,omitempty"`
}

func (m *IndexColumn) Reset()         { *m = IndexColumn{} }
func (m *IndexColumn) String() string { return proto.CompactTextString(m) }
func (*IndexColumn) ProtoMessage()    {}
func (*IndexColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{52}
}
func (m *IndexColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexColumn.Merge(m, src)
}
func (m *IndexColumn) XXX_Size() int {
	return m.Size()
}
func (m *IndexColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexColumn.DiscardUnknown(m)
}

var xxx_messageInfo_IndexColumn proto.InternalMessageInfo

type EnumTypeValue struct {
	TypeID                 github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=type_id,json=typeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"type_id,omitempty"`
	PhysicalRepresentation []byte                                                    `protobuf:"bytes,2,opt,name=physical_representation,json=physicalRepresentation,proto3" json:"physical_representation,omitempty"`
	LogicalRepresentation  string                                                    `protobuf:"bytes,3,opt,name=logical_representation,json=logicalRepresentation,proto3" json:"logical_representation,omitempty"`
}

func (m *EnumTypeValue) Reset()         { *m = EnumTypeValue{} }
func (m *EnumTypeValue) String() string { return proto.CompactTextString(m) }
func (*EnumTypeValue) ProtoMessage()    {}
func (*EnumTypeValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{53}
}
func (m *EnumTypeValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnumTypeValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EnumTypeValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnumTypeValue.Merge(m, src)
}
func (m *EnumTypeValue) XXX_Size() int {
	return m.Size()
}
func (m *EnumTypeValue) XXX_DiscardUnknown() {
	xxx_messageInfo_EnumTypeValue.DiscardUnknown(m)
}

var xxx_messageInfo_EnumTypeValue proto.InternalMessageInfo

type CompositeTypeAttrName struct {
	CompositeTypeID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=composite_type_id,json=compositeTypeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"composite_type_id,omitempty"`
	Name            string                                                    `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *CompositeTypeAttrName) Reset()         { *m = CompositeTypeAttrName{} }
func (m *CompositeTypeAttrName) String() string { return proto.CompactTextString(m) }
func (*CompositeTypeAttrName) ProtoMessage()    {}
func (*CompositeTypeAttrName) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{54}
}
func (m *CompositeTypeAttrName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompositeTypeAttrName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CompositeTypeAttrName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompositeTypeAttrName.Merge(m, src)
}
func (m *CompositeTypeAttrName) XXX_Size() int {
	return m.Size()
}
func (m *CompositeTypeAttrName) XXX_DiscardUnknown() {
	xxx_messageInfo_CompositeTypeAttrName.DiscardUnknown(m)
}

var xxx_messageInfo_CompositeTypeAttrName proto.InternalMessageInfo

type CompositeTypeAttrType struct {
	CompositeTypeID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=composite_type_id,json=compositeTypeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"composite_type_id,omitempty"`
	TypeT           `protobuf:"bytes,2,opt,name=embedded_type_t,json=embeddedTypeT,proto3,embedded=embedded_type_t" json:"embedded_type_t"`
}

func (m *CompositeTypeAttrType) Reset()         { *m = CompositeTypeAttrType{} }
func (m *CompositeTypeAttrType) String() string { return proto.CompactTextString(m) }
func (*CompositeTypeAttrType) ProtoMessage()    {}
func (*CompositeTypeAttrType) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{55}
}
func (m *CompositeTypeAttrType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompositeTypeAttrType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CompositeTypeAttrType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompositeTypeAttrType.Merge(m, src)
}
func (m *CompositeTypeAttrType) XXX_Size() int {
	return m.Size()
}
func (m *CompositeTypeAttrType) XXX_DiscardUnknown() {
	xxx_messageInfo_CompositeTypeAttrType.DiscardUnknown(m)
}

var xxx_messageInfo_CompositeTypeAttrType proto.InternalMessageInfo

type TableZoneConfig struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
}

func (m *TableZoneConfig) Reset()         { *m = TableZoneConfig{} }
func (m *TableZoneConfig) String() string { return proto.CompactTextString(m) }
func (*TableZoneConfig) ProtoMessage()    {}
func (*TableZoneConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{56}
}
func (m *TableZoneConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableZoneConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableZoneConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableZoneConfig.Merge(m, src)
}
func (m *TableZoneConfig) XXX_Size() int {
	return m.Size()
}
func (m *TableZoneConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TableZoneConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TableZoneConfig proto.InternalMessageInfo

type IndexZoneConfig struct {
	TableID       github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID       github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
	PartitionName string                                                     `protobuf:"bytes,3,opt,name=partition_name,json=partitionName,proto3" json:"partition_name,omitempty"`
}

func (m *IndexZoneConfig) Reset()         { *m = IndexZoneConfig{} }
func (m *IndexZoneConfig) String() string { return proto.CompactTextString(m) }
func (*IndexZoneConfig) ProtoMessage()    {}
func (*IndexZoneConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{57}
}
func (m *IndexZoneConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexZoneConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexZoneConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexZoneConfig.Merge(m, src)
}
func (m *IndexZoneConfig) XXX_Size() int {
	return m.Size()
}
func (m *IndexZoneConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexZoneConfig.DiscardUnknown(m)
}

var xxx_messageInfo_IndexZoneConfig proto.InternalMessageInfo

// DatabaseData models what needs to be GCed when a database is dropped.
type DatabaseData struct {
	DatabaseID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
}

func (m *DatabaseData) Reset()         { *m = DatabaseData{} }
func (m *DatabaseData) String() string { return proto.CompactTextString(m) }
func (*DatabaseData) ProtoMessage()    {}
func (*DatabaseData) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{58}
}
func (m *DatabaseData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DatabaseData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseData.Merge(m, src)
}
func (m *DatabaseData) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseData) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseData.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseData proto.InternalMessageInfo

// TableData models what needs to be GCed when a table is dropped.
type TableData struct {
	TableID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	DatabaseID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,2,opt,name=database_id,json=databaseId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"database_id,omitempty"`
}

func (m *TableData) Reset()         { *m = TableData{} }
func (m *TableData) String() string { return proto.CompactTextString(m) }
func (*TableData) ProtoMessage()    {}
func (*TableData) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{59}
}
func (m *TableData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableData.Merge(m, src)
}
func (m *TableData) XXX_Size() int {
	return m.Size()
}
func (m *TableData) XXX_DiscardUnknown() {
	xxx_messageInfo_TableData.DiscardUnknown(m)
}

var xxx_messageInfo_TableData proto.InternalMessageInfo

// IndexData models what needs to be GCed when an index is dropped.
type IndexData struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID  `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	IndexID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
}

func (m *IndexData) Reset()         { *m = IndexData{} }
func (m *IndexData) String() string { return proto.CompactTextString(m) }
func (*IndexData) ProtoMessage()    {}
func (*IndexData) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{60}
}
func (m *IndexData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexData.Merge(m, src)
}
func (m *IndexData) XXX_Size() int {
	return m.Size()
}
func (m *IndexData) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexData.DiscardUnknown(m)
}

var xxx_messageInfo_IndexData proto.InternalMessageInfo

type TablePartitioning struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
}

func (m *TablePartitioning) Reset()         { *m = TablePartitioning{} }
func (m *TablePartitioning) String() string { return proto.CompactTextString(m) }
func (*TablePartitioning) ProtoMessage()    {}
func (*TablePartitioning) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{61}
}
func (m *TablePartitioning) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TablePartitioning) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TablePartitioning) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TablePartitioning.Merge(m, src)
}
func (m *TablePartitioning) XXX_Size() int {
	return m.Size()
}
func (m *TablePartitioning) XXX_DiscardUnknown() {
	xxx_messageInfo_TablePartitioning.DiscardUnknown(m)
}

var xxx_messageInfo_TablePartitioning proto.InternalMessageInfo

// TableSchemaLocked models storage parameter `schema_locked` of a table.
type TableSchemaLocked struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
}

func (m *TableSchemaLocked) Reset()         { *m = TableSchemaLocked{} }
func (m *TableSchemaLocked) String() string { return proto.CompactTextString(m) }
func (*TableSchemaLocked) ProtoMessage()    {}
func (*TableSchemaLocked) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{62}
}
func (m *TableSchemaLocked) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableSchemaLocked) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TableSchemaLocked) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableSchemaLocked.Merge(m, src)
}
func (m *TableSchemaLocked) XXX_Size() int {
	return m.Size()
}
func (m *TableSchemaLocked) XXX_DiscardUnknown() {
	xxx_messageInfo_TableSchemaLocked.DiscardUnknown(m)
}

var xxx_messageInfo_TableSchemaLocked proto.InternalMessageInfo

type Function struct {
	FunctionID  github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=function_id,json=functionId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"function_id,omitempty"`
	Params      []Function_Parameter                                      `protobuf:"bytes,2,rep,name=params,proto3" json:"params"`
	ReturnSet   bool                                                      `protobuf:"varint,3,opt,name=return_set,json=returnSet,proto3" json:"return_set,omitempty"`
	ReturnType  TypeT                                                     `protobuf:"bytes,4,opt,name=return_type,json=returnType,proto3" json:"return_type"`
	IsProcedure bool                                                      `protobuf:"varint,5,opt,name=is_procedure,json=isProcedure,proto3" json:"is_procedure,omitempty"`
}

func (m *Function) Reset()         { *m = Function{} }
func (m *Function) String() string { return proto.CompactTextString(m) }
func (*Function) ProtoMessage()    {}
func (*Function) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{63}
}
func (m *Function) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Function) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Function) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Function.Merge(m, src)
}
func (m *Function) XXX_Size() int {
	return m.Size()
}
func (m *Function) XXX_DiscardUnknown() {
	xxx_messageInfo_Function.DiscardUnknown(m)
}

var xxx_messageInfo_Function proto.InternalMessageInfo

type Function_Parameter struct {
	Name        string                   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Class       catpb.FunctionParamClass `protobuf:"bytes,2,opt,name=class,proto3" json:"class"`
	Type        TypeT                    `protobuf:"bytes,3,opt,name=type,proto3" json:"type"`
	DefaultExpr string                   `protobuf:"bytes,4,opt,name=default_expr,json=defaultExpr,proto3" json:"default_expr,omitempty"`
}

func (m *Function_Parameter) Reset()         { *m = Function_Parameter{} }
func (m *Function_Parameter) String() string { return proto.CompactTextString(m) }
func (*Function_Parameter) ProtoMessage()    {}
func (*Function_Parameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{63, 0}
}
func (m *Function_Parameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Function_Parameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Function_Parameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Function_Parameter.Merge(m, src)
}
func (m *Function_Parameter) XXX_Size() int {
	return m.Size()
}
func (m *Function_Parameter) XXX_DiscardUnknown() {
	xxx_messageInfo_Function_Parameter.DiscardUnknown(m)
}

var xxx_messageInfo_Function_Parameter proto.InternalMessageInfo

type FunctionName struct {
	FunctionID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=function_id,json=functionId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"function_id,omitempty"`
	Name       string                                                    `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *FunctionName) Reset()         { *m = FunctionName{} }
func (m *FunctionName) String() string { return proto.CompactTextString(m) }
func (*FunctionName) ProtoMessage()    {}
func (*FunctionName) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{64}
}
func (m *FunctionName) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FunctionName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionName.Merge(m, src)
}
func (m *FunctionName) XXX_Size() int {
	return m.Size()
}
func (m *FunctionName) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionName.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionName proto.InternalMessageInfo

type FunctionVolatility struct {
	FunctionID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=function_id,json=functionId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"function_id,omitempty"`
	Volatility catpb.FunctionVolatility                                  `protobuf:"bytes,2,opt,name=volatility,proto3" json:"volatility"`
}

func (m *FunctionVolatility) Reset()         { *m = FunctionVolatility{} }
func (m *FunctionVolatility) String() string { return proto.CompactTextString(m) }
func (*FunctionVolatility) ProtoMessage()    {}
func (*FunctionVolatility) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{65}
}
func (m *FunctionVolatility) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionVolatility) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FunctionVolatility) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionVolatility.Merge(m, src)
}
func (m *FunctionVolatility) XXX_Size() int {
	return m.Size()
}
func (m *FunctionVolatility) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionVolatility.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionVolatility proto.InternalMessageInfo

type FunctionLeakProof struct {
	FunctionID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=function_id,json=functionId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"function_id,omitempty"`
	LeakProof  bool                                                      `protobuf:"varint,2,opt,name=leak_proof,json=leakProof,proto3" json:"leak_proof,omitempty"`
}

func (m *FunctionLeakProof) Reset()         { *m = FunctionLeakProof{} }
func (m *FunctionLeakProof) String() string { return proto.CompactTextString(m) }
func (*FunctionLeakProof) ProtoMessage()    {}
func (*FunctionLeakProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{66}
}
func (m *FunctionLeakProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionLeakProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FunctionLeakProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionLeakProof.Merge(m, src)
}
func (m *FunctionLeakProof) XXX_Size() int {
	return m.Size()
}
func (m *FunctionLeakProof) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionLeakProof.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionLeakProof proto.InternalMessageInfo

type FunctionNullInputBehavior struct {
	FunctionID        github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=function_id,json=functionId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"function_id,omitempty"`
	NullInputBehavior catpb.FunctionNullInputBehavior                           `protobuf:"bytes,11,opt,name=null_input_behavior,json=nullInputBehavior,proto3" json:"null_input_behavior"`
}

func (m *FunctionNullInputBehavior) Reset()         { *m = FunctionNullInputBehavior{} }
func (m *FunctionNullInputBehavior) String() string { return proto.CompactTextString(m) }
func (*FunctionNullInputBehavior) ProtoMessage()    {}
func (*FunctionNullInputBehavior) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{67}
}
func (m *FunctionNullInputBehavior) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionNullInputBehavior) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FunctionNullInputBehavior) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionNullInputBehavior.Merge(m, src)
}
func (m *FunctionNullInputBehavior) XXX_Size() int {
	return m.Size()
}
func (m *FunctionNullInputBehavior) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionNullInputBehavior.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionNullInputBehavior proto.InternalMessageInfo

type FunctionBody struct {
	FunctionID      github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID   `protobuf:"varint,1,opt,name=function_id,json=functionId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"function_id,omitempty"`
	Body            string                                                      `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
	Lang            catpb.FunctionLanguage                                      `protobuf:"bytes,3,opt,name=lang,proto3" json:"lang"`
	UsesTables      []FunctionBody_TableReference                               `protobuf:"bytes,4,rep,name=uses_tables,json=usesTables,proto3" json:"uses_tables"`
	UsesViews       []FunctionBody_ViewReference                                `protobuf:"bytes,5,rep,name=uses_views,json=usesViews,proto3" json:"uses_views"`
	UsesSequenceIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,6,rep,packed,name=uses_sequence_ids,json=usesSequenceIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_sequence_ids,omitempty"`
	UsesTypeIDs     []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,7,rep,packed,name=uses_type_ids,json=usesTypeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_type_ids,omitempty"`
	UsesFunctionIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,8,rep,packed,name=uses_function_ids,json=usesFunctionIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"uses_function_ids,omitempty"`
}

func (m *FunctionBody) Reset()         { *m = FunctionBody{} }
func (m *FunctionBody) String() string { return proto.CompactTextString(m) }
func (*FunctionBody) ProtoMessage()    {}
func (*FunctionBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{68}
}
func (m *FunctionBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FunctionBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionBody.Merge(m, src)
}
func (m *FunctionBody) XXX_Size() int {
	return m.Size()
}
func (m *FunctionBody) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionBody.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionBody proto.InternalMessageInfo

type FunctionBody_TableReference struct {
	TableID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID     `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id,omitempty"`
	ColumnIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
	IndexID   github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID    `protobuf:"varint,3,opt,name=index_id,json=indexId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.IndexID" json:"index_id,omitempty"`
}

func (m *FunctionBody_TableReference) Reset()         { *m = FunctionBody_TableReference{} }
func (m *FunctionBody_TableReference) String() string { return proto.CompactTextString(m) }
func (*FunctionBody_TableReference) ProtoMessage()    {}
func (*FunctionBody_TableReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{68, 0}
}
func (m *FunctionBody_TableReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionBody_TableReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FunctionBody_TableReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionBody_TableReference.Merge(m, src)
}
func (m *FunctionBody_TableReference) XXX_Size() int {
	return m.Size()
}
func (m *FunctionBody_TableReference) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionBody_TableReference.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionBody_TableReference proto.InternalMessageInfo

type FunctionBody_ViewReference struct {
	ViewID    github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID     `protobuf:"varint,1,opt,name=view_id,json=viewId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"view_id,omitempty"`
	ColumnIDs []github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID `protobuf:"varint,2,rep,packed,name=column_ids,json=columnIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.ColumnID" json:"column_ids,omitempty"`
}

func (m *FunctionBody_ViewReference) Reset()         { *m = FunctionBody_ViewReference{} }
func (m *FunctionBody_ViewReference) String() string { return proto.CompactTextString(m) }
func (*FunctionBody_ViewReference) ProtoMessage()    {}
func (*FunctionBody_ViewReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{68, 1}
}
func (m *FunctionBody_ViewReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FunctionBody_ViewReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FunctionBody_ViewReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FunctionBody_ViewReference.Merge(m, src)
}
func (m *FunctionBody_ViewReference) XXX_Size() int {
	return m.Size()
}
func (m *FunctionBody_ViewReference) XXX_DiscardUnknown() {
	xxx_messageInfo_FunctionBody_ViewReference.DiscardUnknown(m)
}

var xxx_messageInfo_FunctionBody_ViewReference proto.InternalMessageInfo

type ElementCreationMetadata struct {
	In_23_1OrLater bool `protobuf:"varint,1,opt,name=in_23_1_or_later,json=in231OrLater,proto3" json:"in_23_1_or_later,omitempty"`
}

func (m *ElementCreationMetadata) Reset()         { *m = ElementCreationMetadata{} }
func (m *ElementCreationMetadata) String() string { return proto.CompactTextString(m) }
func (*ElementCreationMetadata) ProtoMessage()    {}
func (*ElementCreationMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_49b58fafa7b67c5d, []int{69}
}
func (m *ElementCreationMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ElementCreationMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ElementCreationMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ElementCreationMetadata.Merge(m, src)
}
func (m *ElementCreationMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ElementCreationMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ElementCreationMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ElementCreationMetadata proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.sql.schemachanger.scpb.IndexColumn_Kind", IndexColumn_Kind_name, IndexColumn_Kind_value)
	proto.RegisterType((*ElementProto)(nil), "cockroach.sql.schemachanger.scpb.ElementProto")
	proto.RegisterType((*TypeT)(nil), "cockroach.sql.schemachanger.scpb.TypeT")
	proto.RegisterType((*Expression)(nil), "cockroach.sql.schemachanger.scpb.Expression")
	proto.RegisterType((*Column)(nil), "cockroach.sql.schemachanger.scpb.Column")
	proto.RegisterType((*ColumnType)(nil), "cockroach.sql.schemachanger.scpb.ColumnType")
	proto.RegisterType((*ColumnFamily)(nil), "cockroach.sql.schemachanger.scpb.ColumnFamily")
	proto.RegisterType((*Index)(nil), "cockroach.sql.schemachanger.scpb.Index")
	proto.RegisterType((*PrimaryIndex)(nil), "cockroach.sql.schemachanger.scpb.PrimaryIndex")
	proto.RegisterType((*SecondaryIndex)(nil), "cockroach.sql.schemachanger.scpb.SecondaryIndex")
	proto.RegisterType((*TemporaryIndex)(nil), "cockroach.sql.schemachanger.scpb.TemporaryIndex")
	proto.RegisterType((*SecondaryIndexPartial)(nil), "cockroach.sql.schemachanger.scpb.SecondaryIndexPartial")
	proto.RegisterType((*SchemaParent)(nil), "cockroach.sql.schemachanger.scpb.SchemaParent")
	proto.RegisterType((*SchemaChild)(nil), "cockroach.sql.schemachanger.scpb.SchemaChild")
	proto.RegisterType((*Sequence)(nil), "cockroach.sql.schemachanger.scpb.Sequence")
	proto.RegisterType((*SequenceOption)(nil), "cockroach.sql.schemachanger.scpb.SequenceOption")
	proto.RegisterType((*SequenceOwner)(nil), "cockroach.sql.schemachanger.scpb.SequenceOwner")
	proto.RegisterType((*ColumnDefaultExpression)(nil), "cockroach.sql.schemachanger.scpb.ColumnDefaultExpression")
	proto.RegisterType((*ColumnOnUpdateExpression)(nil), "cockroach.sql.schemachanger.scpb.ColumnOnUpdateExpression")
	proto.RegisterType((*View)(nil), "cockroach.sql.schemachanger.scpb.View")
	proto.RegisterType((*View_Reference)(nil), "cockroach.sql.schemachanger.scpb.View.Reference")
	proto.RegisterType((*Table)(nil), "cockroach.sql.schemachanger.scpb.Table")
	proto.RegisterType((*UniqueWithoutIndexConstraint)(nil), "cockroach.sql.schemachanger.scpb.UniqueWithoutIndexConstraint")
	proto.RegisterType((*UniqueWithoutIndexConstraintUnvalidated)(nil), "cockroach.sql.schemachanger.scpb.UniqueWithoutIndexConstraintUnvalidated")
	proto.RegisterType((*CheckConstraint)(nil), "cockroach.sql.schemachanger.scpb.CheckConstraint")
	proto.RegisterType((*CheckConstraintUnvalidated)(nil), "cockroach.sql.schemachanger.scpb.CheckConstraintUnvalidated")
	proto.RegisterType((*ForeignKeyConstraint)(nil), "cockroach.sql.schemachanger.scpb.ForeignKeyConstraint")
	proto.RegisterType((*ForeignKeyConstraintUnvalidated)(nil), "cockroach.sql.schemachanger.scpb.ForeignKeyConstraintUnvalidated")
	proto.RegisterType((*EnumType)(nil), "cockroach.sql.schemachanger.scpb.EnumType")
	proto.RegisterType((*AliasType)(nil), "cockroach.sql.schemachanger.scpb.AliasType")
	proto.RegisterType((*CompositeType)(nil), "cockroach.sql.schemachanger.scpb.CompositeType")
	proto.RegisterType((*Schema)(nil), "cockroach.sql.schemachanger.scpb.Schema")
	proto.RegisterType((*Database)(nil), "cockroach.sql.schemachanger.scpb.Database")
	proto.RegisterType((*Namespace)(nil), "cockroach.sql.schemachanger.scpb.Namespace")
	proto.RegisterType((*Owner)(nil), "cockroach.sql.schemachanger.scpb.Owner")
	proto.RegisterType((*UserPrivileges)(nil), "cockroach.sql.schemachanger.scpb.UserPrivileges")
	proto.RegisterType((*TableLocalityGlobal)(nil), "cockroach.sql.schemachanger.scpb.TableLocalityGlobal")
	proto.RegisterType((*TableLocalityPrimaryRegion)(nil), "cockroach.sql.schemachanger.scpb.TableLocalityPrimaryRegion")
	proto.RegisterType((*TableLocalitySecondaryRegion)(nil), "cockroach.sql.schemachanger.scpb.TableLocalitySecondaryRegion")
	proto.RegisterType((*TableLocalityRegionalByRow)(nil), "cockroach.sql.schemachanger.scpb.TableLocalityRegionalByRow")
	proto.RegisterType((*IndexPartitioning)(nil), "cockroach.sql.schemachanger.scpb.IndexPartitioning")
	proto.RegisterType((*RowLevelTTL)(nil), "cockroach.sql.schemachanger.scpb.RowLevelTTL")
	proto.RegisterType((*ColumnName)(nil), "cockroach.sql.schemachanger.scpb.ColumnName")
	proto.RegisterType((*IndexName)(nil), "cockroach.sql.schemachanger.scpb.IndexName")
	proto.RegisterType((*ConstraintWithoutIndexName)(nil), "cockroach.sql.schemachanger.scpb.ConstraintWithoutIndexName")
	proto.RegisterType((*TableComment)(nil), "cockroach.sql.schemachanger.scpb.TableComment")
	proto.RegisterType((*DatabaseComment)(nil), "cockroach.sql.schemachanger.scpb.DatabaseComment")
	proto.RegisterType((*SchemaComment)(nil), "cockroach.sql.schemachanger.scpb.SchemaComment")
	proto.RegisterType((*IndexComment)(nil), "cockroach.sql.schemachanger.scpb.IndexComment")
	proto.RegisterType((*ColumnComment)(nil), "cockroach.sql.schemachanger.scpb.ColumnComment")
	proto.RegisterType((*ColumnNotNull)(nil), "cockroach.sql.schemachanger.scpb.ColumnNotNull")
	proto.RegisterType((*ConstraintComment)(nil), "cockroach.sql.schemachanger.scpb.ConstraintComment")
	proto.RegisterType((*DatabaseRegionConfig)(nil), "cockroach.sql.schemachanger.scpb.DatabaseRegionConfig")
	proto.RegisterType((*DatabaseRoleSetting)(nil), "cockroach.sql.schemachanger.scpb.DatabaseRoleSetting")
	proto.RegisterType((*IndexColumn)(nil), "cockroach.sql.schemachanger.scpb.IndexColumn")
	proto.RegisterType((*EnumTypeValue)(nil), "cockroach.sql.schemachanger.scpb.EnumTypeValue")
	proto.RegisterType((*CompositeTypeAttrName)(nil), "cockroach.sql.schemachanger.scpb.CompositeTypeAttrName")
	proto.RegisterType((*CompositeTypeAttrType)(nil), "cockroach.sql.schemachanger.scpb.CompositeTypeAttrType")
	proto.RegisterType((*TableZoneConfig)(nil), "cockroach.sql.schemachanger.scpb.TableZoneConfig")
	proto.RegisterType((*IndexZoneConfig)(nil), "cockroach.sql.schemachanger.scpb.IndexZoneConfig")
	proto.RegisterType((*DatabaseData)(nil), "cockroach.sql.schemachanger.scpb.DatabaseData")
	proto.RegisterType((*TableData)(nil), "cockroach.sql.schemachanger.scpb.TableData")
	proto.RegisterType((*IndexData)(nil), "cockroach.sql.schemachanger.scpb.IndexData")
	proto.RegisterType((*TablePartitioning)(nil), "cockroach.sql.schemachanger.scpb.TablePartitioning")
	proto.RegisterType((*TableSchemaLocked)(nil), "cockroach.sql.schemachanger.scpb.TableSchemaLocked")
	proto.RegisterType((*Function)(nil), "cockroach.sql.schemachanger.scpb.Function")
	proto.RegisterType((*Function_Parameter)(nil), "cockroach.sql.schemachanger.scpb.Function.Parameter")
	proto.RegisterType((*FunctionName)(nil), "cockroach.sql.schemachanger.scpb.FunctionName")
	proto.RegisterType((*FunctionVolatility)(nil), "cockroach.sql.schemachanger.scpb.FunctionVolatility")
	proto.RegisterType((*FunctionLeakProof)(nil), "cockroach.sql.schemachanger.scpb.FunctionLeakProof")
	proto.RegisterType((*FunctionNullInputBehavior)(nil), "cockroach.sql.schemachanger.scpb.FunctionNullInputBehavior")
	proto.RegisterType((*FunctionBody)(nil), "cockroach.sql.schemachanger.scpb.FunctionBody")
	proto.RegisterType((*FunctionBody_TableReference)(nil), "cockroach.sql.schemachanger.scpb.FunctionBody.TableReference")
	proto.RegisterType((*FunctionBody_ViewReference)(nil), "cockroach.sql.schemachanger.scpb.FunctionBody.ViewReference")
	proto.RegisterType((*ElementCreationMetadata)(nil), "cockroach.sql.schemachanger.scpb.ElementCreationMetadata")
}

func init() {
	proto.RegisterFile("sql/schemachanger/scpb/elements.proto", fileDescriptor_49b58fafa7b67c5d)
}

var fileDescriptor_49b58fafa7b67c5d = []byte{
	// 5550 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x3d, 0x59, 0x6c, 0x24, 0xc7,
	0x75, 0xec, 0xe1, 0x90, 0x9c, 0x79, 0x73, 0x90, 0xac, 0x5d, 0x2e, 0x7b, 0xb9, 0xbb, 0x1c, 0xee,
	0x38, 0x2b, 0xad, 0x2d, 0x8a, 0x8c, 0x76, 0xad, 0x08, 0x96, 0x25, 0x3b, 0x3b, 0x7b, 0x72, 0x4f,
	0xba, 0xf7, 0xd0, 0xe1, 0x00, 0xed, 0x66, 0x77, 0x71, 0xd8, 0x62, 0x4f, 0xf7, 0xa8, 0xbb, 0x87,
	0xdc, 0x11, 0x94, 0x48, 0x96, 0xa2, 0x04, 0x48, 0x24, 0x4b, 0x06, 0x92, 0x00, 0x41, 0x7e, 0x94,
	0xcb, 0xc8, 0x05, 0xf8, 0x23, 0xbf, 0x86, 0x91, 0x7c, 0xd8, 0x58, 0x24, 0x01, 0x22, 0xe4, 0x74,
	0x80, 0x60, 0x62, 0x8f, 0x7e, 0x9c, 0x00, 0xce, 0xc1, 0x7c, 0x18, 0x10, 0xf2, 0x11, 0xd4, 0xd5,
	0xc7, 0x70, 0x86, 0x6c, 0x2e, 0xb9, 0xb3, 0x10, 0xb1, 0x1f, 0x2b, 0xb1, 0xab, 0xea, 0x1d, 0xf5,
	0xea, 0x78, 0xaf, 0x5e, 0xbd, 0x7a, 0x03, 0x27, 0xbc, 0x57, 0xad, 0x79, 0x4f, 0x5f, 0xc1, 0x35,
	0x4d, 0x5f, 0xd1, 0xec, 0x2a, 0x76, 0xe7, 0x3d, 0xbd, 0xbe, 0x34, 0x8f, 0x2d, 0x5c, 0xc3, 0xb6,
	0xef, 0xcd, 0xd5, 0x5d, 0xc7, 0x77, 0xd0, 0x8c, 0xee, 0xe8, 0xab, 0xae, 0xa3, 0xe9, 0x2b, 0x73,
	0xde, 0xab, 0xd6, 0x5c, 0x0c, 0x60, 0x8e, 0x00, 0x4c, 0x1d, 0x27, 0x88, 0x74, 0xcd, 0xd7, 0x2c,
	0xa7, 0x4a, 0xfe, 0x8f, 0xed, 0x46, 0xad, 0xbe, 0x34, 0x6f, 0xda, 0x06, 0xbe, 0xcb, 0x90, 0x4c,
	0x95, 0x3a, 0x9a, 0xd4, 0x97, 0xc4, 0x17, 0x6f, 0x50, 0xa6, 0xcc, 0xe0, 0x1a, 0xf9, 0xc7, 0xe1,
	0x75, 0xc7, 0xf6, 0x7c, 0x57, 0x33, 0x6d, 0x9f, 0xb7, 0x99, 0xd9, 0x8c, 0x64, 0xb9, 0x61, 0xeb,
	0xbe, 0xe9, 0xd8, 0xbc, 0xc5, 0x04, 0x69, 0xe1, 0x37, 0xeb, 0xd8, 0x63, 0xff, 0xe5, 0xc5, 0x07,
	0xab, 0x4e, 0xd5, 0xa1, 0x7f, 0xce, 0x93, 0xbf, 0x78, 0xe9, 0xa1, 0x2a, 0x76, 0xe6, 0xab, 0xd8,
	0x61, 0xa4, 0x96, 0x4d, 0xce, 0x4a, 0xf9, 0x3b, 0x3f, 0x0f, 0xf9, 0xf3, 0x4c, 0x06, 0x8b, 0x54,
	0x02, 0x97, 0x20, 0x63, 0x68, 0xbe, 0xb6, 0xa4, 0x79, 0x58, 0x96, 0x66, 0xa4, 0x93, 0xb9, 0x53,
	0x9f, 0x9b, 0xdb, 0x4e, 0x28, 0x73, 0xe7, 0x38, 0xc4, 0xa5, 0x01, 0x25, 0x80, 0x46, 0x15, 0x18,
	0x66, 0x4d, 0xe5, 0x14, 0xc5, 0x73, 0x72, 0x7b, 0x3c, 0x37, 0x69, 0xd1, 0xa5, 0x01, 0x85, 0x43,
	0xa2, 0xe7, 0x20, 0xbd, 0x66, 0xe2, 0x75, 0x79, 0x90, 0x62, 0x78, 0x6c, 0x7b, 0x0c, 0x77, 0x4c,
	0xbc, 0x7e, 0x69, 0x40, 0xa1, 0x50, 0xa4, 0x2f, 0x1e, 0x7e, 0xb5, 0x81, 0x6d, 0x1d, 0xcb, 0xe9,
	0xa4, 0x7d, 0xb9, 0xc9, 0x21, 0x48, 0x5f, 0x04, 0x34, 0xfa, 0x32, 0x0c, 0xf9, 0xda, 0x92, 0x85,
	0xe5, 0x21, 0x8a, 0xe6, 0xf1, 0xed, 0xd1, 0xdc, 0x22, 0xcd, 0x2f, 0x0d, 0x28, 0x0c, 0x0e, 0x2d,
	0x40, 0x96, 0x8c, 0xb4, 0x4a, 0x46, 0x4a, 0x1e, 0x4e, 0xca, 0xcb, 0x79, 0xbb, 0x51, 0xbb, 0xd5,
	0xac, 0x53, 0x5e, 0x30, 0xff, 0x1b, 0x5d, 0x05, 0xd0, 0x2c, 0x53, 0xf3, 0x18, 0xae, 0x11, 0x8a,
	0xeb, 0x89, 0xed, 0x71, 0x9d, 0x21, 0x30, 0x1c, 0x59, 0x56, 0x13, 0x1f, 0xe8, 0x45, 0x28, 0xea,
	0x4e, 0xad, 0xee, 0x78, 0xa6, 0x8f, 0x19, 0xc6, 0x0c, 0xc5, 0x38, 0xbf, 0x3d, 0xc6, 0xb3, 0x02,
	0x8e, 0x63, 0x2d, 0xe8, 0xd1, 0x02, 0x22, 0x7d, 0x31, 0x63, 0xe5, 0x6c, 0xd2, 0x1e, 0x5f, 0xe0,
	0x10, 0xa4, 0xc7, 0x02, 0x1a, 0x99, 0x50, 0xd0, 0x1d, 0xab, 0x51, 0xb3, 0xd5, 0x65, 0xad, 0x66,
	0x5a, 0x4d, 0xf9, 0x20, 0x45, 0x37, 0x97, 0x84, 0x45, 0x02, 0x76, 0x81, 0x42, 0x55, 0xd0, 0x46,
	0xab, 0x54, 0xac, 0x6b, 0x2e, 0xb6, 0xfd, 0x67, 0xcb, 0x74, 0x7c, 0xca, 0x97, 0x06, 0x94, 0xbc,
	0x1e, 0x69, 0x83, 0x7e, 0x01, 0x86, 0xd9, 0xb7, 0x3c, 0x91, 0x74, 0xd2, 0x32, 0x1a, 0x15, 0x79,
	0xa3, 0x55, 0x3a, 0x18, 0xc3, 0x3e, 0x3b, 0x43, 0x66, 0x23, 0xa1, 0xc1, 0x71, 0x22, 0x07, 0x0a,
	0x75, 0xd7, 0xac, 0x69, 0x6e, 0x53, 0xa5, 0x1b, 0x86, 0x7c, 0x28, 0x69, 0x47, 0x16, 0x19, 0xd8,
	0x02, 0x81, 0xda, 0x92, 0x54, 0xbe, 0x1e, 0x69, 0x89, 0x1a, 0x30, 0xea, 0x61, 0xdd, 0xb1, 0x8d,
	0x90, 0xe4, 0x24, 0x25, 0xf9, 0xb3, 0x49, 0x16, 0x02, 0x07, 0xdc, 0x9e, 0x68, 0xd1, 0x8b, 0xb5,
	0x25, 0x64, 0x7d, 0x5c, 0xab, 0x3b, 0x6e, 0x48, 0x56, 0x4e, 0x4a, 0xf6, 0x96, 0x00, 0x4c, 0x40,
	0xd6, 0x8f, 0xb5, 0x45, 0xbf, 0x23, 0x41, 0xa9, 0x61, 0x9b, 0xaf, 0x36, 0xb0, 0xba, 0x6e, 0xfa,
	0x2b, 0x4e, 0xc3, 0x67, 0xc4, 0xd5, 0x70, 0x77, 0x95, 0x0f, 0x53, 0x3e, 0xbe, 0xb4, 0x3d, 0x1f,
	0xb7, 0x29, 0xa2, 0x17, 0x18, 0x1e, 0x8a, 0xff, 0x6c, 0x80, 0xa5, 0xc7, 0x54, 0x3a, 0xda, 0xd8,
	0x02, 0x06, 0x7d, 0x57, 0x82, 0x27, 0xb6, 0xe1, 0x4e, 0x6d, 0xd8, 0x6b, 0x9a, 0x65, 0x1a, 0x9a,
	0x8f, 0x0d, 0xf9, 0x4f, 0xd9, 0xf6, 0xbb, 0xb0, 0x3b, 0x56, 0x6f, 0x87, 0x18, 0x7b, 0x70, 0xfd,
	0x78, 0x23, 0x19, 0x38, 0x72, 0x61, 0x4c, 0x5f, 0xc1, 0xfa, 0x6a, 0x54, 0x9c, 0x53, 0x94, 0xc7,
	0xa7, 0x12, 0xac, 0x12, 0x02, 0xb9, 0xad, 0x04, 0x47, 0xf5, 0x78, 0x33, 0xf4, 0x9b, 0x12, 0x1c,
	0xed, 0x24, 0x1a, 0x93, 0xd2, 0x9f, 0x30, 0x29, 0x3d, 0xb7, 0x63, 0x0e, 0xb6, 0x17, 0xcc, 0x94,
	0xde, 0x13, 0x02, 0xbd, 0x25, 0xc1, 0xa1, 0x65, 0xc7, 0xc5, 0x66, 0xd5, 0x56, 0x57, 0x71, 0x33,
	0x2a, 0x92, 0x23, 0x94, 0xa1, 0x9f, 0x4b, 0xb0, 0xd7, 0x31, 0xf8, 0x2b, 0xb8, 0xb9, 0xad, 0x5c,
	0x0e, 0x2e, 0x77, 0x69, 0x8b, 0xfe, 0x50, 0x82, 0x72, 0x77, 0x26, 0x62, 0x22, 0xfa, 0x33, 0x26,
	0xa2, 0x33, 0xf7, 0xc7, 0xd1, 0xf6, 0x72, 0x2a, 0x2d, 0x6f, 0x0d, 0x86, 0x9a, 0x50, 0xa0, 0x5a,
	0x50, 0xd5, 0x9d, 0x1a, 0xb1, 0x34, 0xe4, 0xa3, 0x49, 0xb7, 0x3d, 0x4a, 0xe3, 0x2c, 0x83, 0xaa,
	0x94, 0x37, 0x5a, 0xa5, 0xe9, 0x2e, 0x5b, 0xc1, 0xec, 0x8c, 0xd0, 0xd9, 0x74, 0x03, 0xf4, 0x23,
	0x30, 0x68, 0x0d, 0x0a, 0xae, 0xb3, 0xae, 0x5a, 0x78, 0x0d, 0x5b, 0xaa, 0xef, 0x5b, 0xf2, 0x31,
	0x4a, 0xfa, 0xc9, 0xed, 0x49, 0x2b, 0xce, 0xfa, 0x55, 0x02, 0x75, 0xeb, 0xd6, 0xd5, 0xca, 0xf1,
	0x76, 0xab, 0x94, 0x8b, 0x14, 0x74, 0x15, 0x43, 0xce, 0x15, 0x0d, 0x7c, 0x0b, 0x35, 0x61, 0x9c,
	0x75, 0xf9, 0x35, 0xc7, 0x26, 0xfd, 0x26, 0x26, 0x97, 0xdc, 0x4c, 0xba, 0x58, 0x28, 0xce, 0x97,
	0x1d, 0x1b, 0x9f, 0xa5, 0x80, 0x5b, 0x6e, 0x82, 0xa3, 0x7e, 0xbc, 0x31, 0xf2, 0x60, 0x9c, 0xed,
	0x2b, 0x51, 0xd2, 0xaf, 0x25, 0x25, 0x4d, 0xd7, 0x7f, 0x84, 0x74, 0x6c, 0xc8, 0x69, 0x25, 0x25,
	0x6a, 0xc6, 0x9b, 0xa1, 0x5f, 0x02, 0x60, 0xfd, 0x25, 0xe6, 0x9f, 0xfc, 0xb6, 0x94, 0xd4, 0x2a,
	0xa1, 0x9d, 0x21, 0xe6, 0x63, 0x65, 0xbe, 0xdd, 0x2a, 0x65, 0x83, 0xcf, 0x44, 0x43, 0x9d, 0xf5,
	0x45, 0x73, 0xf4, 0x0d, 0x09, 0x10, 0x63, 0xa0, 0xae, 0xb9, 0xbe, 0x49, 0xcc, 0x06, 0xd3, 0xae,
	0xca, 0xbf, 0xcc, 0x18, 0x39, 0x9d, 0x90, 0x91, 0xc5, 0x08, 0x6c, 0xe5, 0xf1, 0x76, 0xab, 0x34,
	0xbe, 0xa9, 0xb8, 0xeb, 0xd0, 0xb3, 0xb1, 0x8e, 0x36, 0x43, 0xef, 0x4b, 0x70, 0x80, 0x31, 0xc4,
	0x88, 0xa9, 0x96, 0xa3, 0xaf, 0x62, 0x43, 0x7e, 0x67, 0x67, 0x1c, 0x31, 0x8b, 0xf8, 0x2a, 0x85,
	0x8d, 0x70, 0x14, 0x2d, 0xde, 0x82, 0xa3, 0x68, 0x33, 0xf4, 0x06, 0x4c, 0x30, 0x86, 0x2c, 0x47,
	0xd7, 0x2c, 0xd3, 0x6f, 0xaa, 0x55, 0xcb, 0x59, 0xd2, 0x2c, 0xd9, 0xa6, 0x1c, 0x3d, 0x9d, 0x90,
	0xa3, 0xab, 0x1c, 0xfa, 0x22, 0x05, 0xee, 0xb1, 0x25, 0xb0, 0xae, 0xc7, 0x9b, 0x92, 0xbd, 0xfc,
	0x58, 0x07, 0x07, 0xc2, 0x1a, 0x72, 0x71, 0x95, 0x98, 0x89, 0x4e, 0xd2, 0xbd, 0x3c, 0xc6, 0x09,
	0xb7, 0x8d, 0x14, 0x8a, 0xa3, 0xd7, 0x5e, 0xee, 0xf7, 0x84, 0xa0, 0x66, 0x43, 0x07, 0x5f, 0xa1,
	0xd1, 0xc4, 0x39, 0xab, 0x27, 0x35, 0x1b, 0x62, 0x9c, 0x05, 0x26, 0xd4, 0x96, 0xbc, 0x1d, 0xf5,
	0xb7, 0x80, 0x41, 0xbf, 0x25, 0xc1, 0x74, 0x07, 0x77, 0x8c, 0x27, 0xcd, 0x52, 0x97, 0x9a, 0xaa,
	0xeb, 0xac, 0xcb, 0xaf, 0xde, 0x97, 0xd8, 0x14, 0x8e, 0xa5, 0xd2, 0x54, 0x9c, 0xf5, 0x44, 0x62,
	0x8b, 0x41, 0x20, 0x03, 0x72, 0xdc, 0x2a, 0xb7, 0xb5, 0x1a, 0x96, 0xa7, 0x29, 0x13, 0xb3, 0x49,
	0xed, 0xe5, 0xeb, 0x5a, 0x0d, 0x57, 0x0e, 0x6c, 0xb4, 0x4a, 0xa3, 0x82, 0x28, 0x2b, 0x27, 0x54,
	0x41, 0x0f, 0x9a, 0x44, 0xa8, 0xd0, 0xc3, 0x49, 0x69, 0x67, 0x54, 0xc8, 0x41, 0x64, 0x1b, 0x2a,
	0xf4, 0xac, 0xf2, 0xae, 0x04, 0x87, 0x39, 0x19, 0x03, 0x2f, 0x6b, 0x0d, 0xcb, 0x57, 0xf1, 0xdd,
	0xba, 0x8b, 0x3d, 0x8f, 0x0c, 0xfe, 0x0c, 0x25, 0xfa, 0x85, 0xa4, 0x44, 0xcf, 0x31, 0x0c, 0xe7,
	0x03, 0x04, 0xbd, 0x38, 0x98, 0xd4, 0xbb, 0xb7, 0x47, 0x1f, 0x48, 0x70, 0x84, 0xb3, 0xe3, 0xd8,
	0x6a, 0xa3, 0x4e, 0xd4, 0x68, 0x94, 0xa1, 0xe3, 0x94, 0xa1, 0x67, 0x93, 0x32, 0x74, 0xc3, 0xbe,
	0x4d, 0x51, 0x6c, 0xcf, 0x91, 0xac, 0xf7, 0x00, 0x40, 0x35, 0x28, 0x8a, 0xd3, 0xb0, 0xea, 0xac,
	0xdb, 0xd8, 0x95, 0xcb, 0x49, 0xcf, 0x89, 0x62, 0xcb, 0xbe, 0x41, 0xc0, 0x7a, 0x51, 0x2e, 0x78,
	0xd1, 0x56, 0x84, 0x1c, 0x17, 0x80, 0xb0, 0x19, 0x3e, 0x93, 0xfc, 0x58, 0x4a, 0xe0, 0x84, 0xd1,
	0xd0, 0x8b, 0x9c, 0x1e, 0x6d, 0x85, 0x6c, 0x18, 0x15, 0x73, 0xd9, 0xf1, 0x55, 0xbb, 0x61, 0x59,
	0xf2, 0xcf, 0xec, 0x8c, 0xde, 0x75, 0xc7, 0xbf, 0xde, 0xb0, 0xac, 0x6d, 0xe8, 0xf1, 0x56, 0xc8,
	0x25, 0xe7, 0x32, 0x21, 0xcd, 0x3a, 0x3d, 0x22, 0x9f, 0x48, 0x7e, 0x2e, 0xe3, 0x82, 0xa2, 0x70,
	0x95, 0x89, 0x8d, 0x56, 0x69, 0x5c, 0x10, 0x8c, 0x6a, 0xc7, 0x60, 0xbc, 0x58, 0x43, 0xb4, 0x0e,
	0xc0, 0xec, 0x02, 0xba, 0x5c, 0x4f, 0x26, 0xd5, 0xd0, 0x54, 0xe7, 0xd3, 0xd5, 0xfa, 0xd9, 0x8d,
	0x56, 0xe9, 0x84, 0xa0, 0x14, 0x3d, 0x90, 0x12, 0xad, 0x1c, 0x3d, 0xff, 0x51, 0xdd, 0x6c, 0x0a,
	0x38, 0xa2, 0x0a, 0x11, 0xa3, 0x1c, 0xd3, 0xcd, 0x9f, 0x4d, 0xaa, 0x08, 0x29, 0xce, 0x98, 0x6a,
	0xde, 0x11, 0x27, 0xcc, 0x1a, 0x8a, 0x29, 0xe7, 0x6f, 0x48, 0x30, 0xd9, 0x71, 0x2e, 0x66, 0xbc,
	0x69, 0x96, 0xfc, 0x39, 0xca, 0xd6, 0x33, 0x3b, 0x3d, 0x1f, 0x2f, 0x32, 0xf0, 0xca, 0x91, 0x8d,
	0x56, 0x69, 0x32, 0x1c, 0x8e, 0x4e, 0x66, 0x26, 0xbc, 0x6e, 0x50, 0xe8, 0x4d, 0x09, 0x0a, 0xe2,
	0x30, 0xc8, 0xa6, 0xfb, 0x13, 0x49, 0x4d, 0x64, 0x7e, 0x60, 0x63, 0xb3, 0x7d, 0x47, 0x82, 0xc9,
	0x9b, 0x11, 0x50, 0xa2, 0x9d, 0xf3, 0x82, 0x05, 0xea, 0x00, 0x99, 0x4d, 0x6a, 0x29, 0x73, 0x0e,
	0xa8, 0x17, 0xe4, 0xcc, 0x46, 0xab, 0xf4, 0x7c, 0x12, 0x06, 0x66, 0x67, 0xe2, 0x07, 0xfd, 0xd9,
	0x99, 0x70, 0xb1, 0xe4, 0xcc, 0x10, 0x23, 0xfa, 0x0d, 0x49, 0xcc, 0x5b, 0x6a, 0x5a, 0x3e, 0xb9,
	0xa3, 0x79, 0x4b, 0x2d, 0xcb, 0x0b, 0xc4, 0xb2, 0x0c, 0x3e, 0x37, 0x5a, 0xa5, 0xa7, 0xef, 0x87,
	0xc1, 0x70, 0x52, 0x53, 0x83, 0xf3, 0xef, 0x25, 0x38, 0x16, 0x39, 0x6f, 0xc5, 0x4f, 0xf4, 0x74,
	0x85, 0x9d, 0x4e, 0x7c, 0x30, 0x0d, 0xd0, 0x44, 0xcf, 0xe0, 0x74, 0xc9, 0x2d, 0x6e, 0xb4, 0x4a,
	0x57, 0x05, 0xb7, 0x5b, 0x1d, 0xf3, 0x67, 0x67, 0x3a, 0x8e, 0xb7, 0xb3, 0x33, 0xdd, 0x0e, 0x73,
	0xec, 0x58, 0xdb, 0x93, 0x1e, 0xfa, 0x07, 0x09, 0x50, 0xa4, 0x57, 0x62, 0x32, 0x7e, 0x3e, 0xe9,
	0x52, 0x0d, 0x29, 0x89, 0x19, 0x69, 0x6f, 0xb4, 0x4a, 0xaf, 0x24, 0x93, 0xf7, 0x1e, 0xf5, 0x6f,
	0x5c, 0xef, 0x64, 0x82, 0xd8, 0x50, 0x59, 0x32, 0x26, 0x5e, 0x5d, 0xd3, 0xb1, 0xfc, 0x5c, 0xd2,
	0x29, 0x74, 0x5d, 0x80, 0x54, 0x16, 0x36, 0x5a, 0xa5, 0xf3, 0x5b, 0x9e, 0x47, 0x66, 0x67, 0x84,
	0x13, 0x7c, 0x76, 0x86, 0x99, 0xdd, 0xb3, 0x33, 0x81, 0xcb, 0x75, 0x76, 0x46, 0x78, 0x72, 0xe9,
	0x2c, 0x0a, 0x58, 0x41, 0xbf, 0x26, 0xc1, 0x10, 0xd3, 0xa6, 0xcf, 0x27, 0x75, 0x2c, 0x33, 0x2d,
	0xba, 0xa7, 0x0c, 0x31, 0x16, 0xd0, 0xb7, 0x24, 0x18, 0x6d, 0x78, 0xd8, 0x25, 0x56, 0xf9, 0x9a,
	0x69, 0xe1, 0x2a, 0xf6, 0xe4, 0x2f, 0x25, 0xd5, 0x4a, 0xb7, 0x3d, 0xec, 0x2e, 0x06, 0x70, 0x7b,
	0xcb, 0x5f, 0xb1, 0x11, 0x43, 0x8e, 0xde, 0x91, 0xe0, 0x90, 0xb8, 0x66, 0xe0, 0xc6, 0xb0, 0x38,
	0xe7, 0x2e, 0x26, 0x75, 0xbe, 0x08, 0xe2, 0xcc, 0xa6, 0xe5, 0x87, 0xdd, 0x98, 0x2e, 0x15, 0x2d,
	0xa8, 0xff, 0xc5, 0xe8, 0xd2, 0x1c, 0xbd, 0x25, 0xc1, 0x44, 0xc8, 0x87, 0x43, 0xce, 0x7a, 0xd8,
	0xf7, 0x89, 0x6e, 0xfb, 0x4a, 0xd2, 0x23, 0x55, 0xc0, 0x86, 0x63, 0xe1, 0x9b, 0x0c, 0xb8, 0x37,
	0x17, 0x07, 0x8c, 0xcd, 0xad, 0x51, 0x03, 0xc6, 0x02, 0x1e, 0xc4, 0x7a, 0x55, 0x92, 0x9e, 0xf6,
	0x05, 0x76, 0xb1, 0x5a, 0x7b, 0x92, 0x1e, 0x35, 0xe2, 0x2d, 0xd1, 0xeb, 0x50, 0x08, 0xc8, 0xd2,
	0x8d, 0xf9, 0x66, 0x52, 0x85, 0x25, 0xd0, 0xd2, 0xbd, 0xf9, 0x44, 0xbb, 0x55, 0xca, 0x47, 0x4b,
	0x7a, 0x31, 0x90, 0x37, 0x22, 0x8d, 0xd0, 0x2b, 0x50, 0xe0, 0xc7, 0x6a, 0xd6, 0x56, 0x7e, 0x39,
	0x29, 0x75, 0x36, 0xd5, 0x16, 0x29, 0x54, 0xdc, 0x58, 0x63, 0x35, 0x94, 0x96, 0x17, 0x69, 0x44,
	0x2d, 0x5f, 0x46, 0x4b, 0x88, 0xf7, 0xab, 0x89, 0x2d, 0x5f, 0x5a, 0xd4, 0xd5, 0x14, 0x0d, 0xa9,
	0xf1, 0x9e, 0x08, 0xc1, 0xfe, 0xba, 0x04, 0x79, 0x41, 0x6f, 0xc5, 0xb4, 0x0c, 0xd9, 0x48, 0xaa,
	0x87, 0x39, 0x35, 0x02, 0x54, 0x79, 0x66, 0xa3, 0x55, 0x3a, 0x2d, 0x68, 0x75, 0x59, 0x56, 0xb3,
	0x33, 0x3d, 0xbd, 0x2a, 0x39, 0x2f, 0xc4, 0x83, 0xea, 0x30, 0x1a, 0xdc, 0x5b, 0xa9, 0x6b, 0x9a,
	0xd5, 0xc0, 0xf2, 0xdd, 0xa4, 0xbd, 0x17, 0xb4, 0xee, 0x10, 0xb0, 0xf8, 0xd4, 0x8a, 0xae, 0xee,
	0x02, 0x8e, 0xb6, 0x23, 0xd6, 0xa2, 0x1c, 0xbf, 0x91, 0x52, 0x35, 0xdf, 0x77, 0xd9, 0xf1, 0xef,
	0x5d, 0x29, 0xa9, 0x75, 0x16, 0xbb, 0x9c, 0x3a, 0xe3, 0xfb, 0x2e, 0x3d, 0x0a, 0x4e, 0x6d, 0xb4,
	0x4a, 0x87, 0x42, 0xeb, 0x3c, 0xd2, 0x84, 0x1a, 0x67, 0x7a, 0x37, 0xa0, 0x9e, 0x1c, 0x51, 0x2d,
	0xff, 0xde, 0xfd, 0x73, 0x44, 0x35, 0xfc, 0x4e, 0x39, 0xa2, 0x6a, 0xba, 0x06, 0x05, 0x71, 0x39,
	0xc6, 0xb8, 0xf8, 0x50, 0x4a, 0x3a, 0xff, 0xc5, 0x05, 0x1b, 0x25, 0x1e, 0x1b, 0x13, 0x51, 0x43,
	0x57, 0xc0, 0x72, 0xa4, 0x19, 0x7a, 0x03, 0x0e, 0x04, 0xe4, 0xd6, 0x1c, 0x4b, 0xf3, 0x4d, 0xcb,
	0xf4, 0x9b, 0xf2, 0xef, 0x32, 0xa2, 0x9f, 0x4f, 0x4e, 0xf4, 0x4e, 0x00, 0xdc, 0x9b, 0x34, 0x5a,
	0xde, 0xd4, 0x18, 0xfd, 0x62, 0x84, 0x01, 0x0b, 0x6b, 0xab, 0x6a, 0xdd, 0x75, 0x9c, 0x65, 0xf9,
	0xf7, 0x12, 0xfb, 0xd2, 0x04, 0x81, 0xab, 0x58, 0x5b, 0x5d, 0x24, 0xb0, 0xbd, 0xe9, 0x8f, 0x2f,
	0x77, 0xb6, 0x25, 0xe6, 0xc3, 0xd1, 0x50, 0xde, 0x0d, 0xcb, 0x52, 0x4d, 0xbb, 0xde, 0xf0, 0xd5,
	0x25, 0xbc, 0xa2, 0xad, 0x99, 0x8e, 0x2b, 0xff, 0x3e, 0x63, 0xe4, 0x8b, 0x3b, 0x10, 0x7f, 0xc3,
	0xb2, 0x16, 0x08, 0x92, 0x0a, 0xc7, 0xd1, 0x9b, 0xa1, 0xc3, 0xcb, 0xbd, 0x60, 0x62, 0xf3, 0x60,
	0xc9, 0x31, 0x9a, 0xf2, 0x1f, 0xec, 0x78, 0x1e, 0x54, 0x1c, 0xa3, 0x99, 0x60, 0x1e, 0xd0, 0x66,
	0x63, 0x50, 0xe4, 0xf1, 0x12, 0xaa, 0x63, 0x63, 0xd5, 0x59, 0x2e, 0x7f, 0x5b, 0x82, 0x21, 0x32,
	0x33, 0x6f, 0xa1, 0x39, 0x48, 0xd3, 0x15, 0xca, 0x18, 0x98, 0xea, 0x64, 0x00, 0xd7, 0xe6, 0x58,
	0x90, 0xc2, 0x2d, 0x85, 0xb6, 0x43, 0x6b, 0x30, 0xaa, 0x5b, 0x8e, 0x87, 0x0d, 0xb6, 0xa0, 0x4c,
	0xc3, 0x93, 0x53, 0x33, 0x83, 0x27, 0x0b, 0x95, 0xeb, 0xed, 0x56, 0xa9, 0x70, 0x96, 0x56, 0x11,
	0xcc, 0x0b, 0xe7, 0xbc, 0x4f, 0x5a, 0xa5, 0x2f, 0x54, 0x4d, 0x7f, 0xa5, 0xb1, 0x34, 0xa7, 0x3b,
	0xb5, 0xf9, 0x00, 0xb3, 0xb1, 0x14, 0xfe, 0x3d, 0x5f, 0x5f, 0xad, 0xce, 0x8b, 0xb0, 0x0a, 0x5d,
	0xf3, 0x4d, 0x63, 0xee, 0x1c, 0xf6, 0xf4, 0x85, 0x73, 0x4a, 0x41, 0x0f, 0x71, 0x19, 0x5e, 0xb9,
	0x9d, 0x06, 0x88, 0xb8, 0x35, 0x5e, 0x82, 0x34, 0xbe, 0x5b, 0x77, 0x29, 0xdb, 0xd9, 0xca, 0xf9,
	0x4f, 0x5a, 0xa5, 0x33, 0x89, 0x49, 0xc5, 0xa2, 0x33, 0xe6, 0x42, 0xa4, 0x0a, 0x45, 0x89, 0xea,
	0x50, 0x68, 0x78, 0xd8, 0xeb, 0xec, 0xdf, 0xd5, 0x76, 0xab, 0x94, 0xbb, 0xed, 0x61, 0x6f, 0x4f,
	0x7a, 0x97, 0x6b, 0x08, 0x4c, 0x86, 0x87, 0x5e, 0x87, 0x71, 0x4a, 0x31, 0x70, 0x2d, 0x10, 0xaa,
	0x83, 0x94, 0xea, 0x62, 0xbb, 0x55, 0x1a, 0x25, 0x54, 0xc5, 0x4e, 0xbf, 0x6b, 0xca, 0xc4, 0x54,
	0x0c, 0xb1, 0x19, 0x1e, 0xb1, 0x65, 0x27, 0x5c, 0xbc, 0x8c, 0x5d, 0x52, 0x60, 0xf0, 0x53, 0x24,
	0x65, 0x21, 0x4d, 0x59, 0xb8, 0xd3, 0x6e, 0x95, 0x0e, 0x28, 0x41, 0x03, 0x76, 0xbc, 0x63, 0x6c,
	0x7c, 0xf1, 0x3e, 0xd8, 0x10, 0xf0, 0xca, 0x01, 0xb7, 0x13, 0x67, 0x44, 0x14, 0xc1, 0xf2, 0x20,
	0x7c, 0x0c, 0xc5, 0x45, 0x21, 0x26, 0xfa, 0xde, 0x88, 0x22, 0xc0, 0x66, 0x78, 0xe5, 0x6f, 0x0f,
	0xc1, 0x30, 0x3f, 0xbe, 0xea, 0x90, 0x61, 0xde, 0x5b, 0xd3, 0xa0, 0x93, 0xac, 0x50, 0xb9, 0xd4,
	0x6e, 0x95, 0x46, 0xa8, 0xf6, 0x5d, 0x38, 0xb7, 0x3b, 0xba, 0x23, 0x14, 0xf3, 0x82, 0x81, 0x56,
	0x20, 0x1b, 0x88, 0x9b, 0x46, 0xdb, 0x14, 0x2a, 0x57, 0xda, 0xad, 0x52, 0x46, 0xc8, 0x68, 0xb7,
	0x22, 0xce, 0xe8, 0x5c, 0xb0, 0xe8, 0x08, 0x64, 0x4d, 0x4f, 0x5d, 0x31, 0x0d, 0x03, 0xdb, 0x34,
	0x2a, 0x27, 0xa3, 0x64, 0x4c, 0xef, 0x12, 0xfd, 0x46, 0x8f, 0xc3, 0xa8, 0xe9, 0xa9, 0xa6, 0xad,
	0xe9, 0x3a, 0x59, 0x09, 0x4b, 0x16, 0x0b, 0xbb, 0xc9, 0x28, 0x45, 0xd3, 0x5b, 0x88, 0x94, 0x12,
	0x8d, 0x3a, 0x55, 0xc5, 0x36, 0x76, 0x35, 0x1f, 0x1b, 0xaa, 0xe6, 0xa9, 0xa6, 0x81, 0x6d, 0xdf,
	0xf4, 0x9b, 0x4c, 0xcb, 0x0f, 0xd1, 0x1e, 0x28, 0x9f, 0xb4, 0x4a, 0xd7, 0xef, 0x73, 0x31, 0x5e,
	0x14, 0xc8, 0xcf, 0x78, 0x0b, 0x1c, 0x35, 0x59, 0x24, 0xca, 0x64, 0xb5, 0x7b, 0x05, 0x5a, 0x84,
	0x13, 0xdd, 0x19, 0xea, 0x74, 0xd3, 0x0d, 0x93, 0x8d, 0x42, 0x39, 0xde, 0x05, 0x4f, 0xdc, 0x2f,
	0x87, 0xbe, 0x2e, 0xc1, 0x58, 0xbd, 0x4a, 0x2d, 0x05, 0x73, 0xa9, 0xe1, 0x63, 0xd5, 0x6e, 0xd4,
	0x68, 0xb4, 0x4e, 0xa1, 0xf2, 0x42, 0xbb, 0x55, 0x2a, 0x2e, 0x56, 0xcf, 0x88, 0xaa, 0xeb, 0x8d,
	0xda, 0x8e, 0x36, 0x9e, 0x70, 0x84, 0x16, 0x2f, 0x46, 0x91, 0x28, 0xc5, 0x7a, 0x0c, 0x29, 0x3a,
	0x09, 0x63, 0xa6, 0xa7, 0x7a, 0x4d, 0xcf, 0xc7, 0x35, 0xe1, 0xd6, 0xc9, 0x88, 0x11, 0xb9, 0x49,
	0x8b, 0xb9, 0xd7, 0xe5, 0xbb, 0x43, 0x00, 0xa1, 0xcb, 0xbc, 0x6f, 0xb3, 0x96, 0xc5, 0xf3, 0x74,
	0xcc, 0x5a, 0x16, 0x8a, 0x73, 0xdf, 0xb3, 0x56, 0x80, 0x2b, 0x19, 0x86, 0xbd, 0x73, 0x7d, 0x0c,
	0x3e, 0xc8, 0xf5, 0xf1, 0x12, 0x8c, 0xe2, 0xda, 0x12, 0x36, 0x0c, 0xa1, 0xd8, 0x7c, 0x1e, 0x79,
	0x96, 0x24, 0x64, 0x8c, 0x28, 0xd2, 0x4a, 0xe6, 0x5e, 0xab, 0x34, 0xf0, 0x51, 0xab, 0x24, 0x29,
	0x05, 0x81, 0x89, 0x69, 0xd8, 0xcf, 0x40, 0xce, 0xf4, 0xa8, 0xf9, 0x11, 0x44, 0xa2, 0x65, 0x2a,
	0x29, 0x59, 0x52, 0xc0, 0xf4, 0xae, 0xf3, 0x52, 0x74, 0x03, 0xf2, 0xc4, 0x64, 0x6c, 0xf0, 0xfb,
	0x02, 0x1e, 0x6a, 0x96, 0xe0, 0xbe, 0x24, 0xa2, 0xbe, 0x72, 0x1c, 0x03, 0x29, 0x42, 0xc7, 0x00,
	0x4c, 0x4f, 0x5d, 0x33, 0x5d, 0xbf, 0xa1, 0x59, 0x74, 0xfe, 0x66, 0x94, 0xac, 0xe9, 0xdd, 0x61,
	0x05, 0xa8, 0x01, 0x87, 0x85, 0x49, 0xa0, 0xbb, 0x58, 0xa3, 0x5b, 0x6d, 0x0d, 0xfb, 0x1a, 0x3d,
	0x12, 0xe6, 0x92, 0xde, 0x9b, 0xf0, 0x08, 0xc4, 0xb3, 0x1c, 0xc3, 0x35, 0x8e, 0x40, 0x99, 0xc4,
	0xdd, 0x2b, 0x2e, 0xa7, 0x33, 0x99, 0xb1, 0xec, 0xe5, 0x74, 0x26, 0x3b, 0x06, 0x97, 0xd3, 0x19,
	0x18, 0xcb, 0x95, 0xff, 0x47, 0x82, 0x7c, 0x34, 0xda, 0x6b, 0xbf, 0x4d, 0x61, 0x04, 0x69, 0x6a,
	0xe9, 0x0f, 0xd2, 0xfd, 0x87, 0xfe, 0x5d, 0xfe, 0xe1, 0x08, 0x0c, 0xb1, 0xc8, 0xa7, 0xbe, 0x74,
	0xd6, 0x80, 0x0c, 0x73, 0x6f, 0x06, 0x7d, 0x5d, 0x20, 0x44, 0x28, 0x07, 0x94, 0xc8, 0xb3, 0xf7,
	0x41, 0x84, 0x43, 0x2b, 0x23, 0x14, 0x75, 0xa0, 0x61, 0x58, 0x4c, 0x92, 0x0c, 0x42, 0xc3, 0x30,
	0xdf, 0x20, 0x2a, 0xd1, 0x35, 0x60, 0xda, 0x6b, 0xd8, 0xf5, 0xb1, 0x41, 0x27, 0x58, 0x86, 0xcc,
	0xff, 0x05, 0x5e, 0x82, 0x2e, 0x43, 0xc6, 0x5b, 0xd1, 0x5c, 0xc3, 0xb4, 0xab, 0x72, 0xbe, 0xab,
	0x2d, 0x2c, 0x42, 0x71, 0x99, 0xa2, 0xb8, 0x49, 0x1a, 0x63, 0x83, 0x74, 0xd5, 0x35, 0xeb, 0xbe,
	0xe3, 0x2a, 0x01, 0x3c, 0x3a, 0x05, 0x13, 0xa6, 0xc7, 0xa6, 0x35, 0x36, 0xc8, 0x72, 0xb2, 0x4c,
	0xdd, 0xf4, 0xad, 0xa6, 0x5c, 0xa0, 0x64, 0x0f, 0x98, 0xde, 0x59, 0x56, 0x77, 0x3e, 0xa8, 0x42,
	0x77, 0xa1, 0x10, 0xf1, 0x9f, 0x9a, 0x86, 0x5c, 0xa4, 0x82, 0xba, 0xd9, 0x6e, 0x95, 0xf2, 0xa1,
	0x9b, 0x92, 0x4a, 0xeb, 0xcb, 0xf7, 0xb5, 0xe3, 0x84, 0x28, 0x94, 0x7c, 0x48, 0x69, 0xc1, 0xe0,
	0xca, 0x57, 0x77, 0x6c, 0xbd, 0xe1, 0x12, 0x43, 0x9e, 0x87, 0x49, 0xd2, 0xad, 0xfe, 0x6c, 0xa4,
	0x14, 0xad, 0xc3, 0xa8, 0xe7, 0x34, 0x5c, 0x62, 0x1e, 0x8a, 0xd1, 0x9c, 0xa0, 0x4c, 0xde, 0x20,
	0x96, 0xf7, 0x4d, 0x5a, 0xb5, 0x37, 0x63, 0x5a, 0xf0, 0x22, 0xc8, 0x0c, 0xf4, 0xa6, 0x04, 0xa8,
	0x23, 0x2c, 0x90, 0x10, 0x3f, 0xc4, 0xb4, 0x7d, 0xbb, 0x55, 0x1a, 0x8b, 0x7b, 0xdc, 0x77, 0x4d,
	0x7f, 0x2c, 0x1e, 0x1f, 0xb8, 0x60, 0xa0, 0xb3, 0x00, 0x55, 0xec, 0x08, 0x67, 0x21, 0x8b, 0x49,
	0x9c, 0x8e, 0x4c, 0x90, 0x2a, 0x76, 0xc8, 0x3f, 0x16, 0xcd, 0xcd, 0x9d, 0x82, 0xe9, 0x7b, 0x64,
	0x33, 0xce, 0x56, 0xb1, 0xc3, 0xdd, 0x7e, 0x27, 0xa1, 0x48, 0x36, 0x62, 0xc7, 0x57, 0xd7, 0x4c,
	0x66, 0xe5, 0x4c, 0x06, 0x7b, 0x71, 0xde, 0xf4, 0xae, 0x3b, 0xfe, 0x1d, 0x56, 0x8e, 0xca, 0x90,
	0x37, 0x6d, 0xda, 0x88, 0x9d, 0x98, 0x0f, 0xcf, 0x48, 0x27, 0x49, 0x9b, 0x48, 0xd9, 0xe5, 0x74,
	0x66, 0x70, 0x2c, 0x7d, 0x39, 0x9d, 0x49, 0x8f, 0x0d, 0x5d, 0x4e, 0x67, 0x86, 0xc6, 0x86, 0x2f,
	0xa7, 0x33, 0xc3, 0x63, 0x23, 0x97, 0xd3, 0x99, 0x91, 0xb1, 0x4c, 0x79, 0x05, 0xf2, 0x51, 0xa7,
	0x39, 0x7a, 0x11, 0x8a, 0x81, 0x7e, 0x61, 0x81, 0x95, 0x52, 0x52, 0xf5, 0xc2, 0xe2, 0x29, 0xbb,
	0xa8, 0x17, 0x76, 0xbd, 0xf1, 0xd7, 0x29, 0x28, 0xc6, 0x3d, 0xf2, 0x0f, 0x8e, 0x18, 0x7a, 0x01,
	0x82, 0x02, 0xa6, 0xa7, 0x06, 0x77, 0xae, 0xa7, 0xf8, 0xc0, 0xe4, 0x05, 0x22, 0xaa, 0xae, 0xde,
	0x91, 0x00, 0xb9, 0x98, 0xad, 0x59, 0x55, 0x4c, 0x73, 0x83, 0xea, 0x60, 0x66, 0x77, 0x4d, 0x28,
	0xbc, 0x76, 0x2f, 0x27, 0xfa, 0x98, 0x1b, 0x47, 0x6a, 0x10, 0x75, 0x54, 0x8c, 0xcf, 0xe6, 0x07,
	0x28, 0xcd, 0xe7, 0xe1, 0x08, 0xd9, 0x32, 0x3d, 0xd3, 0xae, 0x46, 0x22, 0x57, 0xb0, 0xad, 0x3b,
	0x74, 0x1f, 0x4c, 0xd1, 0x6d, 0x40, 0x36, 0xbd, 0xdb, 0xa4, 0x45, 0x30, 0xc6, 0xe7, 0x79, 0x3d,
	0xba, 0xc0, 0xcf, 0xc0, 0xf7, 0x3f, 0x06, 0x14, 0xbe, 0xfc, 0xbd, 0x14, 0x4c, 0x74, 0xbd, 0x14,
	0xdd, 0x4f, 0xea, 0xe9, 0xab, 0x7b, 0x31, 0x73, 0xc3, 0x91, 0x8c, 0xcd, 0x5e, 0x6e, 0xca, 0xfc,
	0x54, 0x82, 0x7c, 0xd4, 0x4d, 0x8d, 0x96, 0x21, 0xcb, 0x3d, 0xc2, 0x81, 0xfc, 0x48, 0xd7, 0x32,
	0xac, 0xd1, 0x6e, 0x05, 0x98, 0x61, 0xb8, 0x17, 0x0c, 0xf4, 0x06, 0x20, 0xe6, 0x04, 0x52, 0x03,
	0xd7, 0x7e, 0x20, 0xcb, 0xaf, 0x90, 0xfd, 0x99, 0xf1, 0x23, 0xdc, 0xf2, 0xbb, 0x25, 0x3c, 0x56,
	0x8f, 0xa3, 0x33, 0xca, 0x3f, 0x91, 0x20, 0x17, 0xf1, 0x62, 0x53, 0x27, 0x11, 0xf9, 0x43, 0x75,
	0x96, 0x5e, 0xc1, 0xba, 0x1f, 0x76, 0x9f, 0x39, 0x89, 0x48, 0xd5, 0x0d, 0x5a, 0xb3, 0x5b, 0x56,
	0x0a, 0x7a, 0x04, 0x97, 0x11, 0x17, 0x78, 0xea, 0x81, 0x09, 0xbc, 0xfc, 0x63, 0x09, 0x32, 0xe2,
	0xd8, 0x88, 0x2c, 0xc8, 0x45, 0x1c, 0x37, 0xbc, 0xa3, 0xc4, 0x9a, 0x84, 0xd0, 0x67, 0xb3, 0x3b,
	0xc2, 0xe0, 0x05, 0xee, 0x1a, 0x74, 0x1c, 0xf2, 0x2e, 0xf6, 0x7c, 0xcd, 0x65, 0x77, 0xd7, 0xb4,
	0x97, 0x83, 0x4a, 0x8e, 0x97, 0xbd, 0x60, 0xfa, 0x2b, 0xe4, 0xf4, 0xd8, 0xa0, 0x17, 0x6c, 0x91,
	0x66, 0xec, 0xc8, 0x5f, 0x6c, 0x78, 0x58, 0x89, 0xb4, 0x3c, 0x0e, 0x79, 0xd3, 0x53, 0x03, 0x6d,
	0xcb, 0xcd, 0xb6, 0x9c, 0xe9, 0x05, 0x5b, 0x60, 0xf9, 0x5b, 0x12, 0x51, 0x2f, 0xb1, 0x13, 0x72,
	0x7f, 0x3b, 0x3c, 0x06, 0x83, 0xab, 0xb8, 0x49, 0xfb, 0x99, 0x55, 0xc8, 0x9f, 0xe8, 0x20, 0x0c,
	0xb1, 0x1b, 0x0d, 0x66, 0x53, 0xb3, 0x8f, 0xf2, 0xdf, 0xa4, 0xa0, 0x10, 0x8b, 0x58, 0xea, 0x33,
	0x9f, 0xd1, 0xbd, 0x32, 0xd5, 0x17, 0x87, 0xd1, 0x83, 0x3c, 0x10, 0x13, 0xa5, 0x30, 0xd9, 0x23,
	0x2c, 0x6e, 0xbf, 0xf9, 0xc6, 0x1e, 0xa4, 0x6a, 0x28, 0x7f, 0x3f, 0x05, 0x72, 0xaf, 0x68, 0xbe,
	0x47, 0x82, 0xdc, 0x81, 0x20, 0xff, 0x6d, 0x18, 0xd2, 0x77, 0x4c, 0xbc, 0x8e, 0xbe, 0x06, 0x23,
	0x6b, 0x26, 0x5e, 0x0f, 0x65, 0x76, 0xb1, 0xdd, 0x2a, 0x0d, 0x93, 0xaa, 0xdd, 0x8a, 0x6c, 0x98,
	0xe0, 0x5d, 0x30, 0x1e, 0xe2, 0x0d, 0x80, 0x8b, 0x2d, 0x2d, 0x70, 0x7b, 0x77, 0xdc, 0x00, 0x28,
	0xbc, 0x6e, 0x6f, 0xdc, 0xde, 0x01, 0x36, 0xc3, 0x43, 0x6b, 0x80, 0x96, 0x1d, 0x77, 0x5d, 0x73,
	0x0d, 0x35, 0xf0, 0xc9, 0x33, 0xef, 0x7f, 0xa2, 0x10, 0x12, 0x22, 0xfa, 0xb9, 0xe0, 0x82, 0xa0,
	0x32, 0xd1, 0x6e, 0x95, 0xc6, 0x2f, 0x30, 0x7c, 0x41, 0xa9, 0xa7, 0x8c, 0x2f, 0x77, 0x16, 0x25,
	0x50, 0x3f, 0xfc, 0x74, 0x5c, 0xd3, 0x7c, 0xec, 0x9a, 0x9a, 0x65, 0xbe, 0x16, 0x38, 0x0f, 0x8a,
	0xa6, 0x77, 0x2d, 0x52, 0x3a, 0xf5, 0x17, 0x29, 0xc8, 0x06, 0xa8, 0xd1, 0xcb, 0x30, 0xe4, 0x3b,
	0xe1, 0x0c, 0x39, 0xdf, 0x6e, 0x95, 0xd2, 0xb7, 0x9c, 0xdd, 0xce, 0x8f, 0xb4, 0xef, 0xf4, 0xcd,
	0x5e, 0x5d, 0x05, 0x88, 0xdc, 0xc4, 0x0c, 0x06, 0x13, 0x30, 0xbb, 0x67, 0xf7, 0x2f, 0x59, 0xb1,
	0x6e, 0xbd, 0x67, 0xd3, 0x3f, 0xfe, 0xb0, 0x24, 0x95, 0xdf, 0x97, 0x60, 0x88, 0x6e, 0x3d, 0xfd,
	0xd9, 0x97, 0x12, 0x18, 0x1f, 0xff, 0x98, 0x86, 0xa3, 0x5b, 0x45, 0x97, 0xf5, 0x87, 0xd1, 0x4d,
	0xbe, 0xa1, 0x54, 0xbf, 0x7c, 0x43, 0xfd, 0x9c, 0x04, 0xe8, 0x25, 0xc8, 0xd6, 0x5d, 0x6c, 0x98,
	0xba, 0xe6, 0x8b, 0x67, 0xd7, 0x3b, 0xdb, 0xb9, 0x0b, 0x84, 0xb3, 0x45, 0x81, 0x42, 0x09, 0xb1,
	0xa1, 0xf7, 0x24, 0x98, 0x14, 0x6b, 0x46, 0x5d, 0x76, 0x5c, 0x95, 0xbf, 0x31, 0x33, 0x1d, 0x9b,
	0x5f, 0x1a, 0xdd, 0x69, 0xb7, 0x4a, 0x07, 0xf9, 0x22, 0xb8, 0xe0, 0xb8, 0x77, 0x82, 0xfa, 0x5d,
	0xae, 0xa7, 0x83, 0x7c, 0x3d, 0xc5, 0x70, 0x96, 0x3f, 0x1a, 0x84, 0xc7, 0x13, 0x3e, 0xbe, 0x7c,
	0x34, 0xc5, 0x3e, 0x15, 0x53, 0xac, 0xfc, 0xf6, 0x10, 0x8c, 0x76, 0x84, 0x9a, 0x3e, 0x1a, 0xba,
	0x3d, 0x1c, 0xba, 0x4d, 0xb6, 0x5d, 0x7a, 0xef, 0x6c, 0x3b, 0xf4, 0x0c, 0xc8, 0xcb, 0xae, 0x53,
	0x53, 0x57, 0x34, 0x6f, 0x45, 0xf5, 0x98, 0x6b, 0x5f, 0xdc, 0x7b, 0xd2, 0xfb, 0x32, 0x65, 0x82,
	0xd4, 0x5f, 0xd2, 0xbc, 0x15, 0xee, 0xf8, 0xe7, 0xb7, 0xf4, 0x5b, 0x6d, 0x2c, 0xc3, 0x0f, 0x61,
	0x63, 0xf9, 0xde, 0x20, 0x4c, 0xf5, 0x7e, 0xaf, 0xfc, 0x68, 0x42, 0x7e, 0x4a, 0x26, 0x64, 0xf9,
	0x5f, 0x33, 0x70, 0xb0, 0x5b, 0x9c, 0xfa, 0xa3, 0x11, 0xdc, 0xc3, 0x11, 0x7c, 0x4b, 0x82, 0x48,
	0x0c, 0x90, 0x1a, 0xc8, 0x35, 0x1d, 0x5c, 0x2c, 0x8d, 0x87, 0x61, 0x47, 0x7b, 0x22, 0xe1, 0x71,
	0xb7, 0x03, 0x9f, 0xb1, 0x45, 0xf4, 0xd3, 0x50, 0xff, 0xa3, 0x9f, 0x56, 0x61, 0x2c, 0x7c, 0x37,
	0xa8, 0xe9, 0xc1, 0x36, 0x56, 0xdc, 0x1c, 0x46, 0x8c, 0x6b, 0x73, 0x41, 0x16, 0xa2, 0xc8, 0xfb,
	0xff, 0x33, 0x2c, 0xea, 0x0f, 0xb5, 0x5b, 0xa5, 0xa2, 0x70, 0x38, 0xb0, 0x32, 0xa5, 0xe8, 0xc4,
	0xbe, 0x39, 0x31, 0x03, 0x5b, 0x38, 0x24, 0x36, 0xb2, 0x0b, 0x62, 0xe7, 0x28, 0xa6, 0x90, 0x58,
	0xf4, 0x1b, 0xbd, 0x0e, 0x53, 0x61, 0x28, 0xee, 0x2a, 0x6e, 0x92, 0x23, 0x9d, 0xbe, 0xa2, 0xd6,
	0xb0, 0xbf, 0xe2, 0x18, 0x34, 0xb6, 0xa5, 0x78, 0xaa, 0xbc, 0x25, 0xd9, 0x6b, 0x04, 0xa0, 0x72,
	0xa4, 0xdd, 0x2a, 0x4d, 0x06, 0xe1, 0xb6, 0x57, 0x70, 0x93, 0x16, 0x5f, 0xa3, 0x68, 0x94, 0x49,
	0xbd, 0x7b, 0xc5, 0x96, 0x6a, 0x22, 0xfb, 0x10, 0xd4, 0xc4, 0x3f, 0x8f, 0x40, 0x69, 0x9b, 0x9c,
	0x0d, 0x8f, 0x76, 0x9a, 0x47, 0x3b, 0xcd, 0xa3, 0x9d, 0xe6, 0xd3, 0xb6, 0xd3, 0x94, 0x7f, 0x25,
	0x05, 0x19, 0xf1, 0x48, 0x02, 0x7d, 0x0d, 0x46, 0xb8, 0x0b, 0x31, 0xea, 0xa9, 0x64, 0xde, 0xc3,
	0x5d, 0x7a, 0x2a, 0x7d, 0xea, 0x38, 0x44, 0x75, 0x28, 0x68, 0xae, 0xab, 0x35, 0x85, 0xab, 0x92,
	0xaf, 0x5f, 0xea, 0xa9, 0x3c, 0x43, 0x2a, 0xf6, 0x82, 0x58, 0x4e, 0x0b, 0x30, 0x19, 0xe8, 0x31,
	0xe6, 0x90, 0x6b, 0x58, 0xbe, 0x29, 0x72, 0x2c, 0xb0, 0xbb, 0xa5, 0x82, 0xe9, 0x5d, 0x23, 0xa5,
	0xec, 0xa5, 0x55, 0xf9, 0x9e, 0x04, 0xd9, 0xe0, 0xfd, 0x4a, 0x1f, 0x24, 0xd1, 0x25, 0x80, 0x2f,
	0xb5, 0x37, 0x01, 0x7c, 0xe5, 0x8f, 0x25, 0x28, 0xc4, 0x5e, 0x78, 0xec, 0xc7, 0x81, 0x2d, 0xff,
	0xad, 0x04, 0xc3, 0xec, 0x9e, 0xb4, 0x6f, 0xf7, 0xd6, 0x09, 0xfc, 0xbf, 0x2c, 0xaa, 0xac, 0xde,
	0x58, 0xb2, 0x4c, 0x9d, 0x7b, 0x7e, 0x33, 0xa6, 0xb7, 0x48, 0xbf, 0x3b, 0x62, 0x1c, 0xf3, 0x1d,
	0x31, 0x8e, 0xe5, 0xbb, 0x90, 0x11, 0x77, 0xd4, 0xc8, 0x82, 0x5c, 0xf4, 0x6e, 0x3c, 0x72, 0x17,
	0xb8, 0x57, 0xb7, 0xe2, 0x60, 0x84, 0xf7, 0xe1, 0xff, 0x9e, 0x82, 0x6c, 0xf0, 0x08, 0xb5, 0xbf,
	0xb4, 0xfb, 0x75, 0x07, 0x8e, 0x5c, 0x28, 0x18, 0x41, 0xf4, 0x5d, 0x78, 0x1d, 0x79, 0x8d, 0x3e,
	0x0c, 0x0c, 0x2a, 0x76, 0x4b, 0x2f, 0x1f, 0xd2, 0x88, 0x04, 0x53, 0xa6, 0x23, 0xc1, 0x94, 0xdf,
	0x94, 0x60, 0x88, 0xdd, 0xf7, 0x6e, 0xe2, 0x48, 0x7a, 0xf0, 0x1c, 0x1d, 0x14, 0xef, 0x80, 0xd9,
	0xfd, 0x34, 0xfb, 0x28, 0xff, 0x44, 0x82, 0x62, 0xfc, 0x61, 0xed, 0x43, 0x61, 0xee, 0x08, 0x64,
	0xe9, 0xbb, 0x60, 0x2a, 0x33, 0xc6, 0x60, 0x86, 0x14, 0xd0, 0xc7, 0x61, 0xd3, 0x00, 0x91, 0xf7,
	0xc2, 0x64, 0xf0, 0xd2, 0x4a, 0xa4, 0x04, 0x7d, 0x0e, 0xc6, 0xd7, 0x4d, 0x7f, 0x45, 0xad, 0xba,
	0x9a, 0xed, 0x8b, 0x28, 0xfa, 0x34, 0x6d, 0x36, 0x4a, 0x2a, 0x2e, 0x92, 0x72, 0x16, 0x11, 0x50,
	0x7e, 0x0d, 0x0e, 0x74, 0xc9, 0x31, 0xd4, 0x17, 0x13, 0xb6, 0xfc, 0x75, 0x09, 0xa6, 0x7a, 0xa7,
	0x15, 0xea, 0x0f, 0x0f, 0xff, 0x99, 0x82, 0xa3, 0x5b, 0x25, 0x10, 0xea, 0x8f, 0x31, 0xff, 0x26,
	0xb5, 0x72, 0xe9, 0xab, 0xea, 0xf0, 0xed, 0x67, 0x3c, 0x10, 0x88, 0xb1, 0x23, 0x0c, 0x94, 0x5d,
	0x07, 0x02, 0xb9, 0x71, 0x74, 0x64, 0xf3, 0xc9, 0x71, 0x0e, 0xc2, 0xa0, 0xe7, 0x5d, 0xbd, 0xce,
	0x62, 0x0c, 0x93, 0x09, 0xab, 0x80, 0x1b, 0xfc, 0x4d, 0x16, 0xfd, 0x54, 0xef, 0xa4, 0x48, 0xfd,
	0x11, 0x77, 0x11, 0x52, 0x9a, 0xc7, 0x97, 0x55, 0x4a, 0xf3, 0xca, 0x7f, 0x99, 0x82, 0xf1, 0x4d,
	0x29, 0x4f, 0xf6, 0x53, 0x08, 0x9d, 0x06, 0xf9, 0x58, 0x22, 0x98, 0xc1, 0xae, 0xaf, 0x38, 0xe3,
	0x71, 0xda, 0x51, 0x59, 0x84, 0xdb, 0x5c, 0xd4, 0xef, 0x16, 0x45, 0x59, 0xfe, 0x2b, 0x09, 0xa2,
	0xf9, 0xfa, 0xfa, 0x23, 0xbd, 0x3b, 0x9d, 0xb9, 0x06, 0xbb, 0xe7, 0x3d, 0x8e, 0x77, 0x2c, 0x9a,
	0x66, 0x30, 0xec, 0x4d, 0x34, 0x97, 0x60, 0xf9, 0xbf, 0x24, 0xf1, 0x36, 0x87, 0x6e, 0xb8, 0xfb,
	0x2c, 0xd8, 0xa3, 0xdb, 0xc3, 0x86, 0xff, 0x90, 0x20, 0x1b, 0x26, 0x25, 0xd9, 0x47, 0x53, 0xbf,
	0x5b, 0x67, 0xdf, 0x4f, 0xc1, 0x54, 0xef, 0x14, 0x30, 0xfb, 0xdd, 0x7f, 0xd3, 0xcd, 0x14, 0x7b,
	0x4f, 0x82, 0x7c, 0x34, 0xf3, 0x67, 0x7f, 0x64, 0x20, 0xc3, 0x88, 0x48, 0xf0, 0xc0, 0x36, 0x63,
	0xf1, 0x59, 0xfe, 0x6d, 0x09, 0x46, 0x3b, 0x32, 0x65, 0xf4, 0xd9, 0x18, 0xef, 0xcd, 0xdb, 0x37,
	0x25, 0x28, 0xc4, 0xd2, 0x4c, 0xf4, 0xed, 0xd4, 0xd5, 0x9b, 0xa7, 0xff, 0x95, 0x20, 0x1f, 0x4d,
	0x4b, 0xb5, 0x9f, 0x56, 0x70, 0xa4, 0xd7, 0x83, 0xf1, 0x5e, 0xff, 0x5f, 0x8a, 0x1c, 0xef, 0xa3,
	0x59, 0xe5, 0xf6, 0xd9, 0x4e, 0xdd, 0xb3, 0xeb, 0xdd, 0xdf, 0xba, 0xa6, 0xfb, 0xfa, 0xd6, 0x95,
	0xd8, 0xce, 0x85, 0x58, 0x2a, 0xbe, 0xfd, 0x26, 0xfe, 0xad, 0x2e, 0x1f, 0x06, 0x1f, 0xc2, 0xe5,
	0xc3, 0xbb, 0x29, 0x18, 0xdf, 0x94, 0xef, 0x6b, 0xbf, 0xab, 0xab, 0xde, 0xcb, 0xff, 0x57, 0x53,
	0x70, 0xb0, 0x5b, 0x52, 0xa9, 0x3e, 0x6b, 0x8a, 0x87, 0x7f, 0x78, 0x2b, 0x7f, 0x28, 0xc1, 0x81,
	0x2e, 0x79, 0xad, 0xfa, 0x2c, 0x88, 0x23, 0x90, 0xa5, 0x29, 0xb9, 0xa2, 0x4e, 0x0b, 0x52, 0x40,
	0xcf, 0x7d, 0xdf, 0x1f, 0x82, 0x5c, 0x24, 0x6d, 0xe1, 0x7e, 0x52, 0x50, 0xfd, 0x7b, 0xeb, 0xfe,
	0x18, 0x8c, 0x3a, 0xae, 0x61, 0xda, 0x9a, 0xa5, 0x9a, 0xb6, 0xba, 0x6a, 0xda, 0xfc, 0x22, 0x4c,
	0x29, 0xf0, 0xe2, 0x05, 0xfb, 0x8a, 0x69, 0x1b, 0xe8, 0x02, 0xa4, 0x69, 0xe5, 0x10, 0xbd, 0x33,
	0x39, 0xb5, 0xa3, 0x84, 0x92, 0x73, 0x04, 0x83, 0x42, 0xe1, 0xd1, 0x22, 0x64, 0x0d, 0xd3, 0xc5,
	0xd1, 0x4b, 0xa6, 0x53, 0x5b, 0x9e, 0xad, 0xa2, 0x78, 0xce, 0x09, 0x48, 0x25, 0x44, 0x82, 0xa6,
	0x20, 0x63, 0xd6, 0xd8, 0xdb, 0x5d, 0xfe, 0xb4, 0x3d, 0xf8, 0x46, 0xeb, 0x50, 0x10, 0xef, 0x8c,
	0x59, 0xdf, 0x32, 0xbb, 0xce, 0x4a, 0x21, 0x5e, 0x29, 0x47, 0xf8, 0xa2, 0xdd, 0xcb, 0x0b, 0x42,
	0xe4, 0xab, 0xfc, 0x04, 0xa4, 0xa9, 0xd8, 0x46, 0x60, 0xf0, 0xca, 0xf9, 0x97, 0xc6, 0x06, 0x50,
	0x11, 0xe0, 0xca, 0xf9, 0x97, 0xd4, 0x9b, 0xb7, 0x2f, 0x5c, 0x58, 0x78, 0x71, 0x4c, 0x42, 0x00,
	0xc3, 0x37, 0x6f, 0xdd, 0x50, 0xce, 0x9f, 0x1b, 0x4b, 0x95, 0x7f, 0x24, 0x41, 0x21, 0x96, 0x67,
	0xab, 0x0f, 0x77, 0x0a, 0xcf, 0xc0, 0x64, 0x7d, 0xa5, 0xe9, 0x99, 0xba, 0x66, 0xa9, 0x2e, 0xae,
	0xbb, 0xd8, 0xc3, 0xb6, 0xcf, 0xf4, 0x10, 0x99, 0xd6, 0x79, 0xe5, 0x90, 0xa8, 0x56, 0x62, 0xb5,
	0xe8, 0x69, 0x38, 0x64, 0x39, 0xd5, 0x6e, 0x70, 0x6c, 0x2f, 0x9d, 0xe0, 0xb5, 0x71, 0xb0, 0xf2,
	0x1f, 0x4b, 0x30, 0xd1, 0x35, 0x79, 0x16, 0x7a, 0x1d, 0xc6, 0x3b, 0x12, 0x73, 0x05, 0xbd, 0xa6,
	0xe1, 0xee, 0x31, 0xa8, 0xdd, 0x76, 0x7f, 0x34, 0x96, 0x8b, 0x2b, 0x72, 0x74, 0x49, 0x45, 0x8e,
	0x2e, 0xff, 0xdd, 0x8d, 0x57, 0x7a, 0xd7, 0xf3, 0x70, 0x79, 0x7d, 0x80, 0xd7, 0x5a, 0x6b, 0x30,
	0xda, 0xf1, 0x7b, 0x05, 0xfd, 0x71, 0x96, 0xbe, 0x9d, 0x82, 0xd1, 0x8e, 0x5f, 0x2b, 0xd8, 0x4f,
	0xfb, 0xf8, 0x09, 0x28, 0x06, 0x2e, 0xad, 0x88, 0x17, 0x54, 0x29, 0x04, 0xa5, 0x54, 0x93, 0xbd,
	0x0e, 0xb1, 0xf4, 0x89, 0x7d, 0xbe, 0xa0, 0x6a, 0x49, 0x10, 0xfe, 0x66, 0x43, 0x7f, 0xa4, 0xdf,
	0xd1, 0xc1, 0xd4, 0x83, 0xed, 0xe0, 0x3f, 0x09, 0x4f, 0x54, 0xff, 0x3a, 0xd8, 0x97, 0xe9, 0x55,
	0xbe, 0x0b, 0x9b, 0x7f, 0xdb, 0xa2, 0x3f, 0xeb, 0x56, 0x50, 0x8e, 0xfd, 0x38, 0x45, 0x5f, 0x28,
	0xff, 0x79, 0x1a, 0x32, 0x22, 0x4d, 0x17, 0x99, 0x47, 0x91, 0xe4, 0x60, 0xd1, 0x85, 0x12, 0xe6,
	0x05, 0xdb, 0xe5, 0x3c, 0x5a, 0x0e, 0x52, 0x82, 0x21, 0x05, 0x86, 0xeb, 0x9a, 0xab, 0xd5, 0xd8,
	0x1b, 0xb0, 0x1d, 0x25, 0x4d, 0x9c, 0x5b, 0x24, 0x80, 0xd8, 0xc7, 0x2e, 0x7d, 0x6d, 0x3f, 0xa0,
	0x70, 0x4c, 0xe8, 0x18, 0x80, 0x8b, 0xfd, 0x86, 0x6b, 0xab, 0x1e, 0xf6, 0x79, 0xf4, 0x44, 0x96,
	0x95, 0xdc, 0xc4, 0x3e, 0xba, 0x0e, 0x39, 0x5e, 0x4d, 0x93, 0x6a, 0xed, 0x30, 0x0d, 0x11, 0x23,
	0xc5, 0x09, 0x50, 0x05, 0xc6, 0x6e, 0xd9, 0xeb, 0xae, 0xa3, 0x63, 0xa3, 0xe1, 0xf2, 0x04, 0x44,
	0x4a, 0xce, 0xf4, 0x16, 0x45, 0xd1, 0xd4, 0xdf, 0x49, 0x90, 0x0d, 0xb8, 0x0d, 0xf4, 0xa3, 0x14,
	0xea, 0x47, 0x74, 0x05, 0x86, 0x74, 0x4b, 0xf3, 0x3c, 0xae, 0x7d, 0xe6, 0xb7, 0xb4, 0xdf, 0x84,
	0x04, 0x28, 0xca, 0xb3, 0x04, 0x8c, 0xb3, 0xc5, 0x70, 0xa0, 0x33, 0x3c, 0xe7, 0xe0, 0xe0, 0xfd,
	0x74, 0x8d, 0xa5, 0x21, 0x3c, 0x0e, 0xf9, 0xe8, 0x0f, 0x3e, 0x70, 0x37, 0x64, 0xce, 0x08, 0xdf,
	0xaa, 0x96, 0x3f, 0x90, 0x20, 0x1f, 0xcd, 0x9a, 0xd9, 0xe7, 0x99, 0xd3, 0xcd, 0xca, 0xf8, 0x17,
	0x09, 0xd0, 0xe6, 0x9c, 0x9a, 0x7d, 0x66, 0xec, 0x36, 0x40, 0x24, 0x19, 0xe8, 0x4e, 0xc6, 0x33,
	0x92, 0x06, 0x94, 0x4f, 0xb3, 0x10, 0x11, 0x39, 0x3d, 0x8e, 0x6f, 0x4a, 0xd7, 0xd9, 0xe7, 0xae,
	0x1d, 0x03, 0x88, 0xa4, 0x19, 0x65, 0xf9, 0x33, 0xb2, 0x96, 0x60, 0xa6, 0xfc, 0x53, 0x09, 0x0e,
	0xf7, 0x4c, 0xe4, 0xd9, 0x67, 0x56, 0x2d, 0x38, 0xd0, 0x2d, 0x23, 0x69, 0xae, 0x6b, 0x1e, 0xec,
	0xee, 0xc3, 0xb1, 0x39, 0x17, 0x29, 0x1b, 0x95, 0x71, 0xbb, 0xb3, 0xa2, 0xfc, 0x1d, 0x08, 0xd7,
	0x42, 0xc5, 0x31, 0x9a, 0xfd, 0x5f, 0x0b, 0x34, 0xcd, 0x29, 0x5f, 0x0b, 0xe4, 0x6f, 0x74, 0x11,
	0xd2, 0x96, 0x16, 0xdc, 0x22, 0x3e, 0x99, 0xa8, 0xc7, 0x57, 0x35, 0xbb, 0xda, 0xd0, 0xaa, 0x58,
	0x6c, 0x05, 0x04, 0x01, 0x32, 0x20, 0xc7, 0x5e, 0xeb, 0x12, 0x6d, 0x21, 0x9e, 0xad, 0x3e, 0xbf,
	0xb3, 0x4c, 0xaa, 0xec, 0x17, 0x76, 0xc2, 0x37, 0xac, 0x7c, 0x7a, 0xd3, 0x27, 0xba, 0x14, 0x2d,
	0xd2, 0x80, 0x7e, 0xa9, 0x6b, 0x26, 0x5e, 0x67, 0x11, 0x9b, 0x89, 0x7e, 0x23, 0x20, 0x46, 0xe4,
	0x8e, 0x89, 0xd7, 0x3b, 0x69, 0x64, 0x09, 0x56, 0x52, 0xd1, 0x23, 0x0d, 0xe8, 0x70, 0xbf, 0xd2,
	0x80, 0x6e, 0x7a, 0xf4, 0x3c, 0xd2, 0xaf, 0x47, 0xcf, 0xb1, 0x5c, 0x9f, 0x99, 0x3e, 0xe5, 0xfa,
	0x9c, 0xba, 0x97, 0x82, 0x62, 0x7c, 0xd4, 0xfb, 0x63, 0x26, 0xc6, 0x03, 0x9f, 0x53, 0x0f, 0x36,
	0xf0, 0x39, 0x6a, 0x93, 0x0e, 0x3e, 0x28, 0x9b, 0x74, 0xaa, 0x25, 0x41, 0x21, 0x36, 0xb7, 0xfb,
	0xf0, 0x46, 0xbf, 0x9f, 0x62, 0x2c, 0x9f, 0x81, 0xc9, 0x1e, 0xa9, 0x0e, 0xd1, 0x63, 0x30, 0x66,
	0xda, 0xea, 0xa9, 0xd3, 0xea, 0x53, 0xaa, 0xe3, 0xaa, 0x96, 0xe6, 0x63, 0x96, 0x94, 0x38, 0xa3,
	0xe4, 0x4d, 0xfb, 0xd4, 0xe9, 0xa7, 0x6e, 0xb8, 0x57, 0x49, 0x59, 0x45, 0xbb, 0xf7, 0xa3, 0xe9,
	0x81, 0x3f, 0x6a, 0x4f, 0x4b, 0xf7, 0xda, 0xd3, 0xd2, 0x47, 0xed, 0x69, 0xe9, 0x07, 0xed, 0x69,
	0xe9, 0x87, 0xed, 0x69, 0xe9, 0x83, 0x8f, 0xa7, 0x07, 0x3e, 0xfa, 0x78, 0x7a, 0xe0, 0x07, 0x1f,
	0x4f, 0x0f, 0xbc, 0xbc, 0x03, 0x86, 0x37, 0xfd, 0x26, 0xf6, 0xd2, 0x30, 0xfd, 0x69, 0xe8, 0xd3,
	0xff, 0x1f, 0x00, 0x00, 0xff, 0xff, 0x70, 0x43, 0xbf, 0x38, 0x34, 0x7b, 0x00, 0x00,
}

func (this *ElementProto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto)
	if !ok {
		that2, ok := that.(ElementProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ElementOneOf == nil {
		if this.ElementOneOf != nil {
			return false
		}
	} else if this.ElementOneOf == nil {
		return false
	} else if !this.ElementOneOf.Equal(that1.ElementOneOf) {
		return false
	}
	return true
}
func (this *ElementProto_Database) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_Database)
	if !ok {
		that2, ok := that.(ElementProto_Database)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Database.Equal(that1.Database) {
		return false
	}
	return true
}
func (this *ElementProto_Schema) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_Schema)
	if !ok {
		that2, ok := that.(ElementProto_Schema)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Schema.Equal(that1.Schema) {
		return false
	}
	return true
}
func (this *ElementProto_View) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_View)
	if !ok {
		that2, ok := that.(ElementProto_View)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.View.Equal(that1.View) {
		return false
	}
	return true
}
func (this *ElementProto_Sequence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_Sequence)
	if !ok {
		that2, ok := that.(ElementProto_Sequence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Sequence.Equal(that1.Sequence) {
		return false
	}
	return true
}
func (this *ElementProto_Table) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_Table)
	if !ok {
		that2, ok := that.(ElementProto_Table)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Table.Equal(that1.Table) {
		return false
	}
	return true
}
func (this *ElementProto_EnumType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_EnumType)
	if !ok {
		that2, ok := that.(ElementProto_EnumType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnumType.Equal(that1.EnumType) {
		return false
	}
	return true
}
func (this *ElementProto_AliasType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_AliasType)
	if !ok {
		that2, ok := that.(ElementProto_AliasType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AliasType.Equal(that1.AliasType) {
		return false
	}
	return true
}
func (this *ElementProto_CompositeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_CompositeType)
	if !ok {
		that2, ok := that.(ElementProto_CompositeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CompositeType.Equal(that1.CompositeType) {
		return false
	}
	return true
}
func (this *ElementProto_Function) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_Function)
	if !ok {
		that2, ok := that.(ElementProto_Function)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Function.Equal(that1.Function) {
		return false
	}
	return true
}
func (this *ElementProto_ColumnFamily) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ColumnFamily)
	if !ok {
		that2, ok := that.(ElementProto_ColumnFamily)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ColumnFamily.Equal(that1.ColumnFamily) {
		return false
	}
	return true
}
func (this *ElementProto_Column) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_Column)
	if !ok {
		that2, ok := that.(ElementProto_Column)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Column.Equal(that1.Column) {
		return false
	}
	return true
}
func (this *ElementProto_PrimaryIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_PrimaryIndex)
	if !ok {
		that2, ok := that.(ElementProto_PrimaryIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PrimaryIndex.Equal(that1.PrimaryIndex) {
		return false
	}
	return true
}
func (this *ElementProto_SecondaryIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_SecondaryIndex)
	if !ok {
		that2, ok := that.(ElementProto_SecondaryIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SecondaryIndex.Equal(that1.SecondaryIndex) {
		return false
	}
	return true
}
func (this *ElementProto_TemporaryIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TemporaryIndex)
	if !ok {
		that2, ok := that.(ElementProto_TemporaryIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TemporaryIndex.Equal(that1.TemporaryIndex) {
		return false
	}
	return true
}
func (this *ElementProto_UniqueWithoutIndexConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_UniqueWithoutIndexConstraint)
	if !ok {
		that2, ok := that.(ElementProto_UniqueWithoutIndexConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UniqueWithoutIndexConstraint.Equal(that1.UniqueWithoutIndexConstraint) {
		return false
	}
	return true
}
func (this *ElementProto_UniqueWithoutIndexConstraintUnvalidated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_UniqueWithoutIndexConstraintUnvalidated)
	if !ok {
		that2, ok := that.(ElementProto_UniqueWithoutIndexConstraintUnvalidated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UniqueWithoutIndexConstraintUnvalidated.Equal(that1.UniqueWithoutIndexConstraintUnvalidated) {
		return false
	}
	return true
}
func (this *ElementProto_CheckConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_CheckConstraint)
	if !ok {
		that2, ok := that.(ElementProto_CheckConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckConstraint.Equal(that1.CheckConstraint) {
		return false
	}
	return true
}
func (this *ElementProto_CheckConstraintUnvalidated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_CheckConstraintUnvalidated)
	if !ok {
		that2, ok := that.(ElementProto_CheckConstraintUnvalidated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CheckConstraintUnvalidated.Equal(that1.CheckConstraintUnvalidated) {
		return false
	}
	return true
}
func (this *ElementProto_ForeignKeyConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ForeignKeyConstraint)
	if !ok {
		that2, ok := that.(ElementProto_ForeignKeyConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ForeignKeyConstraint.Equal(that1.ForeignKeyConstraint) {
		return false
	}
	return true
}
func (this *ElementProto_ForeignKeyConstraintUnvalidated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ForeignKeyConstraintUnvalidated)
	if !ok {
		that2, ok := that.(ElementProto_ForeignKeyConstraintUnvalidated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ForeignKeyConstraintUnvalidated.Equal(that1.ForeignKeyConstraintUnvalidated) {
		return false
	}
	return true
}
func (this *ElementProto_TableComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TableComment)
	if !ok {
		that2, ok := that.(ElementProto_TableComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TableComment.Equal(that1.TableComment) {
		return false
	}
	return true
}
func (this *ElementProto_RowLevelTTL) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_RowLevelTTL)
	if !ok {
		that2, ok := that.(ElementProto_RowLevelTTL)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RowLevelTTL.Equal(that1.RowLevelTTL) {
		return false
	}
	return true
}
func (this *ElementProto_TableZoneConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TableZoneConfig)
	if !ok {
		that2, ok := that.(ElementProto_TableZoneConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TableZoneConfig.Equal(that1.TableZoneConfig) {
		return false
	}
	return true
}
func (this *ElementProto_IndexZoneConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_IndexZoneConfig)
	if !ok {
		that2, ok := that.(ElementProto_IndexZoneConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IndexZoneConfig.Equal(that1.IndexZoneConfig) {
		return false
	}
	return true
}
func (this *ElementProto_TableData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TableData)
	if !ok {
		that2, ok := that.(ElementProto_TableData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TableData.Equal(that1.TableData) {
		return false
	}
	return true
}
func (this *ElementProto_TablePartitioning) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TablePartitioning)
	if !ok {
		that2, ok := that.(ElementProto_TablePartitioning)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TablePartitioning.Equal(that1.TablePartitioning) {
		return false
	}
	return true
}
func (this *ElementProto_TableSchemaLocked) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TableSchemaLocked)
	if !ok {
		that2, ok := that.(ElementProto_TableSchemaLocked)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TableSchemaLocked.Equal(that1.TableSchemaLocked) {
		return false
	}
	return true
}
func (this *ElementProto_TableLocalityGlobal) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TableLocalityGlobal)
	if !ok {
		that2, ok := that.(ElementProto_TableLocalityGlobal)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TableLocalityGlobal.Equal(that1.TableLocalityGlobal) {
		return false
	}
	return true
}
func (this *ElementProto_TableLocalityPrimaryRegion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TableLocalityPrimaryRegion)
	if !ok {
		that2, ok := that.(ElementProto_TableLocalityPrimaryRegion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TableLocalityPrimaryRegion.Equal(that1.TableLocalityPrimaryRegion) {
		return false
	}
	return true
}
func (this *ElementProto_TableLocalitySecondaryRegion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TableLocalitySecondaryRegion)
	if !ok {
		that2, ok := that.(ElementProto_TableLocalitySecondaryRegion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TableLocalitySecondaryRegion.Equal(that1.TableLocalitySecondaryRegion) {
		return false
	}
	return true
}
func (this *ElementProto_TableLocalityRegionalByRow) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_TableLocalityRegionalByRow)
	if !ok {
		that2, ok := that.(ElementProto_TableLocalityRegionalByRow)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TableLocalityRegionalByRow.Equal(that1.TableLocalityRegionalByRow) {
		return false
	}
	return true
}
func (this *ElementProto_ColumnName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ColumnName)
	if !ok {
		that2, ok := that.(ElementProto_ColumnName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ColumnName.Equal(that1.ColumnName) {
		return false
	}
	return true
}
func (this *ElementProto_ColumnType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ColumnType)
	if !ok {
		that2, ok := that.(ElementProto_ColumnType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ColumnType.Equal(that1.ColumnType) {
		return false
	}
	return true
}
func (this *ElementProto_ColumnDefaultExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ColumnDefaultExpression)
	if !ok {
		that2, ok := that.(ElementProto_ColumnDefaultExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ColumnDefaultExpression.Equal(that1.ColumnDefaultExpression) {
		return false
	}
	return true
}
func (this *ElementProto_ColumnOnUpdateExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ColumnOnUpdateExpression)
	if !ok {
		that2, ok := that.(ElementProto_ColumnOnUpdateExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ColumnOnUpdateExpression.Equal(that1.ColumnOnUpdateExpression) {
		return false
	}
	return true
}
func (this *ElementProto_SequenceOwner) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_SequenceOwner)
	if !ok {
		that2, ok := that.(ElementProto_SequenceOwner)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SequenceOwner.Equal(that1.SequenceOwner) {
		return false
	}
	return true
}
func (this *ElementProto_ColumnComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ColumnComment)
	if !ok {
		that2, ok := that.(ElementProto_ColumnComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ColumnComment.Equal(that1.ColumnComment) {
		return false
	}
	return true
}
func (this *ElementProto_ColumnNotNull) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ColumnNotNull)
	if !ok {
		that2, ok := that.(ElementProto_ColumnNotNull)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ColumnNotNull.Equal(that1.ColumnNotNull) {
		return false
	}
	return true
}
func (this *ElementProto_SequenceOption) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_SequenceOption)
	if !ok {
		that2, ok := that.(ElementProto_SequenceOption)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SequenceOption.Equal(that1.SequenceOption) {
		return false
	}
	return true
}
func (this *ElementProto_IndexName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_IndexName)
	if !ok {
		that2, ok := that.(ElementProto_IndexName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IndexName.Equal(that1.IndexName) {
		return false
	}
	return true
}
func (this *ElementProto_IndexPartitioning) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_IndexPartitioning)
	if !ok {
		that2, ok := that.(ElementProto_IndexPartitioning)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IndexPartitioning.Equal(that1.IndexPartitioning) {
		return false
	}
	return true
}
func (this *ElementProto_SecondaryIndexPartial) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_SecondaryIndexPartial)
	if !ok {
		that2, ok := that.(ElementProto_SecondaryIndexPartial)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SecondaryIndexPartial.Equal(that1.SecondaryIndexPartial) {
		return false
	}
	return true
}
func (this *ElementProto_IndexComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_IndexComment)
	if !ok {
		that2, ok := that.(ElementProto_IndexComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IndexComment.Equal(that1.IndexComment) {
		return false
	}
	return true
}
func (this *ElementProto_IndexColumn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_IndexColumn)
	if !ok {
		that2, ok := that.(ElementProto_IndexColumn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IndexColumn.Equal(that1.IndexColumn) {
		return false
	}
	return true
}
func (this *ElementProto_IndexData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_IndexData)
	if !ok {
		that2, ok := that.(ElementProto_IndexData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IndexData.Equal(that1.IndexData) {
		return false
	}
	return true
}
func (this *ElementProto_ConstraintWithoutIndexName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ConstraintWithoutIndexName)
	if !ok {
		that2, ok := that.(ElementProto_ConstraintWithoutIndexName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConstraintWithoutIndexName.Equal(that1.ConstraintWithoutIndexName) {
		return false
	}
	return true
}
func (this *ElementProto_ConstraintComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_ConstraintComment)
	if !ok {
		that2, ok := that.(ElementProto_ConstraintComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConstraintComment.Equal(that1.ConstraintComment) {
		return false
	}
	return true
}
func (this *ElementProto_Namespace) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_Namespace)
	if !ok {
		that2, ok := that.(ElementProto_Namespace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Namespace.Equal(that1.Namespace) {
		return false
	}
	return true
}
func (this *ElementProto_Owner) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_Owner)
	if !ok {
		that2, ok := that.(ElementProto_Owner)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Owner.Equal(that1.Owner) {
		return false
	}
	return true
}
func (this *ElementProto_UserPrivileges) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_UserPrivileges)
	if !ok {
		that2, ok := that.(ElementProto_UserPrivileges)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UserPrivileges.Equal(that1.UserPrivileges) {
		return false
	}
	return true
}
func (this *ElementProto_DatabaseRegionConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_DatabaseRegionConfig)
	if !ok {
		that2, ok := that.(ElementProto_DatabaseRegionConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DatabaseRegionConfig.Equal(that1.DatabaseRegionConfig) {
		return false
	}
	return true
}
func (this *ElementProto_DatabaseRoleSetting) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_DatabaseRoleSetting)
	if !ok {
		that2, ok := that.(ElementProto_DatabaseRoleSetting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DatabaseRoleSetting.Equal(that1.DatabaseRoleSetting) {
		return false
	}
	return true
}
func (this *ElementProto_DatabaseComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_DatabaseComment)
	if !ok {
		that2, ok := that.(ElementProto_DatabaseComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DatabaseComment.Equal(that1.DatabaseComment) {
		return false
	}
	return true
}
func (this *ElementProto_DatabaseData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_DatabaseData)
	if !ok {
		that2, ok := that.(ElementProto_DatabaseData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DatabaseData.Equal(that1.DatabaseData) {
		return false
	}
	return true
}
func (this *ElementProto_SchemaParent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_SchemaParent)
	if !ok {
		that2, ok := that.(ElementProto_SchemaParent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SchemaParent.Equal(that1.SchemaParent) {
		return false
	}
	return true
}
func (this *ElementProto_SchemaComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_SchemaComment)
	if !ok {
		that2, ok := that.(ElementProto_SchemaComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SchemaComment.Equal(that1.SchemaComment) {
		return false
	}
	return true
}
func (this *ElementProto_SchemaChild) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_SchemaChild)
	if !ok {
		that2, ok := that.(ElementProto_SchemaChild)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SchemaChild.Equal(that1.SchemaChild) {
		return false
	}
	return true
}
func (this *ElementProto_EnumTypeValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_EnumTypeValue)
	if !ok {
		that2, ok := that.(ElementProto_EnumTypeValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnumTypeValue.Equal(that1.EnumTypeValue) {
		return false
	}
	return true
}
func (this *ElementProto_CompositeTypeAttrType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_CompositeTypeAttrType)
	if !ok {
		that2, ok := that.(ElementProto_CompositeTypeAttrType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CompositeTypeAttrType.Equal(that1.CompositeTypeAttrType) {
		return false
	}
	return true
}
func (this *ElementProto_CompositeTypeAttrName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_CompositeTypeAttrName)
	if !ok {
		that2, ok := that.(ElementProto_CompositeTypeAttrName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CompositeTypeAttrName.Equal(that1.CompositeTypeAttrName) {
		return false
	}
	return true
}
func (this *ElementProto_FunctionName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_FunctionName)
	if !ok {
		that2, ok := that.(ElementProto_FunctionName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FunctionName.Equal(that1.FunctionName) {
		return false
	}
	return true
}
func (this *ElementProto_FunctionVolatility) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_FunctionVolatility)
	if !ok {
		that2, ok := that.(ElementProto_FunctionVolatility)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FunctionVolatility.Equal(that1.FunctionVolatility) {
		return false
	}
	return true
}
func (this *ElementProto_FunctionLeakProof) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_FunctionLeakProof)
	if !ok {
		that2, ok := that.(ElementProto_FunctionLeakProof)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FunctionLeakProof.Equal(that1.FunctionLeakProof) {
		return false
	}
	return true
}
func (this *ElementProto_FunctionNullInputBehavior) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_FunctionNullInputBehavior)
	if !ok {
		that2, ok := that.(ElementProto_FunctionNullInputBehavior)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FunctionNullInputBehavior.Equal(that1.FunctionNullInputBehavior) {
		return false
	}
	return true
}
func (this *ElementProto_FunctionBody) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementProto_FunctionBody)
	if !ok {
		that2, ok := that.(ElementProto_FunctionBody)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FunctionBody.Equal(that1.FunctionBody) {
		return false
	}
	return true
}
func (this *TypeT) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TypeT)
	if !ok {
		that2, ok := that.(TypeT)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Type.Equal(that1.Type) {
		return false
	}
	if len(this.ClosedTypeIDs) != len(that1.ClosedTypeIDs) {
		return false
	}
	for i := range this.ClosedTypeIDs {
		if this.ClosedTypeIDs[i] != that1.ClosedTypeIDs[i] {
			return false
		}
	}
	return true
}
func (this *Expression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Expression)
	if !ok {
		that2, ok := that.(Expression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Expr != that1.Expr {
		return false
	}
	if len(this.UsesTypeIDs) != len(that1.UsesTypeIDs) {
		return false
	}
	for i := range this.UsesTypeIDs {
		if this.UsesTypeIDs[i] != that1.UsesTypeIDs[i] {
			return false
		}
	}
	if len(this.UsesSequenceIDs) != len(that1.UsesSequenceIDs) {
		return false
	}
	for i := range this.UsesSequenceIDs {
		if this.UsesSequenceIDs[i] != that1.UsesSequenceIDs[i] {
			return false
		}
	}
	if len(this.ReferencedColumnIDs) != len(that1.ReferencedColumnIDs) {
		return false
	}
	for i := range this.ReferencedColumnIDs {
		if this.ReferencedColumnIDs[i] != that1.ReferencedColumnIDs[i] {
			return false
		}
	}
	if len(this.UsesFunctionIDs) != len(that1.UsesFunctionIDs) {
		return false
	}
	for i := range this.UsesFunctionIDs {
		if this.UsesFunctionIDs[i] != that1.UsesFunctionIDs[i] {
			return false
		}
	}
	return true
}
func (this *Column) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Column)
	if !ok {
		that2, ok := that.(Column)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.IsHidden != that1.IsHidden {
		return false
	}
	if this.IsInaccessible != that1.IsInaccessible {
		return false
	}
	if this.GeneratedAsIdentityType != that1.GeneratedAsIdentityType {
		return false
	}
	if this.GeneratedAsIdentitySequenceOption != that1.GeneratedAsIdentitySequenceOption {
		return false
	}
	if this.PgAttributeNum != that1.PgAttributeNum {
		return false
	}
	if this.IsSystemColumn != that1.IsSystemColumn {
		return false
	}
	return true
}
func (this *ColumnType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnType)
	if !ok {
		that2, ok := that.(ColumnType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.FamilyID != that1.FamilyID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if !this.TypeT.Equal(&that1.TypeT) {
		return false
	}
	if this.IsNullable != that1.IsNullable {
		return false
	}
	if !this.ComputeExpr.Equal(that1.ComputeExpr) {
		return false
	}
	if this.IsVirtual != that1.IsVirtual {
		return false
	}
	if !this.ElementCreationMetadata.Equal(that1.ElementCreationMetadata) {
		return false
	}
	return true
}
func (this *ColumnFamily) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnFamily)
	if !ok {
		that2, ok := that.(ColumnFamily)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.FamilyID != that1.FamilyID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *Index) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Index)
	if !ok {
		that2, ok := that.(Index)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if this.IsUnique != that1.IsUnique {
		return false
	}
	if this.IsInverted != that1.IsInverted {
		return false
	}
	if !this.Sharding.Equal(that1.Sharding) {
		return false
	}
	if this.IsCreatedExplicitly != that1.IsCreatedExplicitly {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if this.IsConcurrently != that1.IsConcurrently {
		return false
	}
	if this.SourceIndexID != that1.SourceIndexID {
		return false
	}
	if this.TemporaryIndexID != that1.TemporaryIndexID {
		return false
	}
	if !this.GeoConfig.Equal(that1.GeoConfig) {
		return false
	}
	if this.IsNotVisible != that1.IsNotVisible {
		return false
	}
	if this.Invisibility != that1.Invisibility {
		return false
	}
	return true
}
func (this *PrimaryIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PrimaryIndex)
	if !ok {
		that2, ok := that.(PrimaryIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Index.Equal(&that1.Index) {
		return false
	}
	return true
}
func (this *SecondaryIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecondaryIndex)
	if !ok {
		that2, ok := that.(SecondaryIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Index.Equal(&that1.Index) {
		return false
	}
	if !this.EmbeddedExpr.Equal(that1.EmbeddedExpr) {
		return false
	}
	if this.RecreateSourceIndexID != that1.RecreateSourceIndexID {
		return false
	}
	return true
}
func (this *TemporaryIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TemporaryIndex)
	if !ok {
		that2, ok := that.(TemporaryIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Index.Equal(&that1.Index) {
		return false
	}
	if this.IsUsingSecondaryEncoding != that1.IsUsingSecondaryEncoding {
		return false
	}
	if !this.Expr.Equal(that1.Expr) {
		return false
	}
	return true
}
func (this *SecondaryIndexPartial) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecondaryIndexPartial)
	if !ok {
		that2, ok := that.(SecondaryIndexPartial)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if !this.Expression.Equal(&that1.Expression) {
		return false
	}
	return true
}
func (this *SchemaParent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SchemaParent)
	if !ok {
		that2, ok := that.(SchemaParent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SchemaID != that1.SchemaID {
		return false
	}
	if this.ParentDatabaseID != that1.ParentDatabaseID {
		return false
	}
	return true
}
func (this *SchemaChild) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SchemaChild)
	if !ok {
		that2, ok := that.(SchemaChild)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChildObjectID != that1.ChildObjectID {
		return false
	}
	if this.SchemaID != that1.SchemaID {
		return false
	}
	return true
}
func (this *Sequence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Sequence)
	if !ok {
		that2, ok := that.(Sequence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SequenceID != that1.SequenceID {
		return false
	}
	if this.RestartWith != that1.RestartWith {
		return false
	}
	if this.UseRestartWith != that1.UseRestartWith {
		return false
	}
	if this.IsTemporary != that1.IsTemporary {
		return false
	}
	return true
}
func (this *SequenceOption) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SequenceOption)
	if !ok {
		that2, ok := that.(SequenceOption)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SequenceID != that1.SequenceID {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *SequenceOwner) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SequenceOwner)
	if !ok {
		that2, ok := that.(SequenceOwner)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SequenceID != that1.SequenceID {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	return true
}
func (this *ColumnDefaultExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnDefaultExpression)
	if !ok {
		that2, ok := that.(ColumnDefaultExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if !this.Expression.Equal(&that1.Expression) {
		return false
	}
	return true
}
func (this *ColumnOnUpdateExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnOnUpdateExpression)
	if !ok {
		that2, ok := that.(ColumnOnUpdateExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if !this.Expression.Equal(&that1.Expression) {
		return false
	}
	return true
}
func (this *View) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*View)
	if !ok {
		that2, ok := that.(View)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ViewID != that1.ViewID {
		return false
	}
	if len(this.UsesTypeIDs) != len(that1.UsesTypeIDs) {
		return false
	}
	for i := range this.UsesTypeIDs {
		if this.UsesTypeIDs[i] != that1.UsesTypeIDs[i] {
			return false
		}
	}
	if len(this.UsesRelationIDs) != len(that1.UsesRelationIDs) {
		return false
	}
	for i := range this.UsesRelationIDs {
		if this.UsesRelationIDs[i] != that1.UsesRelationIDs[i] {
			return false
		}
	}
	if len(this.ForwardReferences) != len(that1.ForwardReferences) {
		return false
	}
	for i := range this.ForwardReferences {
		if !this.ForwardReferences[i].Equal(that1.ForwardReferences[i]) {
			return false
		}
	}
	if this.IsTemporary != that1.IsTemporary {
		return false
	}
	if this.IsMaterialized != that1.IsMaterialized {
		return false
	}
	return true
}
func (this *View_Reference) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*View_Reference)
	if !ok {
		that2, ok := that.(View_Reference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ToID != that1.ToID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	return true
}
func (this *Table) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Table)
	if !ok {
		that2, ok := that.(Table)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IsTemporary != that1.IsTemporary {
		return false
	}
	return true
}
func (this *UniqueWithoutIndexConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UniqueWithoutIndexConstraint)
	if !ok {
		that2, ok := that.(UniqueWithoutIndexConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	if !this.Predicate.Equal(that1.Predicate) {
		return false
	}
	if this.IndexIDForValidation != that1.IndexIDForValidation {
		return false
	}
	return true
}
func (this *UniqueWithoutIndexConstraintUnvalidated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UniqueWithoutIndexConstraintUnvalidated)
	if !ok {
		that2, ok := that.(UniqueWithoutIndexConstraintUnvalidated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	if !this.Predicate.Equal(that1.Predicate) {
		return false
	}
	return true
}
func (this *CheckConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckConstraint)
	if !ok {
		that2, ok := that.(CheckConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	if !this.Expression.Equal(&that1.Expression) {
		return false
	}
	if this.FromHashShardedColumn != that1.FromHashShardedColumn {
		return false
	}
	if this.IndexIDForValidation != that1.IndexIDForValidation {
		return false
	}
	return true
}
func (this *CheckConstraintUnvalidated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckConstraintUnvalidated)
	if !ok {
		that2, ok := that.(CheckConstraintUnvalidated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	if !this.Expression.Equal(&that1.Expression) {
		return false
	}
	return true
}
func (this *ForeignKeyConstraint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ForeignKeyConstraint)
	if !ok {
		that2, ok := that.(ForeignKeyConstraint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	if this.ReferencedTableID != that1.ReferencedTableID {
		return false
	}
	if len(this.ReferencedColumnIDs) != len(that1.ReferencedColumnIDs) {
		return false
	}
	for i := range this.ReferencedColumnIDs {
		if this.ReferencedColumnIDs[i] != that1.ReferencedColumnIDs[i] {
			return false
		}
	}
	if this.OnUpdateAction != that1.OnUpdateAction {
		return false
	}
	if this.OnDeleteAction != that1.OnDeleteAction {
		return false
	}
	if this.CompositeKeyMatchMethod != that1.CompositeKeyMatchMethod {
		return false
	}
	if this.IndexIDForValidation != that1.IndexIDForValidation {
		return false
	}
	return true
}
func (this *ForeignKeyConstraintUnvalidated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ForeignKeyConstraintUnvalidated)
	if !ok {
		that2, ok := that.(ForeignKeyConstraintUnvalidated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	if this.ReferencedTableID != that1.ReferencedTableID {
		return false
	}
	if len(this.ReferencedColumnIDs) != len(that1.ReferencedColumnIDs) {
		return false
	}
	for i := range this.ReferencedColumnIDs {
		if this.ReferencedColumnIDs[i] != that1.ReferencedColumnIDs[i] {
			return false
		}
	}
	if this.OnUpdateAction != that1.OnUpdateAction {
		return false
	}
	if this.OnDeleteAction != that1.OnDeleteAction {
		return false
	}
	if this.CompositeKeyMatchMethod != that1.CompositeKeyMatchMethod {
		return false
	}
	return true
}
func (this *EnumType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EnumType)
	if !ok {
		that2, ok := that.(EnumType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TypeID != that1.TypeID {
		return false
	}
	if this.ArrayTypeID != that1.ArrayTypeID {
		return false
	}
	if this.IsMultiRegion != that1.IsMultiRegion {
		return false
	}
	return true
}
func (this *AliasType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AliasType)
	if !ok {
		that2, ok := that.(AliasType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TypeID != that1.TypeID {
		return false
	}
	if !this.TypeT.Equal(&that1.TypeT) {
		return false
	}
	return true
}
func (this *CompositeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CompositeType)
	if !ok {
		that2, ok := that.(CompositeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TypeID != that1.TypeID {
		return false
	}
	if this.ArrayTypeID != that1.ArrayTypeID {
		return false
	}
	return true
}
func (this *Schema) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Schema)
	if !ok {
		that2, ok := that.(Schema)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SchemaID != that1.SchemaID {
		return false
	}
	if this.IsTemporary != that1.IsTemporary {
		return false
	}
	if this.IsPublic != that1.IsPublic {
		return false
	}
	if this.IsVirtual != that1.IsVirtual {
		return false
	}
	return true
}
func (this *Database) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Database)
	if !ok {
		that2, ok := that.(Database)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	return true
}
func (this *Namespace) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Namespace)
	if !ok {
		that2, ok := that.(Namespace)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	if this.SchemaID != that1.SchemaID {
		return false
	}
	if this.DescriptorID != that1.DescriptorID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *Owner) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Owner)
	if !ok {
		that2, ok := that.(Owner)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DescriptorID != that1.DescriptorID {
		return false
	}
	if this.Owner != that1.Owner {
		return false
	}
	return true
}
func (this *UserPrivileges) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserPrivileges)
	if !ok {
		that2, ok := that.(UserPrivileges)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DescriptorID != that1.DescriptorID {
		return false
	}
	if this.UserName != that1.UserName {
		return false
	}
	if this.Privileges != that1.Privileges {
		return false
	}
	if this.WithGrantOption != that1.WithGrantOption {
		return false
	}
	return true
}
func (this *TableLocalityGlobal) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableLocalityGlobal)
	if !ok {
		that2, ok := that.(TableLocalityGlobal)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	return true
}
func (this *TableLocalityPrimaryRegion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableLocalityPrimaryRegion)
	if !ok {
		that2, ok := that.(TableLocalityPrimaryRegion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	return true
}
func (this *TableLocalitySecondaryRegion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableLocalitySecondaryRegion)
	if !ok {
		that2, ok := that.(TableLocalitySecondaryRegion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.RegionEnumTypeID != that1.RegionEnumTypeID {
		return false
	}
	if this.RegionName != that1.RegionName {
		return false
	}
	return true
}
func (this *TableLocalityRegionalByRow) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableLocalityRegionalByRow)
	if !ok {
		that2, ok := that.(TableLocalityRegionalByRow)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.As != that1.As {
		return false
	}
	return true
}
func (this *IndexPartitioning) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndexPartitioning)
	if !ok {
		that2, ok := that.(IndexPartitioning)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if !this.PartitioningDescriptor.Equal(&that1.PartitioningDescriptor) {
		return false
	}
	return true
}
func (this *RowLevelTTL) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RowLevelTTL)
	if !ok {
		that2, ok := that.(RowLevelTTL)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if !this.RowLevelTTL.Equal(&that1.RowLevelTTL) {
		return false
	}
	return true
}
func (this *ColumnName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnName)
	if !ok {
		that2, ok := that.(ColumnName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *IndexName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndexName)
	if !ok {
		that2, ok := that.(IndexName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *ConstraintWithoutIndexName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConstraintWithoutIndexName)
	if !ok {
		that2, ok := that.(ConstraintWithoutIndexName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *TableComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableComment)
	if !ok {
		that2, ok := that.(TableComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *DatabaseComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DatabaseComment)
	if !ok {
		that2, ok := that.(DatabaseComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *SchemaComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SchemaComment)
	if !ok {
		that2, ok := that.(SchemaComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SchemaID != that1.SchemaID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *IndexComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndexComment)
	if !ok {
		that2, ok := that.(IndexComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *ColumnComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnComment)
	if !ok {
		that2, ok := that.(ColumnComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	if this.PgAttributeNum != that1.PgAttributeNum {
		return false
	}
	return true
}
func (this *ColumnNotNull) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ColumnNotNull)
	if !ok {
		that2, ok := that.(ColumnNotNull)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.IndexIDForValidation != that1.IndexIDForValidation {
		return false
	}
	return true
}
func (this *ConstraintComment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConstraintComment)
	if !ok {
		that2, ok := that.(ConstraintComment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.ConstraintID != that1.ConstraintID {
		return false
	}
	if this.Comment != that1.Comment {
		return false
	}
	return true
}
func (this *DatabaseRegionConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DatabaseRegionConfig)
	if !ok {
		that2, ok := that.(DatabaseRegionConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	if this.RegionEnumTypeID != that1.RegionEnumTypeID {
		return false
	}
	return true
}
func (this *DatabaseRoleSetting) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DatabaseRoleSetting)
	if !ok {
		that2, ok := that.(DatabaseRoleSetting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	if this.RoleName != that1.RoleName {
		return false
	}
	return true
}
func (this *IndexColumn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndexColumn)
	if !ok {
		that2, ok := that.(IndexColumn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if this.ColumnID != that1.ColumnID {
		return false
	}
	if this.OrdinalInKind != that1.OrdinalInKind {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Direction != that1.Direction {
		return false
	}
	if this.Implicit != that1.Implicit {
		return false
	}
	if this.InvertedKind != that1.InvertedKind {
		return false
	}
	return true
}
func (this *EnumTypeValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EnumTypeValue)
	if !ok {
		that2, ok := that.(EnumTypeValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TypeID != that1.TypeID {
		return false
	}
	if !bytes.Equal(this.PhysicalRepresentation, that1.PhysicalRepresentation) {
		return false
	}
	if this.LogicalRepresentation != that1.LogicalRepresentation {
		return false
	}
	return true
}
func (this *CompositeTypeAttrName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CompositeTypeAttrName)
	if !ok {
		that2, ok := that.(CompositeTypeAttrName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CompositeTypeID != that1.CompositeTypeID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *CompositeTypeAttrType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CompositeTypeAttrType)
	if !ok {
		that2, ok := that.(CompositeTypeAttrType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CompositeTypeID != that1.CompositeTypeID {
		return false
	}
	if !this.TypeT.Equal(&that1.TypeT) {
		return false
	}
	return true
}
func (this *TableZoneConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableZoneConfig)
	if !ok {
		that2, ok := that.(TableZoneConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	return true
}
func (this *IndexZoneConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndexZoneConfig)
	if !ok {
		that2, ok := that.(IndexZoneConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	if this.PartitionName != that1.PartitionName {
		return false
	}
	return true
}
func (this *DatabaseData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DatabaseData)
	if !ok {
		that2, ok := that.(DatabaseData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	return true
}
func (this *TableData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableData)
	if !ok {
		that2, ok := that.(TableData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.DatabaseID != that1.DatabaseID {
		return false
	}
	return true
}
func (this *IndexData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IndexData)
	if !ok {
		that2, ok := that.(IndexData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	return true
}
func (this *TablePartitioning) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TablePartitioning)
	if !ok {
		that2, ok := that.(TablePartitioning)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	return true
}
func (this *TableSchemaLocked) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableSchemaLocked)
	if !ok {
		that2, ok := that.(TableSchemaLocked)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	return true
}
func (this *Function) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Function)
	if !ok {
		that2, ok := that.(Function)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FunctionID != that1.FunctionID {
		return false
	}
	if len(this.Params) != len(that1.Params) {
		return false
	}
	for i := range this.Params {
		if !this.Params[i].Equal(&that1.Params[i]) {
			return false
		}
	}
	if this.ReturnSet != that1.ReturnSet {
		return false
	}
	if !this.ReturnType.Equal(&that1.ReturnType) {
		return false
	}
	if this.IsProcedure != that1.IsProcedure {
		return false
	}
	return true
}
func (this *Function_Parameter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Function_Parameter)
	if !ok {
		that2, ok := that.(Function_Parameter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.Class.Equal(&that1.Class) {
		return false
	}
	if !this.Type.Equal(&that1.Type) {
		return false
	}
	if this.DefaultExpr != that1.DefaultExpr {
		return false
	}
	return true
}
func (this *FunctionName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FunctionName)
	if !ok {
		that2, ok := that.(FunctionName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FunctionID != that1.FunctionID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *FunctionVolatility) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FunctionVolatility)
	if !ok {
		that2, ok := that.(FunctionVolatility)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FunctionID != that1.FunctionID {
		return false
	}
	if !this.Volatility.Equal(&that1.Volatility) {
		return false
	}
	return true
}
func (this *FunctionLeakProof) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FunctionLeakProof)
	if !ok {
		that2, ok := that.(FunctionLeakProof)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FunctionID != that1.FunctionID {
		return false
	}
	if this.LeakProof != that1.LeakProof {
		return false
	}
	return true
}
func (this *FunctionNullInputBehavior) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FunctionNullInputBehavior)
	if !ok {
		that2, ok := that.(FunctionNullInputBehavior)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FunctionID != that1.FunctionID {
		return false
	}
	if !this.NullInputBehavior.Equal(&that1.NullInputBehavior) {
		return false
	}
	return true
}
func (this *FunctionBody) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FunctionBody)
	if !ok {
		that2, ok := that.(FunctionBody)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FunctionID != that1.FunctionID {
		return false
	}
	if this.Body != that1.Body {
		return false
	}
	if !this.Lang.Equal(&that1.Lang) {
		return false
	}
	if len(this.UsesTables) != len(that1.UsesTables) {
		return false
	}
	for i := range this.UsesTables {
		if !this.UsesTables[i].Equal(&that1.UsesTables[i]) {
			return false
		}
	}
	if len(this.UsesViews) != len(that1.UsesViews) {
		return false
	}
	for i := range this.UsesViews {
		if !this.UsesViews[i].Equal(&that1.UsesViews[i]) {
			return false
		}
	}
	if len(this.UsesSequenceIDs) != len(that1.UsesSequenceIDs) {
		return false
	}
	for i := range this.UsesSequenceIDs {
		if this.UsesSequenceIDs[i] != that1.UsesSequenceIDs[i] {
			return false
		}
	}
	if len(this.UsesTypeIDs) != len(that1.UsesTypeIDs) {
		return false
	}
	for i := range this.UsesTypeIDs {
		if this.UsesTypeIDs[i] != that1.UsesTypeIDs[i] {
			return false
		}
	}
	if len(this.UsesFunctionIDs) != len(that1.UsesFunctionIDs) {
		return false
	}
	for i := range this.UsesFunctionIDs {
		if this.UsesFunctionIDs[i] != that1.UsesFunctionIDs[i] {
			return false
		}
	}
	return true
}
func (this *FunctionBody_TableReference) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FunctionBody_TableReference)
	if !ok {
		that2, ok := that.(FunctionBody_TableReference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableID != that1.TableID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	if this.IndexID != that1.IndexID {
		return false
	}
	return true
}
func (this *FunctionBody_ViewReference) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FunctionBody_ViewReference)
	if !ok {
		that2, ok := that.(FunctionBody_ViewReference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ViewID != that1.ViewID {
		return false
	}
	if len(this.ColumnIDs) != len(that1.ColumnIDs) {
		return false
	}
	for i := range this.ColumnIDs {
		if this.ColumnIDs[i] != that1.ColumnIDs[i] {
			return false
		}
	}
	return true
}
func (this *ElementCreationMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ElementCreationMetadata)
	if !ok {
		that2, ok := that.(ElementCreationMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.In_23_1OrLater != that1.In_23_1OrLater {
		return false
	}
	return true
}
func (m *ElementProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ElementProto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ElementOneOf != nil {
		{
			size := m.ElementOneOf.Size()
			i -= size
			if _, err := m.ElementOneOf.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ElementProto_Database) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_Database) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Database != nil {
		{
			size, err := m.Database.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_Schema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_Schema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Schema != nil {
		{
			size, err := m.Schema.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_View) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_View) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.View != nil {
		{
			size, err := m.View.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_Sequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_Sequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Sequence != nil {
		{
			size, err := m.Sequence.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_Table) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_Table) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Table != nil {
		{
			size, err := m.Table.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_EnumType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_EnumType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnumType != nil {
		{
			size, err := m.EnumType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_AliasType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_AliasType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AliasType != nil {
		{
			size, err := m.AliasType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_CompositeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_CompositeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CompositeType != nil {
		{
			size, err := m.CompositeType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_Function) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_Function) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Function != nil {
		{
			size, err := m.Function.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ColumnFamily) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ColumnFamily) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ColumnFamily != nil {
		{
			size, err := m.ColumnFamily.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Column != nil {
		{
			size, err := m.Column.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_PrimaryIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_PrimaryIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PrimaryIndex != nil {
		{
			size, err := m.PrimaryIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_SecondaryIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_SecondaryIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SecondaryIndex != nil {
		{
			size, err := m.SecondaryIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TemporaryIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TemporaryIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TemporaryIndex != nil {
		{
			size, err := m.TemporaryIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_UniqueWithoutIndexConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_UniqueWithoutIndexConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UniqueWithoutIndexConstraint != nil {
		{
			size, err := m.UniqueWithoutIndexConstraint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_CheckConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_CheckConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckConstraint != nil {
		{
			size, err := m.CheckConstraint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ForeignKeyConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ForeignKeyConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ForeignKeyConstraint != nil {
		{
			size, err := m.ForeignKeyConstraint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TableComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TableComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TableComment != nil {
		{
			size, err := m.TableComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_RowLevelTTL) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_RowLevelTTL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RowLevelTTL != nil {
		{
			size, err := m.RowLevelTTL.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ColumnName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ColumnName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ColumnName != nil {
		{
			size, err := m.ColumnName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ColumnType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ColumnType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ColumnType != nil {
		{
			size, err := m.ColumnType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ColumnDefaultExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ColumnDefaultExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ColumnDefaultExpression != nil {
		{
			size, err := m.ColumnDefaultExpression.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ColumnOnUpdateExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ColumnOnUpdateExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ColumnOnUpdateExpression != nil {
		{
			size, err := m.ColumnOnUpdateExpression.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_SequenceOwner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_SequenceOwner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SequenceOwner != nil {
		{
			size, err := m.SequenceOwner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ColumnComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ColumnComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ColumnComment != nil {
		{
			size, err := m.ColumnComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ColumnNotNull) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ColumnNotNull) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ColumnNotNull != nil {
		{
			size, err := m.ColumnNotNull.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_SequenceOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_SequenceOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SequenceOption != nil {
		{
			size, err := m.SequenceOption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_IndexName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_IndexName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IndexName != nil {
		{
			size, err := m.IndexName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_IndexPartitioning) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_IndexPartitioning) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IndexPartitioning != nil {
		{
			size, err := m.IndexPartitioning.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_SecondaryIndexPartial) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_SecondaryIndexPartial) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SecondaryIndexPartial != nil {
		{
			size, err := m.SecondaryIndexPartial.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_IndexComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_IndexComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IndexComment != nil {
		{
			size, err := m.IndexComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_IndexColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_IndexColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IndexColumn != nil {
		{
			size, err := m.IndexColumn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_IndexData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_IndexData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IndexData != nil {
		{
			size, err := m.IndexData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ConstraintWithoutIndexName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ConstraintWithoutIndexName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConstraintWithoutIndexName != nil {
		{
			size, err := m.ConstraintWithoutIndexName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ConstraintComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ConstraintComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConstraintComment != nil {
		{
			size, err := m.ConstraintComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_Namespace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_Namespace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Namespace != nil {
		{
			size, err := m.Namespace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_Owner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_Owner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Owner != nil {
		{
			size, err := m.Owner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_UserPrivileges) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_UserPrivileges) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UserPrivileges != nil {
		{
			size, err := m.UserPrivileges.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_DatabaseRegionConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_DatabaseRegionConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DatabaseRegionConfig != nil {
		{
			size, err := m.DatabaseRegionConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_DatabaseRoleSetting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_DatabaseRoleSetting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DatabaseRoleSetting != nil {
		{
			size, err := m.DatabaseRoleSetting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_DatabaseComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_DatabaseComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DatabaseComment != nil {
		{
			size, err := m.DatabaseComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_DatabaseData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_DatabaseData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DatabaseData != nil {
		{
			size, err := m.DatabaseData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_SchemaParent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_SchemaParent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SchemaParent != nil {
		{
			size, err := m.SchemaParent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_SchemaComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_SchemaComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SchemaComment != nil {
		{
			size, err := m.SchemaComment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_SchemaChild) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_SchemaChild) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SchemaChild != nil {
		{
			size, err := m.SchemaChild.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TableLocalityGlobal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TableLocalityGlobal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TableLocalityGlobal != nil {
		{
			size, err := m.TableLocalityGlobal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TableLocalityPrimaryRegion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TableLocalityPrimaryRegion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TableLocalityPrimaryRegion != nil {
		{
			size, err := m.TableLocalityPrimaryRegion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TableLocalitySecondaryRegion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TableLocalitySecondaryRegion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TableLocalitySecondaryRegion != nil {
		{
			size, err := m.TableLocalitySecondaryRegion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TableLocalityRegionalByRow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TableLocalityRegionalByRow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TableLocalityRegionalByRow != nil {
		{
			size, err := m.TableLocalityRegionalByRow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_EnumTypeValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_EnumTypeValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnumTypeValue != nil {
		{
			size, err := m.EnumTypeValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TableZoneConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TableZoneConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TableZoneConfig != nil {
		{
			size, err := m.TableZoneConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_IndexZoneConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_IndexZoneConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IndexZoneConfig != nil {
		{
			size, err := m.IndexZoneConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TableData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TableData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TableData != nil {
		{
			size, err := m.TableData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TablePartitioning) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TablePartitioning) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TablePartitioning != nil {
		{
			size, err := m.TablePartitioning.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_TableSchemaLocked) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_TableSchemaLocked) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TableSchemaLocked != nil {
		{
			size, err := m.TableSchemaLocked.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_CompositeTypeAttrType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_CompositeTypeAttrType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CompositeTypeAttrType != nil {
		{
			size, err := m.CompositeTypeAttrType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_CompositeTypeAttrName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_CompositeTypeAttrName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CompositeTypeAttrName != nil {
		{
			size, err := m.CompositeTypeAttrName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_FunctionName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_FunctionName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FunctionName != nil {
		{
			size, err := m.FunctionName.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_FunctionVolatility) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_FunctionVolatility) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FunctionVolatility != nil {
		{
			size, err := m.FunctionVolatility.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_FunctionLeakProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_FunctionLeakProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FunctionLeakProof != nil {
		{
			size, err := m.FunctionLeakProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_FunctionNullInputBehavior) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_FunctionNullInputBehavior) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FunctionNullInputBehavior != nil {
		{
			size, err := m.FunctionNullInputBehavior.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_FunctionBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_FunctionBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FunctionBody != nil {
		{
			size, err := m.FunctionBody.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_CheckConstraintUnvalidated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_CheckConstraintUnvalidated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CheckConstraintUnvalidated != nil {
		{
			size, err := m.CheckConstraintUnvalidated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_UniqueWithoutIndexConstraintUnvalidated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_UniqueWithoutIndexConstraintUnvalidated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UniqueWithoutIndexConstraintUnvalidated != nil {
		{
			size, err := m.UniqueWithoutIndexConstraintUnvalidated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *ElementProto_ForeignKeyConstraintUnvalidated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementProto_ForeignKeyConstraintUnvalidated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ForeignKeyConstraintUnvalidated != nil {
		{
			size, err := m.ForeignKeyConstraintUnvalidated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *TypeT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypeT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClosedTypeIDs) > 0 {
		dAtA67 := make([]byte, len(m.ClosedTypeIDs)*10)
		var j66 int
		for _, num := range m.ClosedTypeIDs {
			for num >= 1<<7 {
				dAtA67[j66] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j66++
			}
			dAtA67[j66] = uint8(num)
			j66++
		}
		i -= j66
		copy(dAtA[i:], dAtA67[:j66])
		i = encodeVarintElements(dAtA, i, uint64(j66))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Expression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UsesFunctionIDs) > 0 {
		dAtA70 := make([]byte, len(m.UsesFunctionIDs)*10)
		var j69 int
		for _, num := range m.UsesFunctionIDs {
			for num >= 1<<7 {
				dAtA70[j69] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j69++
			}
			dAtA70[j69] = uint8(num)
			j69++
		}
		i -= j69
		copy(dAtA[i:], dAtA70[:j69])
		i = encodeVarintElements(dAtA, i, uint64(j69))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ReferencedColumnIDs) > 0 {
		dAtA72 := make([]byte, len(m.ReferencedColumnIDs)*10)
		var j71 int
		for _, num := range m.ReferencedColumnIDs {
			for num >= 1<<7 {
				dAtA72[j71] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j71++
			}
			dAtA72[j71] = uint8(num)
			j71++
		}
		i -= j71
		copy(dAtA[i:], dAtA72[:j71])
		i = encodeVarintElements(dAtA, i, uint64(j71))
		i--
		dAtA[i] = 0x22
	}
	if len(m.UsesSequenceIDs) > 0 {
		dAtA74 := make([]byte, len(m.UsesSequenceIDs)*10)
		var j73 int
		for _, num := range m.UsesSequenceIDs {
			for num >= 1<<7 {
				dAtA74[j73] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j73++
			}
			dAtA74[j73] = uint8(num)
			j73++
		}
		i -= j73
		copy(dAtA[i:], dAtA74[:j73])
		i = encodeVarintElements(dAtA, i, uint64(j73))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UsesTypeIDs) > 0 {
		dAtA76 := make([]byte, len(m.UsesTypeIDs)*10)
		var j75 int
		for _, num := range m.UsesTypeIDs {
			for num >= 1<<7 {
				dAtA76[j75] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j75++
			}
			dAtA76[j75] = uint8(num)
			j75++
		}
		i -= j75
		copy(dAtA[i:], dAtA76[:j75])
		i = encodeVarintElements(dAtA, i, uint64(j75))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Expr) > 0 {
		i -= len(m.Expr)
		copy(dAtA[i:], m.Expr)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Expr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Column) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsSystemColumn {
		i--
		if m.IsSystemColumn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.PgAttributeNum != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.PgAttributeNum))
		i--
		dAtA[i] = 0x38
	}
	if len(m.GeneratedAsIdentitySequenceOption) > 0 {
		i -= len(m.GeneratedAsIdentitySequenceOption)
		copy(dAtA[i:], m.GeneratedAsIdentitySequenceOption)
		i = encodeVarintElements(dAtA, i, uint64(len(m.GeneratedAsIdentitySequenceOption)))
		i--
		dAtA[i] = 0x32
	}
	if m.GeneratedAsIdentityType != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.GeneratedAsIdentityType))
		i--
		dAtA[i] = 0x28
	}
	if m.IsInaccessible {
		i--
		if m.IsInaccessible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.IsHidden {
		i--
		if m.IsHidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ElementCreationMetadata != nil {
		{
			size, err := m.ElementCreationMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.IsVirtual {
		i--
		if m.IsVirtual {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.ComputeExpr != nil {
		{
			size, err := m.ComputeExpr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.IsNullable {
		i--
		if m.IsNullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.TypeT.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x18
	}
	if m.FamilyID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FamilyID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnFamily) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnFamily) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnFamily) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.FamilyID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FamilyID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Index) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Index) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Index) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Invisibility != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Invisibility))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc9
	}
	if m.GeoConfig != nil {
		{
			size, err := m.GeoConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.IsNotVisible {
		i--
		if m.IsNotVisible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.TemporaryIndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TemporaryIndexID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.SourceIndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SourceIndexID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.IsConcurrently {
		i--
		if m.IsConcurrently {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x70
	}
	if m.IsCreatedExplicitly {
		i--
		if m.IsCreatedExplicitly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.Sharding != nil {
		{
			size, err := m.Sharding.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.IsInverted {
		i--
		if m.IsInverted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.IsUnique {
		i--
		if m.IsUnique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrimaryIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimaryIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrimaryIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Index.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SecondaryIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecondaryIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecondaryIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RecreateSourceIndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.RecreateSourceIndexID))
		i--
		dAtA[i] = 0x20
	}
	if m.EmbeddedExpr != nil {
		{
			size, err := m.EmbeddedExpr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Index.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TemporaryIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TemporaryIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TemporaryIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expr != nil {
		{
			size, err := m.Expr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IsUsingSecondaryEncoding {
		i--
		if m.IsUsingSecondaryEncoding {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Index.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SecondaryIndexPartial) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecondaryIndexPartial) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecondaryIndexPartial) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Expression.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SchemaParent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaParent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaParent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ParentDatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ParentDatabaseID))
		i--
		dAtA[i] = 0x10
	}
	if m.SchemaID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SchemaID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SchemaChild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaChild) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaChild) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SchemaID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SchemaID))
		i--
		dAtA[i] = 0x10
	}
	if m.ChildObjectID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ChildObjectID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Sequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsTemporary {
		i--
		if m.IsTemporary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.UseRestartWith {
		i--
		if m.UseRestartWith {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.RestartWith != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.RestartWith))
		i--
		dAtA[i] = 0x10
	}
	if m.SequenceID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SequenceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SequenceOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SequenceOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SequenceOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.SequenceID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SequenceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SequenceOwner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SequenceOwner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SequenceOwner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x18
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x10
	}
	if m.SequenceID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SequenceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnDefaultExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnDefaultExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnDefaultExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Expression.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnOnUpdateExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnOnUpdateExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnOnUpdateExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Expression.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *View) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *View) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *View) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsMaterialized {
		i--
		if m.IsMaterialized {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.IsTemporary {
		i--
		if m.IsTemporary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.ForwardReferences) > 0 {
		for iNdEx := len(m.ForwardReferences) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForwardReferences[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintElements(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.UsesRelationIDs) > 0 {
		dAtA91 := make([]byte, len(m.UsesRelationIDs)*10)
		var j90 int
		for _, num := range m.UsesRelationIDs {
			for num >= 1<<7 {
				dAtA91[j90] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j90++
			}
			dAtA91[j90] = uint8(num)
			j90++
		}
		i -= j90
		copy(dAtA[i:], dAtA91[:j90])
		i = encodeVarintElements(dAtA, i, uint64(j90))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UsesTypeIDs) > 0 {
		dAtA93 := make([]byte, len(m.UsesTypeIDs)*10)
		var j92 int
		for _, num := range m.UsesTypeIDs {
			for num >= 1<<7 {
				dAtA93[j92] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j92++
			}
			dAtA93[j92] = uint8(num)
			j92++
		}
		i -= j92
		copy(dAtA[i:], dAtA93[:j92])
		i = encodeVarintElements(dAtA, i, uint64(j92))
		i--
		dAtA[i] = 0x12
	}
	if m.ViewID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ViewID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *View_Reference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *View_Reference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *View_Reference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ColumnIDs) > 0 {
		dAtA95 := make([]byte, len(m.ColumnIDs)*10)
		var j94 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA95[j94] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j94++
			}
			dAtA95[j94] = uint8(num)
			j94++
		}
		i -= j94
		copy(dAtA[i:], dAtA95[:j94])
		i = encodeVarintElements(dAtA, i, uint64(j94))
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.ToID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ToID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Table) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Table) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Table) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsTemporary {
		i--
		if m.IsTemporary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UniqueWithoutIndexConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UniqueWithoutIndexConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UniqueWithoutIndexConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexIDForValidation != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexIDForValidation))
		i--
		dAtA[i] = 0x28
	}
	if m.Predicate != nil {
		{
			size, err := m.Predicate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ColumnIDs) > 0 {
		dAtA98 := make([]byte, len(m.ColumnIDs)*10)
		var j97 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA98[j97] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j97++
			}
			dAtA98[j97] = uint8(num)
			j97++
		}
		i -= j97
		copy(dAtA[i:], dAtA98[:j97])
		i = encodeVarintElements(dAtA, i, uint64(j97))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UniqueWithoutIndexConstraintUnvalidated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UniqueWithoutIndexConstraintUnvalidated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UniqueWithoutIndexConstraintUnvalidated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Predicate != nil {
		{
			size, err := m.Predicate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintElements(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ColumnIDs) > 0 {
		dAtA101 := make([]byte, len(m.ColumnIDs)*10)
		var j100 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA101[j100] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j100++
			}
			dAtA101[j100] = uint8(num)
			j100++
		}
		i -= j100
		copy(dAtA[i:], dAtA101[:j100])
		i = encodeVarintElements(dAtA, i, uint64(j100))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CheckConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexIDForValidation != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexIDForValidation))
		i--
		dAtA[i] = 0x30
	}
	if m.FromHashShardedColumn {
		i--
		if m.FromHashShardedColumn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.Expression.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.ColumnIDs) > 0 {
		dAtA104 := make([]byte, len(m.ColumnIDs)*10)
		var j103 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA104[j103] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j103++
			}
			dAtA104[j103] = uint8(num)
			j103++
		}
		i -= j103
		copy(dAtA[i:], dAtA104[:j103])
		i = encodeVarintElements(dAtA, i, uint64(j103))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CheckConstraintUnvalidated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckConstraintUnvalidated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckConstraintUnvalidated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Expression.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.ColumnIDs) > 0 {
		dAtA107 := make([]byte, len(m.ColumnIDs)*10)
		var j106 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA107[j106] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j106++
			}
			dAtA107[j106] = uint8(num)
			j106++
		}
		i -= j106
		copy(dAtA[i:], dAtA107[:j106])
		i = encodeVarintElements(dAtA, i, uint64(j106))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ForeignKeyConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForeignKeyConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForeignKeyConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexIDForValidation != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexIDForValidation))
		i--
		dAtA[i] = 0x48
	}
	if m.CompositeKeyMatchMethod != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.CompositeKeyMatchMethod))
		i--
		dAtA[i] = 0x40
	}
	if m.OnDeleteAction != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.OnDeleteAction))
		i--
		dAtA[i] = 0x38
	}
	if m.OnUpdateAction != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.OnUpdateAction))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ReferencedColumnIDs) > 0 {
		dAtA109 := make([]byte, len(m.ReferencedColumnIDs)*10)
		var j108 int
		for _, num := range m.ReferencedColumnIDs {
			for num >= 1<<7 {
				dAtA109[j108] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j108++
			}
			dAtA109[j108] = uint8(num)
			j108++
		}
		i -= j108
		copy(dAtA[i:], dAtA109[:j108])
		i = encodeVarintElements(dAtA, i, uint64(j108))
		i--
		dAtA[i] = 0x2a
	}
	if m.ReferencedTableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ReferencedTableID))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ColumnIDs) > 0 {
		dAtA111 := make([]byte, len(m.ColumnIDs)*10)
		var j110 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA111[j110] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j110++
			}
			dAtA111[j110] = uint8(num)
			j110++
		}
		i -= j110
		copy(dAtA[i:], dAtA111[:j110])
		i = encodeVarintElements(dAtA, i, uint64(j110))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ForeignKeyConstraintUnvalidated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForeignKeyConstraintUnvalidated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForeignKeyConstraintUnvalidated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CompositeKeyMatchMethod != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.CompositeKeyMatchMethod))
		i--
		dAtA[i] = 0x40
	}
	if m.OnDeleteAction != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.OnDeleteAction))
		i--
		dAtA[i] = 0x38
	}
	if m.OnUpdateAction != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.OnUpdateAction))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ReferencedColumnIDs) > 0 {
		dAtA113 := make([]byte, len(m.ReferencedColumnIDs)*10)
		var j112 int
		for _, num := range m.ReferencedColumnIDs {
			for num >= 1<<7 {
				dAtA113[j112] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j112++
			}
			dAtA113[j112] = uint8(num)
			j112++
		}
		i -= j112
		copy(dAtA[i:], dAtA113[:j112])
		i = encodeVarintElements(dAtA, i, uint64(j112))
		i--
		dAtA[i] = 0x2a
	}
	if m.ReferencedTableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ReferencedTableID))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ColumnIDs) > 0 {
		dAtA115 := make([]byte, len(m.ColumnIDs)*10)
		var j114 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA115[j114] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j114++
			}
			dAtA115[j114] = uint8(num)
			j114++
		}
		i -= j114
		copy(dAtA[i:], dAtA115[:j114])
		i = encodeVarintElements(dAtA, i, uint64(j114))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EnumType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnumType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnumType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsMultiRegion {
		i--
		if m.IsMultiRegion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ArrayTypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ArrayTypeID))
		i--
		dAtA[i] = 0x10
	}
	if m.TypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AliasType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AliasType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AliasType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TypeT.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.TypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CompositeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompositeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompositeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ArrayTypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ArrayTypeID))
		i--
		dAtA[i] = 0x10
	}
	if m.TypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Schema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Schema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsVirtual {
		i--
		if m.IsVirtual {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.IsPublic {
		i--
		if m.IsPublic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.IsTemporary {
		i--
		if m.IsTemporary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.SchemaID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SchemaID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Database) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Database) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Database) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Namespace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Namespace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Namespace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.DescriptorID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DescriptorID))
		i--
		dAtA[i] = 0x18
	}
	if m.SchemaID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SchemaID))
		i--
		dAtA[i] = 0x10
	}
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Owner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Owner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Owner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if m.DescriptorID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DescriptorID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserPrivileges) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPrivileges) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserPrivileges) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WithGrantOption != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.WithGrantOption))
		i--
		dAtA[i] = 0x20
	}
	if m.Privileges != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.Privileges))
		i--
		dAtA[i] = 0x18
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintElements(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x12
	}
	if m.DescriptorID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DescriptorID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableLocalityGlobal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableLocalityGlobal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableLocalityGlobal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableLocalityPrimaryRegion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableLocalityPrimaryRegion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableLocalityPrimaryRegion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableLocalitySecondaryRegion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableLocalitySecondaryRegion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableLocalitySecondaryRegion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RegionName) > 0 {
		i -= len(m.RegionName)
		copy(dAtA[i:], m.RegionName)
		i = encodeVarintElements(dAtA, i, uint64(len(m.RegionName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RegionEnumTypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.RegionEnumTypeID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableLocalityRegionalByRow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableLocalityRegionalByRow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableLocalityRegionalByRow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.As) > 0 {
		i -= len(m.As)
		copy(dAtA[i:], m.As)
		i = encodeVarintElements(dAtA, i, uint64(len(m.As)))
		i--
		dAtA[i] = 0x12
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexPartitioning) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexPartitioning) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexPartitioning) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PartitioningDescriptor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RowLevelTTL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowLevelTTL) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowLevelTTL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RowLevelTTL.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConstraintWithoutIndexName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConstraintWithoutIndexName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConstraintWithoutIndexName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x12
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SchemaComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x12
	}
	if m.SchemaID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.SchemaID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PgAttributeNum != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.PgAttributeNum))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnNotNull) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnNotNull) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnNotNull) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexIDForValidation != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexIDForValidation))
		i--
		dAtA[i] = 0x18
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConstraintComment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConstraintComment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConstraintComment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comment) > 0 {
		i -= len(m.Comment)
		copy(dAtA[i:], m.Comment)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Comment)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConstraintID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ConstraintID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseRegionConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseRegionConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseRegionConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RegionEnumTypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.RegionEnumTypeID))
		i--
		dAtA[i] = 0x10
	}
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseRoleSetting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseRoleSetting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseRoleSetting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RoleName) > 0 {
		i -= len(m.RoleName)
		copy(dAtA[i:], m.RoleName)
		i = encodeVarintElements(dAtA, i, uint64(len(m.RoleName)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexColumn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InvertedKind != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.InvertedKind))
		i--
		dAtA[i] = 0x40
	}
	if m.Implicit {
		i--
		if m.Implicit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Direction != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x30
	}
	if m.Kind != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x28
	}
	if m.OrdinalInKind != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.OrdinalInKind))
		i--
		dAtA[i] = 0x20
	}
	if m.ColumnID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ColumnID))
		i--
		dAtA[i] = 0x18
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EnumTypeValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnumTypeValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnumTypeValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LogicalRepresentation) > 0 {
		i -= len(m.LogicalRepresentation)
		copy(dAtA[i:], m.LogicalRepresentation)
		i = encodeVarintElements(dAtA, i, uint64(len(m.LogicalRepresentation)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PhysicalRepresentation) > 0 {
		i -= len(m.PhysicalRepresentation)
		copy(dAtA[i:], m.PhysicalRepresentation)
		i = encodeVarintElements(dAtA, i, uint64(len(m.PhysicalRepresentation)))
		i--
		dAtA[i] = 0x12
	}
	if m.TypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CompositeTypeAttrName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompositeTypeAttrName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompositeTypeAttrName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.CompositeTypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.CompositeTypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CompositeTypeAttrType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompositeTypeAttrType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompositeTypeAttrType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TypeT.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.CompositeTypeID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.CompositeTypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableZoneConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableZoneConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableZoneConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexZoneConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexZoneConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexZoneConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PartitionName) > 0 {
		i -= len(m.PartitionName)
		copy(dAtA[i:], m.PartitionName)
		i = encodeVarintElements(dAtA, i, uint64(len(m.PartitionName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DatabaseID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.DatabaseID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TablePartitioning) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TablePartitioning) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TablePartitioning) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableSchemaLocked) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableSchemaLocked) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableSchemaLocked) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Function) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Function) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Function) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsProcedure {
		i--
		if m.IsProcedure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.ReturnType.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.ReturnSet {
		i--
		if m.ReturnSet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Params) > 0 {
		for iNdEx := len(m.Params) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Params[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintElements(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.FunctionID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FunctionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Function_Parameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Function_Parameter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Function_Parameter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DefaultExpr) > 0 {
		i -= len(m.DefaultExpr)
		copy(dAtA[i:], m.DefaultExpr)
		i = encodeVarintElements(dAtA, i, uint64(len(m.DefaultExpr)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Class.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FunctionName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FunctionName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.FunctionID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FunctionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FunctionVolatility) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionVolatility) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FunctionVolatility) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Volatility.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.FunctionID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FunctionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FunctionLeakProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionLeakProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FunctionLeakProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LeakProof {
		i--
		if m.LeakProof {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.FunctionID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FunctionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FunctionNullInputBehavior) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionNullInputBehavior) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FunctionNullInputBehavior) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.NullInputBehavior.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if m.FunctionID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FunctionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FunctionBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FunctionBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UsesFunctionIDs) > 0 {
		dAtA126 := make([]byte, len(m.UsesFunctionIDs)*10)
		var j125 int
		for _, num := range m.UsesFunctionIDs {
			for num >= 1<<7 {
				dAtA126[j125] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j125++
			}
			dAtA126[j125] = uint8(num)
			j125++
		}
		i -= j125
		copy(dAtA[i:], dAtA126[:j125])
		i = encodeVarintElements(dAtA, i, uint64(j125))
		i--
		dAtA[i] = 0x42
	}
	if len(m.UsesTypeIDs) > 0 {
		dAtA128 := make([]byte, len(m.UsesTypeIDs)*10)
		var j127 int
		for _, num := range m.UsesTypeIDs {
			for num >= 1<<7 {
				dAtA128[j127] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j127++
			}
			dAtA128[j127] = uint8(num)
			j127++
		}
		i -= j127
		copy(dAtA[i:], dAtA128[:j127])
		i = encodeVarintElements(dAtA, i, uint64(j127))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.UsesSequenceIDs) > 0 {
		dAtA130 := make([]byte, len(m.UsesSequenceIDs)*10)
		var j129 int
		for _, num := range m.UsesSequenceIDs {
			for num >= 1<<7 {
				dAtA130[j129] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j129++
			}
			dAtA130[j129] = uint8(num)
			j129++
		}
		i -= j129
		copy(dAtA[i:], dAtA130[:j129])
		i = encodeVarintElements(dAtA, i, uint64(j129))
		i--
		dAtA[i] = 0x32
	}
	if len(m.UsesViews) > 0 {
		for iNdEx := len(m.UsesViews) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UsesViews[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintElements(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.UsesTables) > 0 {
		for iNdEx := len(m.UsesTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UsesTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintElements(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size, err := m.Lang.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintElements(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintElements(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x12
	}
	if m.FunctionID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.FunctionID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FunctionBody_TableReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionBody_TableReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FunctionBody_TableReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.IndexID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ColumnIDs) > 0 {
		dAtA133 := make([]byte, len(m.ColumnIDs)*10)
		var j132 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA133[j132] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j132++
			}
			dAtA133[j132] = uint8(num)
			j132++
		}
		i -= j132
		copy(dAtA[i:], dAtA133[:j132])
		i = encodeVarintElements(dAtA, i, uint64(j132))
		i--
		dAtA[i] = 0x12
	}
	if m.TableID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FunctionBody_ViewReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FunctionBody_ViewReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FunctionBody_ViewReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ColumnIDs) > 0 {
		dAtA135 := make([]byte, len(m.ColumnIDs)*10)
		var j134 int
		for _, num := range m.ColumnIDs {
			for num >= 1<<7 {
				dAtA135[j134] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j134++
			}
			dAtA135[j134] = uint8(num)
			j134++
		}
		i -= j134
		copy(dAtA[i:], dAtA135[:j134])
		i = encodeVarintElements(dAtA, i, uint64(j134))
		i--
		dAtA[i] = 0x12
	}
	if m.ViewID != 0 {
		i = encodeVarintElements(dAtA, i, uint64(m.ViewID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ElementCreationMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ElementCreationMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElementCreationMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.In_23_1OrLater {
		i--
		if m.In_23_1OrLater {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintElements(dAtA []byte, offset int, v uint64) int {
	offset -= sovElements(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ElementProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ElementOneOf != nil {
		n += m.ElementOneOf.Size()
	}
	return n
}

func (m *ElementProto_Database) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Database != nil {
		l = m.Database.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_Schema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Schema != nil {
		l = m.Schema.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_View) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.View != nil {
		l = m.View.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_Sequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sequence != nil {
		l = m.Sequence.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_Table) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Table != nil {
		l = m.Table.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_EnumType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnumType != nil {
		l = m.EnumType.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_AliasType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AliasType != nil {
		l = m.AliasType.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_CompositeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompositeType != nil {
		l = m.CompositeType.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_Function) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Function != nil {
		l = m.Function.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ColumnFamily) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnFamily != nil {
		l = m.ColumnFamily.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Column != nil {
		l = m.Column.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_PrimaryIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrimaryIndex != nil {
		l = m.PrimaryIndex.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_SecondaryIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SecondaryIndex != nil {
		l = m.SecondaryIndex.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TemporaryIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TemporaryIndex != nil {
		l = m.TemporaryIndex.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_UniqueWithoutIndexConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UniqueWithoutIndexConstraint != nil {
		l = m.UniqueWithoutIndexConstraint.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_CheckConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckConstraint != nil {
		l = m.CheckConstraint.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ForeignKeyConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForeignKeyConstraint != nil {
		l = m.ForeignKeyConstraint.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TableComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableComment != nil {
		l = m.TableComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_RowLevelTTL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RowLevelTTL != nil {
		l = m.RowLevelTTL.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ColumnName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnName != nil {
		l = m.ColumnName.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ColumnType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnType != nil {
		l = m.ColumnType.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ColumnDefaultExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnDefaultExpression != nil {
		l = m.ColumnDefaultExpression.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ColumnOnUpdateExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnOnUpdateExpression != nil {
		l = m.ColumnOnUpdateExpression.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_SequenceOwner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SequenceOwner != nil {
		l = m.SequenceOwner.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ColumnComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnComment != nil {
		l = m.ColumnComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ColumnNotNull) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnNotNull != nil {
		l = m.ColumnNotNull.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_SequenceOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SequenceOption != nil {
		l = m.SequenceOption.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_IndexName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexName != nil {
		l = m.IndexName.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_IndexPartitioning) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexPartitioning != nil {
		l = m.IndexPartitioning.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_SecondaryIndexPartial) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SecondaryIndexPartial != nil {
		l = m.SecondaryIndexPartial.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_IndexComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexComment != nil {
		l = m.IndexComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_IndexColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexColumn != nil {
		l = m.IndexColumn.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_IndexData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexData != nil {
		l = m.IndexData.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ConstraintWithoutIndexName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConstraintWithoutIndexName != nil {
		l = m.ConstraintWithoutIndexName.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ConstraintComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConstraintComment != nil {
		l = m.ConstraintComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_Namespace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Namespace != nil {
		l = m.Namespace.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_Owner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Owner != nil {
		l = m.Owner.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_UserPrivileges) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserPrivileges != nil {
		l = m.UserPrivileges.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_DatabaseRegionConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseRegionConfig != nil {
		l = m.DatabaseRegionConfig.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_DatabaseRoleSetting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseRoleSetting != nil {
		l = m.DatabaseRoleSetting.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_DatabaseComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseComment != nil {
		l = m.DatabaseComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_DatabaseData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseData != nil {
		l = m.DatabaseData.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_SchemaParent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaParent != nil {
		l = m.SchemaParent.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_SchemaComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaComment != nil {
		l = m.SchemaComment.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_SchemaChild) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaChild != nil {
		l = m.SchemaChild.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TableLocalityGlobal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableLocalityGlobal != nil {
		l = m.TableLocalityGlobal.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TableLocalityPrimaryRegion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableLocalityPrimaryRegion != nil {
		l = m.TableLocalityPrimaryRegion.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TableLocalitySecondaryRegion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableLocalitySecondaryRegion != nil {
		l = m.TableLocalitySecondaryRegion.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TableLocalityRegionalByRow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableLocalityRegionalByRow != nil {
		l = m.TableLocalityRegionalByRow.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_EnumTypeValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnumTypeValue != nil {
		l = m.EnumTypeValue.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TableZoneConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableZoneConfig != nil {
		l = m.TableZoneConfig.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_IndexZoneConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexZoneConfig != nil {
		l = m.IndexZoneConfig.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TableData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableData != nil {
		l = m.TableData.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TablePartitioning) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TablePartitioning != nil {
		l = m.TablePartitioning.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_TableSchemaLocked) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableSchemaLocked != nil {
		l = m.TableSchemaLocked.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_CompositeTypeAttrType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompositeTypeAttrType != nil {
		l = m.CompositeTypeAttrType.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_CompositeTypeAttrName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompositeTypeAttrName != nil {
		l = m.CompositeTypeAttrName.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_FunctionName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionName != nil {
		l = m.FunctionName.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_FunctionVolatility) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionVolatility != nil {
		l = m.FunctionVolatility.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_FunctionLeakProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionLeakProof != nil {
		l = m.FunctionLeakProof.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_FunctionNullInputBehavior) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionNullInputBehavior != nil {
		l = m.FunctionNullInputBehavior.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_FunctionBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionBody != nil {
		l = m.FunctionBody.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_CheckConstraintUnvalidated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckConstraintUnvalidated != nil {
		l = m.CheckConstraintUnvalidated.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_UniqueWithoutIndexConstraintUnvalidated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UniqueWithoutIndexConstraintUnvalidated != nil {
		l = m.UniqueWithoutIndexConstraintUnvalidated.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *ElementProto_ForeignKeyConstraintUnvalidated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForeignKeyConstraintUnvalidated != nil {
		l = m.ForeignKeyConstraintUnvalidated.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	return n
}
func (m *TypeT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if len(m.ClosedTypeIDs) > 0 {
		l = 0
		for _, e := range m.ClosedTypeIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	return n
}

func (m *Expression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Expr)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	if len(m.UsesTypeIDs) > 0 {
		l = 0
		for _, e := range m.UsesTypeIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.UsesSequenceIDs) > 0 {
		l = 0
		for _, e := range m.UsesSequenceIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.ReferencedColumnIDs) > 0 {
		l = 0
		for _, e := range m.ReferencedColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.UsesFunctionIDs) > 0 {
		l = 0
		for _, e := range m.UsesFunctionIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	return n
}

func (m *Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	if m.IsHidden {
		n += 2
	}
	if m.IsInaccessible {
		n += 2
	}
	if m.GeneratedAsIdentityType != 0 {
		n += 1 + sovElements(uint64(m.GeneratedAsIdentityType))
	}
	l = len(m.GeneratedAsIdentitySequenceOption)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	if m.PgAttributeNum != 0 {
		n += 1 + sovElements(uint64(m.PgAttributeNum))
	}
	if m.IsSystemColumn {
		n += 2
	}
	return n
}

func (m *ColumnType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.FamilyID != 0 {
		n += 1 + sovElements(uint64(m.FamilyID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	l = m.TypeT.Size()
	n += 1 + l + sovElements(uint64(l))
	if m.IsNullable {
		n += 2
	}
	if m.ComputeExpr != nil {
		l = m.ComputeExpr.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.IsVirtual {
		n += 2
	}
	if m.ElementCreationMetadata != nil {
		l = m.ElementCreationMetadata.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *ColumnFamily) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.FamilyID != 0 {
		n += 1 + sovElements(uint64(m.FamilyID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *Index) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	if m.IsUnique {
		n += 2
	}
	if m.IsInverted {
		n += 2
	}
	if m.Sharding != nil {
		l = m.Sharding.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.IsCreatedExplicitly {
		n += 2
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	if m.IsConcurrently {
		n += 3
	}
	if m.SourceIndexID != 0 {
		n += 2 + sovElements(uint64(m.SourceIndexID))
	}
	if m.TemporaryIndexID != 0 {
		n += 2 + sovElements(uint64(m.TemporaryIndexID))
	}
	if m.IsNotVisible {
		n += 3
	}
	if m.GeoConfig != nil {
		l = m.GeoConfig.Size()
		n += 2 + l + sovElements(uint64(l))
	}
	if m.Invisibility != 0 {
		n += 10
	}
	return n
}

func (m *PrimaryIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Index.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *SecondaryIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Index.Size()
	n += 1 + l + sovElements(uint64(l))
	if m.EmbeddedExpr != nil {
		l = m.EmbeddedExpr.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.RecreateSourceIndexID != 0 {
		n += 1 + sovElements(uint64(m.RecreateSourceIndexID))
	}
	return n
}

func (m *TemporaryIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Index.Size()
	n += 1 + l + sovElements(uint64(l))
	if m.IsUsingSecondaryEncoding {
		n += 2
	}
	if m.Expr != nil {
		l = m.Expr.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *SecondaryIndexPartial) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	l = m.Expression.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *SchemaParent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaID != 0 {
		n += 1 + sovElements(uint64(m.SchemaID))
	}
	if m.ParentDatabaseID != 0 {
		n += 1 + sovElements(uint64(m.ParentDatabaseID))
	}
	return n
}

func (m *SchemaChild) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChildObjectID != 0 {
		n += 1 + sovElements(uint64(m.ChildObjectID))
	}
	if m.SchemaID != 0 {
		n += 1 + sovElements(uint64(m.SchemaID))
	}
	return n
}

func (m *Sequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SequenceID != 0 {
		n += 1 + sovElements(uint64(m.SequenceID))
	}
	if m.RestartWith != 0 {
		n += 1 + sovElements(uint64(m.RestartWith))
	}
	if m.UseRestartWith {
		n += 2
	}
	if m.IsTemporary {
		n += 2
	}
	return n
}

func (m *SequenceOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SequenceID != 0 {
		n += 1 + sovElements(uint64(m.SequenceID))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *SequenceOwner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SequenceID != 0 {
		n += 1 + sovElements(uint64(m.SequenceID))
	}
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	return n
}

func (m *ColumnDefaultExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	l = m.Expression.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *ColumnOnUpdateExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	l = m.Expression.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *View) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ViewID != 0 {
		n += 1 + sovElements(uint64(m.ViewID))
	}
	if len(m.UsesTypeIDs) > 0 {
		l = 0
		for _, e := range m.UsesTypeIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.UsesRelationIDs) > 0 {
		l = 0
		for _, e := range m.UsesRelationIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.ForwardReferences) > 0 {
		for _, e := range m.ForwardReferences {
			l = e.Size()
			n += 1 + l + sovElements(uint64(l))
		}
	}
	if m.IsTemporary {
		n += 2
	}
	if m.IsMaterialized {
		n += 2
	}
	return n
}

func (m *View_Reference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ToID != 0 {
		n += 1 + sovElements(uint64(m.ToID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	return n
}

func (m *Table) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IsTemporary {
		n += 2
	}
	return n
}

func (m *UniqueWithoutIndexConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.Predicate != nil {
		l = m.Predicate.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	if m.IndexIDForValidation != 0 {
		n += 1 + sovElements(uint64(m.IndexIDForValidation))
	}
	return n
}

func (m *UniqueWithoutIndexConstraintUnvalidated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.Predicate != nil {
		l = m.Predicate.Size()
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *CheckConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	l = m.Expression.Size()
	n += 1 + l + sovElements(uint64(l))
	if m.FromHashShardedColumn {
		n += 2
	}
	if m.IndexIDForValidation != 0 {
		n += 1 + sovElements(uint64(m.IndexIDForValidation))
	}
	return n
}

func (m *CheckConstraintUnvalidated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	l = m.Expression.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *ForeignKeyConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.ReferencedTableID != 0 {
		n += 1 + sovElements(uint64(m.ReferencedTableID))
	}
	if len(m.ReferencedColumnIDs) > 0 {
		l = 0
		for _, e := range m.ReferencedColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.OnUpdateAction != 0 {
		n += 1 + sovElements(uint64(m.OnUpdateAction))
	}
	if m.OnDeleteAction != 0 {
		n += 1 + sovElements(uint64(m.OnDeleteAction))
	}
	if m.CompositeKeyMatchMethod != 0 {
		n += 1 + sovElements(uint64(m.CompositeKeyMatchMethod))
	}
	if m.IndexIDForValidation != 0 {
		n += 1 + sovElements(uint64(m.IndexIDForValidation))
	}
	return n
}

func (m *ForeignKeyConstraintUnvalidated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.ReferencedTableID != 0 {
		n += 1 + sovElements(uint64(m.ReferencedTableID))
	}
	if len(m.ReferencedColumnIDs) > 0 {
		l = 0
		for _, e := range m.ReferencedColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.OnUpdateAction != 0 {
		n += 1 + sovElements(uint64(m.OnUpdateAction))
	}
	if m.OnDeleteAction != 0 {
		n += 1 + sovElements(uint64(m.OnDeleteAction))
	}
	if m.CompositeKeyMatchMethod != 0 {
		n += 1 + sovElements(uint64(m.CompositeKeyMatchMethod))
	}
	return n
}

func (m *EnumType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeID != 0 {
		n += 1 + sovElements(uint64(m.TypeID))
	}
	if m.ArrayTypeID != 0 {
		n += 1 + sovElements(uint64(m.ArrayTypeID))
	}
	if m.IsMultiRegion {
		n += 2
	}
	return n
}

func (m *AliasType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeID != 0 {
		n += 1 + sovElements(uint64(m.TypeID))
	}
	l = m.TypeT.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *CompositeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeID != 0 {
		n += 1 + sovElements(uint64(m.TypeID))
	}
	if m.ArrayTypeID != 0 {
		n += 1 + sovElements(uint64(m.ArrayTypeID))
	}
	return n
}

func (m *Schema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaID != 0 {
		n += 1 + sovElements(uint64(m.SchemaID))
	}
	if m.IsTemporary {
		n += 2
	}
	if m.IsPublic {
		n += 2
	}
	if m.IsVirtual {
		n += 2
	}
	return n
}

func (m *Database) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	return n
}

func (m *Namespace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	if m.SchemaID != 0 {
		n += 1 + sovElements(uint64(m.SchemaID))
	}
	if m.DescriptorID != 0 {
		n += 1 + sovElements(uint64(m.DescriptorID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *Owner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DescriptorID != 0 {
		n += 1 + sovElements(uint64(m.DescriptorID))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *UserPrivileges) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DescriptorID != 0 {
		n += 1 + sovElements(uint64(m.DescriptorID))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	if m.Privileges != 0 {
		n += 1 + sovElements(uint64(m.Privileges))
	}
	if m.WithGrantOption != 0 {
		n += 1 + sovElements(uint64(m.WithGrantOption))
	}
	return n
}

func (m *TableLocalityGlobal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	return n
}

func (m *TableLocalityPrimaryRegion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	return n
}

func (m *TableLocalitySecondaryRegion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.RegionEnumTypeID != 0 {
		n += 1 + sovElements(uint64(m.RegionEnumTypeID))
	}
	l = len(m.RegionName)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *TableLocalityRegionalByRow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	l = len(m.As)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *IndexPartitioning) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	l = m.PartitioningDescriptor.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *RowLevelTTL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	l = m.RowLevelTTL.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *ColumnName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *IndexName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *ConstraintWithoutIndexName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *TableComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *DatabaseComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *SchemaComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemaID != 0 {
		n += 1 + sovElements(uint64(m.SchemaID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *IndexComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *ColumnComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	if m.PgAttributeNum != 0 {
		n += 1 + sovElements(uint64(m.PgAttributeNum))
	}
	return n
}

func (m *ColumnNotNull) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	if m.IndexIDForValidation != 0 {
		n += 1 + sovElements(uint64(m.IndexIDForValidation))
	}
	return n
}

func (m *ConstraintComment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.ConstraintID != 0 {
		n += 1 + sovElements(uint64(m.ConstraintID))
	}
	l = len(m.Comment)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *DatabaseRegionConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	if m.RegionEnumTypeID != 0 {
		n += 1 + sovElements(uint64(m.RegionEnumTypeID))
	}
	return n
}

func (m *DatabaseRoleSetting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	l = len(m.RoleName)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *IndexColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	if m.ColumnID != 0 {
		n += 1 + sovElements(uint64(m.ColumnID))
	}
	if m.OrdinalInKind != 0 {
		n += 1 + sovElements(uint64(m.OrdinalInKind))
	}
	if m.Kind != 0 {
		n += 1 + sovElements(uint64(m.Kind))
	}
	if m.Direction != 0 {
		n += 1 + sovElements(uint64(m.Direction))
	}
	if m.Implicit {
		n += 2
	}
	if m.InvertedKind != 0 {
		n += 1 + sovElements(uint64(m.InvertedKind))
	}
	return n
}

func (m *EnumTypeValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeID != 0 {
		n += 1 + sovElements(uint64(m.TypeID))
	}
	l = len(m.PhysicalRepresentation)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	l = len(m.LogicalRepresentation)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *CompositeTypeAttrName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompositeTypeID != 0 {
		n += 1 + sovElements(uint64(m.CompositeTypeID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *CompositeTypeAttrType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompositeTypeID != 0 {
		n += 1 + sovElements(uint64(m.CompositeTypeID))
	}
	l = m.TypeT.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *TableZoneConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	return n
}

func (m *IndexZoneConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	l = len(m.PartitionName)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *DatabaseData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	return n
}

func (m *TableData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.DatabaseID != 0 {
		n += 1 + sovElements(uint64(m.DatabaseID))
	}
	return n
}

func (m *IndexData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	return n
}

func (m *TablePartitioning) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	return n
}

func (m *TableSchemaLocked) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	return n
}

func (m *Function) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionID != 0 {
		n += 1 + sovElements(uint64(m.FunctionID))
	}
	if len(m.Params) > 0 {
		for _, e := range m.Params {
			l = e.Size()
			n += 1 + l + sovElements(uint64(l))
		}
	}
	if m.ReturnSet {
		n += 2
	}
	l = m.ReturnType.Size()
	n += 1 + l + sovElements(uint64(l))
	if m.IsProcedure {
		n += 2
	}
	return n
}

func (m *Function_Parameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	l = m.Class.Size()
	n += 1 + l + sovElements(uint64(l))
	l = m.Type.Size()
	n += 1 + l + sovElements(uint64(l))
	l = len(m.DefaultExpr)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *FunctionName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionID != 0 {
		n += 1 + sovElements(uint64(m.FunctionID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	return n
}

func (m *FunctionVolatility) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionID != 0 {
		n += 1 + sovElements(uint64(m.FunctionID))
	}
	l = m.Volatility.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *FunctionLeakProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionID != 0 {
		n += 1 + sovElements(uint64(m.FunctionID))
	}
	if m.LeakProof {
		n += 2
	}
	return n
}

func (m *FunctionNullInputBehavior) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionID != 0 {
		n += 1 + sovElements(uint64(m.FunctionID))
	}
	l = m.NullInputBehavior.Size()
	n += 1 + l + sovElements(uint64(l))
	return n
}

func (m *FunctionBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionID != 0 {
		n += 1 + sovElements(uint64(m.FunctionID))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovElements(uint64(l))
	}
	l = m.Lang.Size()
	n += 1 + l + sovElements(uint64(l))
	if len(m.UsesTables) > 0 {
		for _, e := range m.UsesTables {
			l = e.Size()
			n += 1 + l + sovElements(uint64(l))
		}
	}
	if len(m.UsesViews) > 0 {
		for _, e := range m.UsesViews {
			l = e.Size()
			n += 1 + l + sovElements(uint64(l))
		}
	}
	if len(m.UsesSequenceIDs) > 0 {
		l = 0
		for _, e := range m.UsesSequenceIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.UsesTypeIDs) > 0 {
		l = 0
		for _, e := range m.UsesTypeIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if len(m.UsesFunctionIDs) > 0 {
		l = 0
		for _, e := range m.UsesFunctionIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	return n
}

func (m *FunctionBody_TableReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovElements(uint64(m.TableID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	if m.IndexID != 0 {
		n += 1 + sovElements(uint64(m.IndexID))
	}
	return n
}

func (m *FunctionBody_ViewReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ViewID != 0 {
		n += 1 + sovElements(uint64(m.ViewID))
	}
	if len(m.ColumnIDs) > 0 {
		l = 0
		for _, e := range m.ColumnIDs {
			l += sovElements(uint64(e))
		}
		n += 1 + sovElements(uint64(l)) + l
	}
	return n
}

func (m *ElementCreationMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.In_23_1OrLater {
		n += 2
	}
	return n
}

func sovElements(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozElements(x uint64) (n int) {
	return sovElements(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ElementProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ElementProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ElementProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Database{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_Database{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Schema{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_Schema{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &View{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_View{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Sequence{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_Sequence{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Table{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_Table{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnumType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EnumType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_EnumType{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AliasType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AliasType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_AliasType{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CompositeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_CompositeType{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Function", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Function{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_Function{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnFamily", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnFamily{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_ColumnFamily{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Column{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_Column{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PrimaryIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_PrimaryIndex{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SecondaryIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_SecondaryIndex{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporaryIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TemporaryIndex{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_TemporaryIndex{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueWithoutIndexConstraint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UniqueWithoutIndexConstraint{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_UniqueWithoutIndexConstraint{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckConstraint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CheckConstraint{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_CheckConstraint{v}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeignKeyConstraint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ForeignKeyConstraint{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_ForeignKeyConstraint{v}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TableComment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_TableComment{v}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowLevelTTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RowLevelTTL{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_RowLevelTTL{v}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnName{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_ColumnName{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_ColumnType{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnDefaultExpression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnDefaultExpression{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_ColumnDefaultExpression{v}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnOnUpdateExpression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnOnUpdateExpression{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_ColumnOnUpdateExpression{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceOwner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SequenceOwner{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_SequenceOwner{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnComment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_ColumnComment{v}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnNotNull", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ColumnNotNull{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_ColumnNotNull{v}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SequenceOption{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_SequenceOption{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IndexName{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_IndexName{v}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexPartitioning", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IndexPartitioning{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_IndexPartitioning{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryIndexPartial", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SecondaryIndexPartial{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_SecondaryIndexPartial{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IndexComment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_IndexComment{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexColumn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IndexColumn{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_IndexColumn{v}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IndexData{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_IndexData{v}
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintWithoutIndexName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConstraintWithoutIndexName{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_ConstraintWithoutIndexName{v}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConstraintComment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_ConstraintComment{v}
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Namespace{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_Namespace{v}
			iNdEx = postIndex
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Owner{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_Owner{v}
			iNdEx = postIndex
		case 62:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPrivileges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UserPrivileges{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_UserPrivileges{v}
			iNdEx = postIndex
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseRegionConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DatabaseRegionConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_DatabaseRegionConfig{v}
			iNdEx = postIndex
		case 81:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseRoleSetting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DatabaseRoleSetting{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_DatabaseRoleSetting{v}
			iNdEx = postIndex
		case 82:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DatabaseComment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_DatabaseComment{v}
			iNdEx = postIndex
		case 83:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DatabaseData{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_DatabaseData{v}
			iNdEx = postIndex
		case 90:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaParent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SchemaParent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_SchemaParent{v}
			iNdEx = postIndex
		case 91:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaComment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SchemaComment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_SchemaComment{v}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaChild", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SchemaChild{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_SchemaChild{v}
			iNdEx = postIndex
		case 110:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableLocalityGlobal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TableLocalityGlobal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_TableLocalityGlobal{v}
			iNdEx = postIndex
		case 111:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableLocalityPrimaryRegion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TableLocalityPrimaryRegion{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_TableLocalityPrimaryRegion{v}
			iNdEx = postIndex
		case 112:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableLocalitySecondaryRegion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TableLocalitySecondaryRegion{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_TableLocalitySecondaryRegion{v}
			iNdEx = postIndex
		case 113:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableLocalityRegionalByRow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TableLocalityRegionalByRow{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_TableLocalityRegionalByRow{v}
			iNdEx = postIndex
		case 120:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnumTypeValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EnumTypeValue{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_EnumTypeValue{v}
			iNdEx = postIndex
		case 121:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableZoneConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TableZoneConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_TableZoneConfig{v}
			iNdEx = postIndex
		case 122:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexZoneConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IndexZoneConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_IndexZoneConfig{v}
			iNdEx = postIndex
		case 131:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TableData{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_TableData{v}
			iNdEx = postIndex
		case 132:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TablePartitioning", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TablePartitioning{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_TablePartitioning{v}
			iNdEx = postIndex
		case 133:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableSchemaLocked", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TableSchemaLocked{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_TableSchemaLocked{v}
			iNdEx = postIndex
		case 140:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeTypeAttrType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CompositeTypeAttrType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_CompositeTypeAttrType{v}
			iNdEx = postIndex
		case 141:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeTypeAttrName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CompositeTypeAttrName{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_CompositeTypeAttrName{v}
			iNdEx = postIndex
		case 160:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FunctionName{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_FunctionName{v}
			iNdEx = postIndex
		case 161:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionVolatility", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FunctionVolatility{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_FunctionVolatility{v}
			iNdEx = postIndex
		case 162:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionLeakProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FunctionLeakProof{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_FunctionLeakProof{v}
			iNdEx = postIndex
		case 163:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionNullInputBehavior", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FunctionNullInputBehavior{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_FunctionNullInputBehavior{v}
			iNdEx = postIndex
		case 164:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionBody", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FunctionBody{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_FunctionBody{v}
			iNdEx = postIndex
		case 170:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckConstraintUnvalidated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CheckConstraintUnvalidated{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_CheckConstraintUnvalidated{v}
			iNdEx = postIndex
		case 171:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueWithoutIndexConstraintUnvalidated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UniqueWithoutIndexConstraintUnvalidated{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_UniqueWithoutIndexConstraintUnvalidated{v}
			iNdEx = postIndex
		case 172:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForeignKeyConstraintUnvalidated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ForeignKeyConstraintUnvalidated{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ElementOneOf = &ElementProto_ForeignKeyConstraintUnvalidated{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &types.T{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ClosedTypeIDs = append(m.ClosedTypeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ClosedTypeIDs) == 0 {
					m.ClosedTypeIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ClosedTypeIDs = append(m.ClosedTypeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedTypeIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expr = github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.Expression(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesTypeIDs = append(m.UsesTypeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UsesTypeIDs) == 0 {
					m.UsesTypeIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesTypeIDs = append(m.UsesTypeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesTypeIDs", wireType)
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesSequenceIDs = append(m.UsesSequenceIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UsesSequenceIDs) == 0 {
					m.UsesSequenceIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesSequenceIDs = append(m.UsesSequenceIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesSequenceIDs", wireType)
			}
		case 4:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ReferencedColumnIDs = append(m.ReferencedColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ReferencedColumnIDs) == 0 {
					m.ReferencedColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ReferencedColumnIDs = append(m.ReferencedColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencedColumnIDs", wireType)
			}
		case 5:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesFunctionIDs = append(m.UsesFunctionIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UsesFunctionIDs) == 0 {
					m.UsesFunctionIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesFunctionIDs = append(m.UsesFunctionIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesFunctionIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHidden = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInaccessible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInaccessible = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedAsIdentityType", wireType)
			}
			m.GeneratedAsIdentityType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GeneratedAsIdentityType |= github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.GeneratedAsIdentityType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedAsIdentitySequenceOption", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeneratedAsIdentitySequenceOption = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgAttributeNum", wireType)
			}
			m.PgAttributeNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PgAttributeNum |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.PGAttributeNum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSystemColumn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSystemColumn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FamilyID", wireType)
			}
			m.FamilyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FamilyID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.FamilyID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNullable = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ComputeExpr == nil {
				m.ComputeExpr = &Expression{}
			}
			if err := m.ComputeExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVirtual", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVirtual = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElementCreationMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ElementCreationMetadata == nil {
				m.ElementCreationMetadata = &ElementCreationMetadata{}
			}
			if err := m.ElementCreationMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnFamily) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnFamily: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnFamily: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FamilyID", wireType)
			}
			m.FamilyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FamilyID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.FamilyID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Index) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Index: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Index: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUnique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUnique = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInverted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInverted = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sharding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sharding == nil {
				m.Sharding = &catpb.ShardedDescriptor{}
			}
			if err := m.Sharding.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCreatedExplicitly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCreatedExplicitly = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConcurrently", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConcurrently = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIndexID", wireType)
			}
			m.SourceIndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceIndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporaryIndexID", wireType)
			}
			m.TemporaryIndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TemporaryIndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNotVisible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNotVisible = bool(v != 0)
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GeoConfig == nil {
				m.GeoConfig = &geopb.Config{}
			}
			if err := m.GeoConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invisibility", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Invisibility = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimaryIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimaryIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimaryIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecondaryIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecondaryIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecondaryIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmbeddedExpr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EmbeddedExpr == nil {
				m.EmbeddedExpr = &Expression{}
			}
			if err := m.EmbeddedExpr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecreateSourceIndexID", wireType)
			}
			m.RecreateSourceIndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecreateSourceIndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TemporaryIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TemporaryIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TemporaryIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUsingSecondaryEncoding", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUsingSecondaryEncoding = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expression{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecondaryIndexPartial) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecondaryIndexPartial: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecondaryIndexPartial: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaParent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaParent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaParent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaID", wireType)
			}
			m.SchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentDatabaseID", wireType)
			}
			m.ParentDatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentDatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaChild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaChild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaChild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildObjectID", wireType)
			}
			m.ChildObjectID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChildObjectID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaID", wireType)
			}
			m.SchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceID", wireType)
			}
			m.SequenceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartWith", wireType)
			}
			m.RestartWith = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestartWith |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseRestartWith", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseRestartWith = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTemporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTemporary = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SequenceOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequenceOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequenceOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceID", wireType)
			}
			m.SequenceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SequenceOwner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SequenceOwner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SequenceOwner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceID", wireType)
			}
			m.SequenceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnDefaultExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnDefaultExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnDefaultExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnOnUpdateExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnOnUpdateExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnOnUpdateExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *View) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: View: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: View: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewID", wireType)
			}
			m.ViewID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViewID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesTypeIDs = append(m.UsesTypeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UsesTypeIDs) == 0 {
					m.UsesTypeIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesTypeIDs = append(m.UsesTypeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesTypeIDs", wireType)
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesRelationIDs = append(m.UsesRelationIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UsesRelationIDs) == 0 {
					m.UsesRelationIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesRelationIDs = append(m.UsesRelationIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesRelationIDs", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardReferences", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForwardReferences = append(m.ForwardReferences, &View_Reference{})
			if err := m.ForwardReferences[len(m.ForwardReferences)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTemporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTemporary = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMaterialized", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMaterialized = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *View_Reference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToID", wireType)
			}
			m.ToID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Table) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Table: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Table: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTemporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTemporary = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UniqueWithoutIndexConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UniqueWithoutIndexConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UniqueWithoutIndexConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Predicate == nil {
				m.Predicate = &Expression{}
			}
			if err := m.Predicate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIDForValidation", wireType)
			}
			m.IndexIDForValidation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexIDForValidation |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UniqueWithoutIndexConstraintUnvalidated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UniqueWithoutIndexConstraintUnvalidated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UniqueWithoutIndexConstraintUnvalidated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predicate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Predicate == nil {
				m.Predicate = &Expression{}
			}
			if err := m.Predicate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromHashShardedColumn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FromHashShardedColumn = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIDForValidation", wireType)
			}
			m.IndexIDForValidation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexIDForValidation |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckConstraintUnvalidated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckConstraintUnvalidated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckConstraintUnvalidated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expression.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForeignKeyConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForeignKeyConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForeignKeyConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencedTableID", wireType)
			}
			m.ReferencedTableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReferencedTableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ReferencedColumnIDs = append(m.ReferencedColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ReferencedColumnIDs) == 0 {
					m.ReferencedColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ReferencedColumnIDs = append(m.ReferencedColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencedColumnIDs", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnUpdateAction", wireType)
			}
			m.OnUpdateAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnUpdateAction |= semenumpb.ForeignKeyAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDeleteAction", wireType)
			}
			m.OnDeleteAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnDeleteAction |= semenumpb.ForeignKeyAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeKeyMatchMethod", wireType)
			}
			m.CompositeKeyMatchMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompositeKeyMatchMethod |= semenumpb.Match(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIDForValidation", wireType)
			}
			m.IndexIDForValidation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexIDForValidation |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForeignKeyConstraintUnvalidated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForeignKeyConstraintUnvalidated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForeignKeyConstraintUnvalidated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencedTableID", wireType)
			}
			m.ReferencedTableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReferencedTableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ReferencedColumnIDs = append(m.ReferencedColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ReferencedColumnIDs) == 0 {
					m.ReferencedColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ReferencedColumnIDs = append(m.ReferencedColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencedColumnIDs", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnUpdateAction", wireType)
			}
			m.OnUpdateAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnUpdateAction |= semenumpb.ForeignKeyAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDeleteAction", wireType)
			}
			m.OnDeleteAction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnDeleteAction |= semenumpb.ForeignKeyAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeKeyMatchMethod", wireType)
			}
			m.CompositeKeyMatchMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompositeKeyMatchMethod |= semenumpb.Match(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnumType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnumType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnumType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrayTypeID", wireType)
			}
			m.ArrayTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArrayTypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMultiRegion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMultiRegion = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AliasType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AliasType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AliasType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompositeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompositeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompositeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrayTypeID", wireType)
			}
			m.ArrayTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArrayTypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Schema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Schema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaID", wireType)
			}
			m.SchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTemporary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTemporary = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPublic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPublic = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVirtual", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVirtual = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Database) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Database: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Database: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Namespace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Namespace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Namespace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaID", wireType)
			}
			m.SchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorID", wireType)
			}
			m.DescriptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Owner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Owner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Owner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorID", wireType)
			}
			m.DescriptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPrivileges) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPrivileges: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPrivileges: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescriptorID", wireType)
			}
			m.DescriptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescriptorID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileges", wireType)
			}
			m.Privileges = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Privileges |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithGrantOption", wireType)
			}
			m.WithGrantOption = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithGrantOption |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableLocalityGlobal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableLocalityGlobal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableLocalityGlobal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableLocalityPrimaryRegion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableLocalityPrimaryRegion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableLocalityPrimaryRegion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableLocalitySecondaryRegion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableLocalitySecondaryRegion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableLocalitySecondaryRegion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionEnumTypeID", wireType)
			}
			m.RegionEnumTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionEnumTypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionName = github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.RegionName(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableLocalityRegionalByRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableLocalityRegionalByRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableLocalityRegionalByRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field As", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.As = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexPartitioning) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexPartitioning: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexPartitioning: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitioningDescriptor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PartitioningDescriptor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowLevelTTL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowLevelTTL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowLevelTTL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowLevelTTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RowLevelTTL.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConstraintWithoutIndexName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConstraintWithoutIndexName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConstraintWithoutIndexName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaID", wireType)
			}
			m.SchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PgAttributeNum", wireType)
			}
			m.PgAttributeNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PgAttributeNum |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.PGAttributeNum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnNotNull) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnNotNull: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnNotNull: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIDForValidation", wireType)
			}
			m.IndexIDForValidation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexIDForValidation |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConstraintComment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConstraintComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConstraintComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstraintID", wireType)
			}
			m.ConstraintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstraintID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ConstraintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseRegionConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseRegionConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseRegionConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionEnumTypeID", wireType)
			}
			m.RegionEnumTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionEnumTypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseRoleSetting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseRoleSetting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseRoleSetting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrdinalInKind", wireType)
			}
			m.OrdinalInKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrdinalInKind |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= IndexColumn_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= catenumpb.IndexColumn_Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Implicit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Implicit = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertedKind", wireType)
			}
			m.InvertedKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvertedKind |= github_com_cockroachdb_cockroach_pkg_sql_catalog_catpb.InvertedIndexColumnKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnumTypeValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnumTypeValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnumTypeValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalRepresentation", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalRepresentation = append(m.PhysicalRepresentation[:0], dAtA[iNdEx:postIndex]...)
			if m.PhysicalRepresentation == nil {
				m.PhysicalRepresentation = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalRepresentation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogicalRepresentation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompositeTypeAttrName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompositeTypeAttrName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompositeTypeAttrName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeTypeID", wireType)
			}
			m.CompositeTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompositeTypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompositeTypeAttrType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompositeTypeAttrType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompositeTypeAttrType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompositeTypeID", wireType)
			}
			m.CompositeTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompositeTypeID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableZoneConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableZoneConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableZoneConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexZoneConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexZoneConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexZoneConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseID", wireType)
			}
			m.DatabaseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TablePartitioning) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TablePartitioning: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TablePartitioning: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableSchemaLocked) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableSchemaLocked: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableSchemaLocked: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Function) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Function: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Function: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionID", wireType)
			}
			m.FunctionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FunctionID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, Function_Parameter{})
			if err := m.Params[len(m.Params)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReturnSet = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReturnType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsProcedure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsProcedure = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Function_Parameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Parameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Parameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Class", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Class.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultExpr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultExpr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FunctionName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FunctionName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionID", wireType)
			}
			m.FunctionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FunctionID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionVolatility) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FunctionVolatility: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FunctionVolatility: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionID", wireType)
			}
			m.FunctionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FunctionID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volatility", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Volatility.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionLeakProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FunctionLeakProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FunctionLeakProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionID", wireType)
			}
			m.FunctionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FunctionID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeakProof", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LeakProof = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionNullInputBehavior) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FunctionNullInputBehavior: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FunctionNullInputBehavior: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionID", wireType)
			}
			m.FunctionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FunctionID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullInputBehavior", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NullInputBehavior.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FunctionBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FunctionBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionID", wireType)
			}
			m.FunctionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FunctionID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lang", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Lang.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsesTables = append(m.UsesTables, FunctionBody_TableReference{})
			if err := m.UsesTables[len(m.UsesTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesViews", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthElements
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthElements
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsesViews = append(m.UsesViews, FunctionBody_ViewReference{})
			if err := m.UsesViews[len(m.UsesViews)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesSequenceIDs = append(m.UsesSequenceIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UsesSequenceIDs) == 0 {
					m.UsesSequenceIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesSequenceIDs = append(m.UsesSequenceIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesSequenceIDs", wireType)
			}
		case 7:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesTypeIDs = append(m.UsesTypeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UsesTypeIDs) == 0 {
					m.UsesTypeIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesTypeIDs = append(m.UsesTypeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesTypeIDs", wireType)
			}
		case 8:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UsesFunctionIDs = append(m.UsesFunctionIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UsesFunctionIDs) == 0 {
					m.UsesFunctionIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UsesFunctionIDs = append(m.UsesFunctionIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UsesFunctionIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionBody_TableReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexID", wireType)
			}
			m.IndexID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.IndexID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FunctionBody_ViewReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewID", wireType)
			}
			m.ViewID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViewID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ColumnIDs = append(m.ColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowElements
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthElements
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthElements
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ColumnIDs) == 0 {
					m.ColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowElements
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ColumnIDs = append(m.ColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ElementCreationMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowElements
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ElementCreationMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ElementCreationMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field In_23_1OrLater", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowElements
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.In_23_1OrLater = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipElements(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthElements
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipElements(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowElements
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowElements
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowElements
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthElements
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupElements
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthElements
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthElements        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowElements          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupElements = fmt.Errorf("proto: unexpected end of group")
)

