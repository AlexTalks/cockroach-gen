// Code generated by optgen; DO NOT EDIT.

package xform

import (
	"github.com/cockroachdb/cockroach/pkg/sql/opt"
	"github.com/cockroachdb/cockroach/pkg/sql/opt/memo"
)

func (_e *explorer) exploreExpr(_state *exploreState, _eid memo.ExprID) (_fullyExplored bool) {
	_expr := _e.mem.Expr(_eid)
	switch _expr.Operator() {
	case opt.ScanOp:
		return _e.exploreScan(_state, _eid)
	case opt.SelectOp:
		return _e.exploreSelect(_state, _eid)
	case opt.LimitOp:
		return _e.exploreLimit(_state, _eid)
	}

	// No rules for other operator types.
	return true
}

func (_e *explorer) exploreScan(_rootState *exploreState, _root memo.ExprID) (_fullyExplored bool) {
	_rootExpr := _e.mem.Expr(_root).AsScan()
	_fullyExplored = true

	// [GenerateIndexScans]
	{
		if _root.Expr >= _rootState.start {
			def := _rootExpr.Def()
			if _e.funcs.CanGenerateIndexScans(def) {
				if _e.o.matchedRule == nil || _e.o.matchedRule(opt.GenerateIndexScans) {
					_exprs := _e.funcs.GenerateIndexScans(def)
					_before := _e.mem.ExprCount(_root.Group)
					for i := range _exprs {
						_e.mem.MemoizeDenormExpr(_root.Group, _exprs[i])
					}
					if _e.o.appliedRule != nil {
						_after := _e.mem.ExprCount(_root.Group)
						_e.o.appliedRule(opt.GenerateIndexScans, _root.Group, _after-_before)
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreSelect(_rootState *exploreState, _root memo.ExprID) (_fullyExplored bool) {
	_rootExpr := _e.mem.Expr(_root).AsSelect()
	_fullyExplored = true

	// [ConstrainScan]
	{
		_partlyExplored := _root.Expr < _rootState.start
		_state := _e.exploreGroup(_rootExpr.Input())
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		start := memo.ExprOrdinal(0)
		if _partlyExplored {
			start = _state.start
		}
		for _ord := start; _ord < _state.end; _ord++ {
			_eid := memo.ExprID{Group: _rootExpr.Input(), Expr: _ord}
			_scanExpr := _e.mem.Expr(_eid).AsScan()
			if _scanExpr != nil {
				def := _scanExpr.Def()
				if _e.funcs.CanConstrainScan(def) {
					filter := _rootExpr.Filter()
					if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ConstrainScan) {
						_exprs := _e.funcs.ConstrainScan(filter, def)
						_before := _e.mem.ExprCount(_root.Group)
						for i := range _exprs {
							_e.mem.MemoizeDenormExpr(_root.Group, _exprs[i])
						}
						if _e.o.appliedRule != nil {
							_after := _e.mem.ExprCount(_root.Group)
							_e.o.appliedRule(opt.ConstrainScan, _root.Group, _after-_before)
						}
					}
				}
			}
		}
	}

	// [PushFilterIntoLookupJoinNoRemainder]
	{
		_partlyExplored := _root.Expr < _rootState.start
		_state := _e.exploreGroup(_rootExpr.Input())
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		start := memo.ExprOrdinal(0)
		if _partlyExplored {
			start = _state.start
		}
		for _ord := start; _ord < _state.end; _ord++ {
			_eid := memo.ExprID{Group: _rootExpr.Input(), Expr: _ord}
			_lookupJoinExpr := _e.mem.Expr(_eid).AsLookupJoin()
			if _lookupJoinExpr != nil {
				input := _lookupJoinExpr.Input()
				def := _lookupJoinExpr.Def()
				filter := _rootExpr.Filter()
				if _e.funcs.IsBoundBy(filter, input) {
					if _e.o.matchedRule == nil || _e.o.matchedRule(opt.PushFilterIntoLookupJoinNoRemainder) {
						_expr := memo.MakeLookupJoinExpr(
							_e.f.ConstructSelect(
								input,
								filter,
							),
							def,
						)
						_before := _e.mem.ExprCount(_root.Group)
						_e.mem.MemoizeDenormExpr(_root.Group, memo.Expr(_expr))
						if _e.o.appliedRule != nil {
							_after := _e.mem.ExprCount(_root.Group)
							_e.o.appliedRule(opt.PushFilterIntoLookupJoinNoRemainder, _root.Group, _after-_before)
						}
					}
				}
			}
		}
	}

	// [PushFilterIntoLookupJoin]
	{
		_partlyExplored := _root.Expr < _rootState.start
		_state := _e.exploreGroup(_rootExpr.Input())
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		start := memo.ExprOrdinal(0)
		if _partlyExplored {
			start = _state.start
		}
		for _ord := start; _ord < _state.end; _ord++ {
			_eid := memo.ExprID{Group: _rootExpr.Input(), Expr: _ord}
			_lookupJoinExpr := _e.mem.Expr(_eid).AsLookupJoin()
			if _lookupJoinExpr != nil {
				input := _lookupJoinExpr.Input()
				def := _lookupJoinExpr.Def()
				filter := _rootExpr.Filter()
				_eid := memo.MakeNormExprID(_rootExpr.Filter())
				_filtersExpr := _e.mem.Expr(_eid).AsFilters()
				if _filtersExpr != nil {
					list := _filtersExpr.Conditions()
					for _, _item := range _e.mem.LookupList(_filtersExpr.Conditions()) {
						condition := _item
						if _e.funcs.IsBoundBy(condition, input) {
							if !_e.funcs.IsBoundBy(filter, input) {
								if _e.o.matchedRule == nil || _e.o.matchedRule(opt.PushFilterIntoLookupJoin) {
									_expr := memo.MakeSelectExpr(
										_e.f.ConstructLookupJoin(
											_e.f.ConstructSelect(
												input,
												_e.f.ConstructFilters(
													_e.funcs.ExtractBoundConditions(list, input),
												),
											),
											def,
										),
										_e.f.ConstructFilters(
											_e.funcs.ExtractUnboundConditions(list, input),
										),
									)
									_before := _e.mem.ExprCount(_root.Group)
									_e.mem.MemoizeDenormExpr(_root.Group, memo.Expr(_expr))
									if _e.o.appliedRule != nil {
										_after := _e.mem.ExprCount(_root.Group)
										_e.o.appliedRule(opt.PushFilterIntoLookupJoin, _root.Group, _after-_before)
									}
								}
							}
						}
					}
				}
			}
		}
	}

	// [ConstrainLookupJoinIndexScan]
	{
		_partlyExplored := _root.Expr < _rootState.start
		_state := _e.exploreGroup(_rootExpr.Input())
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		for _ord := memo.ExprOrdinal(0); _ord < _state.end; _ord++ {
			_partlyExplored := _partlyExplored && _ord < _state.start
			_eid := memo.ExprID{Group: _rootExpr.Input(), Expr: _ord}
			_lookupJoinExpr := _e.mem.Expr(_eid).AsLookupJoin()
			if _lookupJoinExpr != nil {
				_state := _e.exploreGroup(_lookupJoinExpr.Input())
				if !_state.fullyExplored {
					_fullyExplored = false
				}
				start := memo.ExprOrdinal(0)
				if _partlyExplored {
					start = _state.start
				}
				for _ord := start; _ord < _state.end; _ord++ {
					_eid := memo.ExprID{Group: _lookupJoinExpr.Input(), Expr: _ord}
					_scanExpr := _e.mem.Expr(_eid).AsScan()
					if _scanExpr != nil {
						def := _scanExpr.Def()
						if _e.funcs.CanConstrainScan(def) {
							outerdef := _lookupJoinExpr.Def()
							filter := _rootExpr.Filter()
							if _e.o.matchedRule == nil || _e.o.matchedRule(opt.ConstrainLookupJoinIndexScan) {
								_exprs := _e.funcs.ConstrainLookupJoinIndexScan(filter, def, outerdef)
								_before := _e.mem.ExprCount(_root.Group)
								for i := range _exprs {
									_e.mem.MemoizeDenormExpr(_root.Group, _exprs[i])
								}
								if _e.o.appliedRule != nil {
									_after := _e.mem.ExprCount(_root.Group)
									_e.o.appliedRule(opt.ConstrainLookupJoinIndexScan, _root.Group, _after-_before)
								}
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}

func (_e *explorer) exploreLimit(_rootState *exploreState, _root memo.ExprID) (_fullyExplored bool) {
	_rootExpr := _e.mem.Expr(_root).AsLimit()
	_fullyExplored = true

	// [PushLimitIntoScan]
	{
		_partlyExplored := _root.Expr < _rootState.start
		_state := _e.exploreGroup(_rootExpr.Input())
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		start := memo.ExprOrdinal(0)
		if _partlyExplored {
			start = _state.start
		}
		for _ord := start; _ord < _state.end; _ord++ {
			_eid := memo.ExprID{Group: _rootExpr.Input(), Expr: _ord}
			_scanExpr := _e.mem.Expr(_eid).AsScan()
			if _scanExpr != nil {
				def := _scanExpr.Def()
				_eid := memo.MakeNormExprID(_rootExpr.Limit())
				_constExpr := _e.mem.Expr(_eid).AsConst()
				if _constExpr != nil {
					limit := _constExpr.Value()
					ordering := _rootExpr.Ordering()
					if _e.funcs.CanLimitScan(def, limit, ordering) {
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.PushLimitIntoScan) {
							_expr := memo.MakeScanExpr(
								_e.funcs.LimitScanDef(def, limit),
							)
							_before := _e.mem.ExprCount(_root.Group)
							_e.mem.MemoizeDenormExpr(_root.Group, memo.Expr(_expr))
							if _e.o.appliedRule != nil {
								_after := _e.mem.ExprCount(_root.Group)
								_e.o.appliedRule(opt.PushLimitIntoScan, _root.Group, _after-_before)
							}
						}
					}
				}
			}
		}
	}

	// [PushLimitIntoLookupJoin]
	{
		_partlyExplored := _root.Expr < _rootState.start
		_state := _e.exploreGroup(_rootExpr.Input())
		if !_state.fullyExplored {
			_fullyExplored = false
		}
		start := memo.ExprOrdinal(0)
		if _partlyExplored {
			start = _state.start
		}
		for _ord := start; _ord < _state.end; _ord++ {
			_eid := memo.ExprID{Group: _rootExpr.Input(), Expr: _ord}
			_lookupJoinExpr := _e.mem.Expr(_eid).AsLookupJoin()
			if _lookupJoinExpr != nil {
				input := _lookupJoinExpr.Input()
				def := _lookupJoinExpr.Def()
				if _e.funcs.OneResultPerInput(def) {
					limit := _rootExpr.Limit()
					ordering := _rootExpr.Ordering()
					if _e.funcs.HasOrderingCols(input, ordering) {
						if _e.o.matchedRule == nil || _e.o.matchedRule(opt.PushLimitIntoLookupJoin) {
							_expr := memo.MakeLookupJoinExpr(
								_e.f.ConstructLimit(
									input,
									limit,
									ordering,
								),
								def,
							)
							_before := _e.mem.ExprCount(_root.Group)
							_e.mem.MemoizeDenormExpr(_root.Group, memo.Expr(_expr))
							if _e.o.appliedRule != nil {
								_after := _e.mem.ExprCount(_root.Group)
								_e.o.appliedRule(opt.PushLimitIntoLookupJoin, _root.Group, _after-_before)
							}
						}
					}
				}
			}
		}
	}

	return _fullyExplored
}
