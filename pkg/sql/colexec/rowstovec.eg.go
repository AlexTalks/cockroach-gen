// Code generated by execgen; DO NOT EDIT.
// Copyright 2018 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"fmt"
	"time"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/execgen"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecbase/colexecerror"
	"github.com/cockroachdb/cockroach/pkg/sql/colmem"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sqlbase"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
)

// Remove unused warning.
var _ = execgen.UNSAFEGET

// EncDatumRowsToColVec converts one column from EncDatumRows to a column
// vector. columnIdx is the 0-based index of the column in the EncDatumRows.
func EncDatumRowsToColVec(
	allocator *colmem.Allocator,
	rows sqlbase.EncDatumRows,
	vec coldata.Vec,
	columnIdx int,
	typ *types.T,
	alloc *sqlbase.DatumAlloc,
) error {
	var err error
	allocator.PerformOperation(
		[]coldata.Vec{vec},
		func() {
			switch typ.Family() {
			case types.BoolFamily:
				col := vec.Bool()
				datumToPhysicalFn := getDatumToPhysicalFn(typ)
				for i := range rows {
					row := rows[i]
					if row[columnIdx].Datum == nil {
						if err = row[columnIdx].EnsureDecoded(typ, alloc); err != nil {
							return
						}
					}
					datum := row[columnIdx].Datum
					if datum == tree.DNull {
						vec.Nulls().SetNull(i)
					} else {
						v, err := datumToPhysicalFn(datum)
						if err != nil {
							return
						}

						castV := v.(bool)
						col[i] = castV
					}
				}
			case types.BytesFamily:
				col := vec.Bytes()
				datumToPhysicalFn := getDatumToPhysicalFn(typ)
				for i := range rows {
					row := rows[i]
					if row[columnIdx].Datum == nil {
						if err = row[columnIdx].EnsureDecoded(typ, alloc); err != nil {
							return
						}
					}
					datum := row[columnIdx].Datum
					if datum == tree.DNull {
						vec.Nulls().SetNull(i)
					} else {
						v, err := datumToPhysicalFn(datum)
						if err != nil {
							return
						}

						castV := v.([]byte)
						col.Set(i, castV)
					}
				}
			case types.DateFamily:
				col := vec.Int64()
				datumToPhysicalFn := getDatumToPhysicalFn(typ)
				for i := range rows {
					row := rows[i]
					if row[columnIdx].Datum == nil {
						if err = row[columnIdx].EnsureDecoded(typ, alloc); err != nil {
							return
						}
					}
					datum := row[columnIdx].Datum
					if datum == tree.DNull {
						vec.Nulls().SetNull(i)
					} else {
						v, err := datumToPhysicalFn(datum)
						if err != nil {
							return
						}

						castV := v.(int64)
						col[i] = castV
					}
				}
			case types.DecimalFamily:
				col := vec.Decimal()
				datumToPhysicalFn := getDatumToPhysicalFn(typ)
				for i := range rows {
					row := rows[i]
					if row[columnIdx].Datum == nil {
						if err = row[columnIdx].EnsureDecoded(typ, alloc); err != nil {
							return
						}
					}
					datum := row[columnIdx].Datum
					if datum == tree.DNull {
						vec.Nulls().SetNull(i)
					} else {
						v, err := datumToPhysicalFn(datum)
						if err != nil {
							return
						}

						castV := v.(apd.Decimal)
						col[i].Set(&castV)
					}
				}
			case types.FloatFamily:
				switch typ.Width() {
				case 32:
					col := vec.Float64()
					datumToPhysicalFn := getDatumToPhysicalFn(typ)
					for i := range rows {
						row := rows[i]
						if row[columnIdx].Datum == nil {
							if err = row[columnIdx].EnsureDecoded(typ, alloc); err != nil {
								return
							}
						}
						datum := row[columnIdx].Datum
						if datum == tree.DNull {
							vec.Nulls().SetNull(i)
						} else {
							v, err := datumToPhysicalFn(datum)
							if err != nil {
								return
							}

							castV := v.(float64)
							col[i] = castV
						}
					}
				case 64:
					col := vec.Float64()
					datumToPhysicalFn := getDatumToPhysicalFn(typ)
					for i := range rows {
						row := rows[i]
						if row[columnIdx].Datum == nil {
							if err = row[columnIdx].EnsureDecoded(typ, alloc); err != nil {
								return
							}
						}
						datum := row[columnIdx].Datum
						if datum == tree.DNull {
							vec.Nulls().SetNull(i)
						} else {
							v, err := datumToPhysicalFn(datum)
							if err != nil {
								return
							}

							castV := v.(float64)
							col[i] = castV
						}
					}
				default:
					colexecerror.InternalError(fmt.Sprintf("unsupported width %d for type %s", typ.Width(), typ.String()))
				}
			case types.IntFamily:
				switch typ.Width() {
				case 16:
					col := vec.Int16()
					datumToPhysicalFn := getDatumToPhysicalFn(typ)
					for i := range rows {
						row := rows[i]
						if row[columnIdx].Datum == nil {
							if err = row[columnIdx].EnsureDecoded(typ, alloc); err != nil {
								return
							}
						}
						datum := row[columnIdx].Datum
						if datum == tree.DNull {
							vec.Nulls().SetNull(i)
						} else {
							v, err := datumToPhysicalFn(datum)
							if err != nil {
								return
							}

							castV := v.(int16)
							col[i] = castV
						}
					}
				case 32:
					col := vec.Int32()
					datumToPhysicalFn := getDatumToPhysicalFn(typ)
					for i := range rows {
						row := rows[i]
						if row[columnIdx].Datum == nil {
							if err = row[columnIdx].EnsureDecoded(typ, alloc); err != nil {
								return
							}
						}
						datum := row[columnIdx].Datum
						if datum == tree.DNull {
							vec.Nulls().SetNull(i)
						} else {
							v, err := datumToPhysicalFn(datum)
							if err != nil {
								return
							}

							castV := v.(int32)
							col[i] = castV
						}
					}
				case 64:
					col := vec.Int64()
					datumToPhysicalFn := getDatumToPhysicalFn(typ)
					for i := range rows {
						row := rows[i]
						if row[columnIdx].Datum == nil {
							if err = row[columnIdx].EnsureDecoded(typ, alloc); err != nil {
								return
							}
						}
						datum := row[columnIdx].Datum
						if datum == tree.DNull {
							vec.Nulls().SetNull(i)
						} else {
							v, err := datumToPhysicalFn(datum)
							if err != nil {
								return
							}

							castV := v.(int64)
							col[i] = castV
						}
					}
				default:
					colexecerror.InternalError(fmt.Sprintf("unsupported width %d for type %s", typ.Width(), typ.String()))
				}
			case types.IntervalFamily:
				col := vec.Interval()
				datumToPhysicalFn := getDatumToPhysicalFn(typ)
				for i := range rows {
					row := rows[i]
					if row[columnIdx].Datum == nil {
						if err = row[columnIdx].EnsureDecoded(typ, alloc); err != nil {
							return
						}
					}
					datum := row[columnIdx].Datum
					if datum == tree.DNull {
						vec.Nulls().SetNull(i)
					} else {
						v, err := datumToPhysicalFn(datum)
						if err != nil {
							return
						}

						castV := v.(duration.Duration)
						col[i] = castV
					}
				}
			case types.OidFamily:
				col := vec.Int64()
				datumToPhysicalFn := getDatumToPhysicalFn(typ)
				for i := range rows {
					row := rows[i]
					if row[columnIdx].Datum == nil {
						if err = row[columnIdx].EnsureDecoded(typ, alloc); err != nil {
							return
						}
					}
					datum := row[columnIdx].Datum
					if datum == tree.DNull {
						vec.Nulls().SetNull(i)
					} else {
						v, err := datumToPhysicalFn(datum)
						if err != nil {
							return
						}

						castV := v.(int64)
						col[i] = castV
					}
				}
			case types.StringFamily:
				col := vec.Bytes()
				datumToPhysicalFn := getDatumToPhysicalFn(typ)
				for i := range rows {
					row := rows[i]
					if row[columnIdx].Datum == nil {
						if err = row[columnIdx].EnsureDecoded(typ, alloc); err != nil {
							return
						}
					}
					datum := row[columnIdx].Datum
					if datum == tree.DNull {
						vec.Nulls().SetNull(i)
					} else {
						v, err := datumToPhysicalFn(datum)
						if err != nil {
							return
						}

						castV := v.([]byte)
						col.Set(i, castV)
					}
				}
			case types.TimestampFamily:
				col := vec.Timestamp()
				datumToPhysicalFn := getDatumToPhysicalFn(typ)
				for i := range rows {
					row := rows[i]
					if row[columnIdx].Datum == nil {
						if err = row[columnIdx].EnsureDecoded(typ, alloc); err != nil {
							return
						}
					}
					datum := row[columnIdx].Datum
					if datum == tree.DNull {
						vec.Nulls().SetNull(i)
					} else {
						v, err := datumToPhysicalFn(datum)
						if err != nil {
							return
						}

						castV := v.(time.Time)
						col[i] = castV
					}
				}
			case types.TimestampTZFamily:
				col := vec.Timestamp()
				datumToPhysicalFn := getDatumToPhysicalFn(typ)
				for i := range rows {
					row := rows[i]
					if row[columnIdx].Datum == nil {
						if err = row[columnIdx].EnsureDecoded(typ, alloc); err != nil {
							return
						}
					}
					datum := row[columnIdx].Datum
					if datum == tree.DNull {
						vec.Nulls().SetNull(i)
					} else {
						v, err := datumToPhysicalFn(datum)
						if err != nil {
							return
						}

						castV := v.(time.Time)
						col[i] = castV
					}
				}
			case types.UuidFamily:
				col := vec.Bytes()
				datumToPhysicalFn := getDatumToPhysicalFn(typ)
				for i := range rows {
					row := rows[i]
					if row[columnIdx].Datum == nil {
						if err = row[columnIdx].EnsureDecoded(typ, alloc); err != nil {
							return
						}
					}
					datum := row[columnIdx].Datum
					if datum == tree.DNull {
						vec.Nulls().SetNull(i)
					} else {
						v, err := datumToPhysicalFn(datum)
						if err != nil {
							return
						}

						castV := v.([]byte)
						col.Set(i, castV)
					}
				}
			default:
				colexecerror.InternalError(fmt.Sprintf("unsupported type %s", typ.String()))
			}
		},
	)
	return err
}
