// Code generated by execgen; DO NOT EDIT.
// Copyright 2018 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"time"
	"unsafe"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/typeconv"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/execgen"
	"github.com/cockroachdb/cockroach/pkg/sql/colmem"
	"github.com/cockroachdb/cockroach/pkg/sql/types"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
	"github.com/cockroachdb/errors"
)

// Remove unused warning.
var _ = execgen.UNSAFEGET

func newAnyNotNullAggAlloc(
	allocator *colmem.Allocator, t *types.T, allocSize int64,
) (aggregateFuncAlloc, error) {
	switch typeconv.TypeFamilyToCanonicalTypeFamily(t.Family()) {
	case types.BoolFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullBoolAggAlloc{allocator: allocator, allocSize: allocSize}, nil
		}
	case types.BytesFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullBytesAggAlloc{allocator: allocator, allocSize: allocSize}, nil
		}
	case types.DecimalFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullDecimalAggAlloc{allocator: allocator, allocSize: allocSize}, nil
		}
	case types.IntFamily:
		switch t.Width() {
		case 16:
			return &anyNotNullInt16AggAlloc{allocator: allocator, allocSize: allocSize}, nil
		case 32:
			return &anyNotNullInt32AggAlloc{allocator: allocator, allocSize: allocSize}, nil
		case -1:
		default:
			return &anyNotNullInt64AggAlloc{allocator: allocator, allocSize: allocSize}, nil
		}
	case types.FloatFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullFloat64AggAlloc{allocator: allocator, allocSize: allocSize}, nil
		}
	case types.TimestampTZFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullTimestampAggAlloc{allocator: allocator, allocSize: allocSize}, nil
		}
	case types.IntervalFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullIntervalAggAlloc{allocator: allocator, allocSize: allocSize}, nil
		}
	case typeconv.DatumVecCanonicalTypeFamily:
		switch t.Width() {
		case -1:
		default:
			return &anyNotNullDatumAggAlloc{allocator: allocator, allocSize: allocSize}, nil
		}
	}
	return nil, errors.Errorf("unsupported any not null agg type %s", t.Name())
}

// anyNotNullBoolAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullBoolAgg struct {
	allocator                   *colmem.Allocator
	groups                      []bool
	vec                         coldata.Vec
	col                         []bool
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      bool
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullBoolAgg{}

const sizeOfAnyNotNullBoolAgg = int64(unsafe.Sizeof(anyNotNullBoolAgg{}))

func (a *anyNotNullBoolAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Bool()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullBoolAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullBoolAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullBoolAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *anyNotNullBoolAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bool(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullBoolAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullBoolAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullBoolAggAlloc struct {
	allocator *colmem.Allocator
	allocSize int64
	aggFuncs  []anyNotNullBoolAgg
}

var _ aggregateFuncAlloc = &anyNotNullBoolAggAlloc{}

func (a *anyNotNullBoolAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullBoolAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullBoolAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullBytesAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullBytesAgg struct {
	allocator                   *colmem.Allocator
	groups                      []bool
	vec                         coldata.Vec
	col                         *coldata.Bytes
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      []byte
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullBytesAgg{}

const sizeOfAnyNotNullBytesAgg = int64(unsafe.Sizeof(anyNotNullBytesAgg{}))

func (a *anyNotNullBytesAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Bytes()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullBytesAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullBytesAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullBytesAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *anyNotNullBytesAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bytes(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col.Get(i)
							a.curAgg = append(a.curAgg[:0], val...)
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col
					_ = 0
					_ = inputLen
					for i := 0; i < inputLen; i++ {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col.Get(i)
							a.curAgg = append(a.curAgg[:0], val...)
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col.Get(i)
							a.curAgg = append(a.curAgg[:0], val...)
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col
					_ = 0
					_ = inputLen
					for i := 0; i < inputLen; i++ {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col.Get(i)
							a.curAgg = append(a.curAgg[:0], val...)
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullBytesAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col.Set(a.curIdx, a.curAgg)
	}
	a.curIdx++
}

func (a *anyNotNullBytesAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullBytesAggAlloc struct {
	allocator *colmem.Allocator
	allocSize int64
	aggFuncs  []anyNotNullBytesAgg
}

var _ aggregateFuncAlloc = &anyNotNullBytesAggAlloc{}

func (a *anyNotNullBytesAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullBytesAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullBytesAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullDecimalAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullDecimalAgg struct {
	allocator                   *colmem.Allocator
	groups                      []bool
	vec                         coldata.Vec
	col                         []apd.Decimal
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      apd.Decimal
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullDecimalAgg{}

const sizeOfAnyNotNullDecimalAgg = int64(unsafe.Sizeof(anyNotNullDecimalAgg{}))

func (a *anyNotNullDecimalAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Decimal()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullDecimalAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullDecimalAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullDecimalAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *anyNotNullDecimalAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Decimal(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg.Set(&val)
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg.Set(&val)
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg.Set(&val)
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg.Set(&val)
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullDecimalAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx].Set(&a.curAgg)
	}
	a.curIdx++
}

func (a *anyNotNullDecimalAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullDecimalAggAlloc struct {
	allocator *colmem.Allocator
	allocSize int64
	aggFuncs  []anyNotNullDecimalAgg
}

var _ aggregateFuncAlloc = &anyNotNullDecimalAggAlloc{}

func (a *anyNotNullDecimalAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullDecimalAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullDecimalAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullInt16Agg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullInt16Agg struct {
	allocator                   *colmem.Allocator
	groups                      []bool
	vec                         coldata.Vec
	col                         []int16
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      int16
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullInt16Agg{}

const sizeOfAnyNotNullInt16Agg = int64(unsafe.Sizeof(anyNotNullInt16Agg{}))

func (a *anyNotNullInt16Agg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Int16()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullInt16Agg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullInt16Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullInt16Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *anyNotNullInt16Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int16(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullInt16Agg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullInt16Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullInt16AggAlloc struct {
	allocator *colmem.Allocator
	allocSize int64
	aggFuncs  []anyNotNullInt16Agg
}

var _ aggregateFuncAlloc = &anyNotNullInt16AggAlloc{}

func (a *anyNotNullInt16AggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullInt16Agg * a.allocSize)
		a.aggFuncs = make([]anyNotNullInt16Agg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullInt32Agg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullInt32Agg struct {
	allocator                   *colmem.Allocator
	groups                      []bool
	vec                         coldata.Vec
	col                         []int32
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      int32
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullInt32Agg{}

const sizeOfAnyNotNullInt32Agg = int64(unsafe.Sizeof(anyNotNullInt32Agg{}))

func (a *anyNotNullInt32Agg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Int32()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullInt32Agg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullInt32Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullInt32Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *anyNotNullInt32Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int32(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullInt32Agg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullInt32Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullInt32AggAlloc struct {
	allocator *colmem.Allocator
	allocSize int64
	aggFuncs  []anyNotNullInt32Agg
}

var _ aggregateFuncAlloc = &anyNotNullInt32AggAlloc{}

func (a *anyNotNullInt32AggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullInt32Agg * a.allocSize)
		a.aggFuncs = make([]anyNotNullInt32Agg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullInt64Agg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullInt64Agg struct {
	allocator                   *colmem.Allocator
	groups                      []bool
	vec                         coldata.Vec
	col                         []int64
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      int64
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullInt64Agg{}

const sizeOfAnyNotNullInt64Agg = int64(unsafe.Sizeof(anyNotNullInt64Agg{}))

func (a *anyNotNullInt64Agg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Int64()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullInt64Agg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullInt64Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullInt64Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *anyNotNullInt64Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int64(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullInt64Agg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullInt64Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullInt64AggAlloc struct {
	allocator *colmem.Allocator
	allocSize int64
	aggFuncs  []anyNotNullInt64Agg
}

var _ aggregateFuncAlloc = &anyNotNullInt64AggAlloc{}

func (a *anyNotNullInt64AggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullInt64Agg * a.allocSize)
		a.aggFuncs = make([]anyNotNullInt64Agg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullFloat64Agg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullFloat64Agg struct {
	allocator                   *colmem.Allocator
	groups                      []bool
	vec                         coldata.Vec
	col                         []float64
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      float64
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullFloat64Agg{}

const sizeOfAnyNotNullFloat64Agg = int64(unsafe.Sizeof(anyNotNullFloat64Agg{}))

func (a *anyNotNullFloat64Agg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Float64()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullFloat64Agg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullFloat64Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullFloat64Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *anyNotNullFloat64Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Float64(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullFloat64Agg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullFloat64Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullFloat64AggAlloc struct {
	allocator *colmem.Allocator
	allocSize int64
	aggFuncs  []anyNotNullFloat64Agg
}

var _ aggregateFuncAlloc = &anyNotNullFloat64AggAlloc{}

func (a *anyNotNullFloat64AggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullFloat64Agg * a.allocSize)
		a.aggFuncs = make([]anyNotNullFloat64Agg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullTimestampAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullTimestampAgg struct {
	allocator                   *colmem.Allocator
	groups                      []bool
	vec                         coldata.Vec
	col                         []time.Time
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      time.Time
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullTimestampAgg{}

const sizeOfAnyNotNullTimestampAgg = int64(unsafe.Sizeof(anyNotNullTimestampAgg{}))

func (a *anyNotNullTimestampAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Timestamp()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullTimestampAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullTimestampAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullTimestampAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *anyNotNullTimestampAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Timestamp(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullTimestampAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullTimestampAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullTimestampAggAlloc struct {
	allocator *colmem.Allocator
	allocSize int64
	aggFuncs  []anyNotNullTimestampAgg
}

var _ aggregateFuncAlloc = &anyNotNullTimestampAggAlloc{}

func (a *anyNotNullTimestampAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullTimestampAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullTimestampAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullIntervalAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullIntervalAgg struct {
	allocator                   *colmem.Allocator
	groups                      []bool
	vec                         coldata.Vec
	col                         []duration.Duration
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      duration.Duration
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullIntervalAgg{}

const sizeOfAnyNotNullIntervalAgg = int64(unsafe.Sizeof(anyNotNullIntervalAgg{}))

func (a *anyNotNullIntervalAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Interval()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullIntervalAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullIntervalAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullIntervalAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *anyNotNullIntervalAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Interval(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col[i]
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullIntervalAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *anyNotNullIntervalAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullIntervalAggAlloc struct {
	allocator *colmem.Allocator
	allocSize int64
	aggFuncs  []anyNotNullIntervalAgg
}

var _ aggregateFuncAlloc = &anyNotNullIntervalAggAlloc{}

func (a *anyNotNullIntervalAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullIntervalAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullIntervalAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

// anyNotNullDatumAgg implements the ANY_NOT_NULL aggregate, returning the
// first non-null value in the input column.
type anyNotNullDatumAgg struct {
	allocator                   *colmem.Allocator
	groups                      []bool
	vec                         coldata.Vec
	col                         coldata.DatumVec
	nulls                       *coldata.Nulls
	curIdx                      int
	curAgg                      interface{}
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &anyNotNullDatumAgg{}

const sizeOfAnyNotNullDatumAgg = int64(unsafe.Sizeof(anyNotNullDatumAgg{}))

func (a *anyNotNullDatumAgg) Init(groups []bool, vec coldata.Vec) {
	a.groups = groups
	a.vec = vec
	a.col = vec.Datum()
	a.nulls = vec.Nulls()
	a.Reset()
}

func (a *anyNotNullDatumAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *anyNotNullDatumAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *anyNotNullDatumAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *anyNotNullDatumAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Datum(), vec.Nulls()

	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col.Get(i)
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col.Slice(0, inputLen)
					for i := 0; i < inputLen; i++ {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col.Get(i)
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col.Get(i)
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				} else {
					col = col.Slice(0, inputLen)
					for i := 0; i < inputLen; i++ {
						if a.groups[i] {
							// The `a.curIdx` check is necessary because for the first
							// group in the result set there is no "current group."
							if a.curIdx >= 0 {
								// If this is a new group, check if any non-nulls have been found for the
								// current group.
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !a.foundNonNullForCurrentGroup && !isNull {
							// If we haven't seen any non-nulls for the current group yet, and the
							// current value is non-null, then we can pick the current value to be the
							// output.
							val := col.Get(i)
							a.curAgg = val
							a.foundNonNullForCurrentGroup = true
						}
					}
				}
			}
		},
	)
}

func (a *anyNotNullDatumAgg) Flush() {
	// If we haven't found any non-nulls for this group so far, the output for
	// this group should be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col.Set(a.curIdx, a.curAgg)
	}
	a.curIdx++
}

func (a *anyNotNullDatumAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type anyNotNullDatumAggAlloc struct {
	allocator *colmem.Allocator
	allocSize int64
	aggFuncs  []anyNotNullDatumAgg
}

var _ aggregateFuncAlloc = &anyNotNullDatumAggAlloc{}

func (a *anyNotNullDatumAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfAnyNotNullDatumAgg * a.allocSize)
		a.aggFuncs = make([]anyNotNullDatumAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}
