// Code generated by execgen; DO NOT EDIT.
// Copyright 2020 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"fmt"
	"math"

	"github.com/cockroachdb/cockroach/pkg/col/coltypes"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/execerror"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
)

// checkCol determines if the current key column in the groupID buckets matches
// the specified equality column key. If there is a match, then the key is added
// to differs. If the bucket has reached the end, the key is rejected. If the
// hashTable disallows null equality, then if any element in the key is null,
// there is no match.
func (ht *hashTable) checkCol(
	probeType, buildType coltypes.T, keyColIdx int, nToCheck uint16, sel []uint16,
) {
	// In order to inline the templated code of overloads, we need to have a
	// `decimalScratch` local variable of type `decimalOverloadScratch`.
	decimalScratch := ht.decimalScratch
	switch probeType {
	case coltypes.Bool:
		switch buildType {
		case coltypes.Bool:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Bool()
			buildKeys := buildVec.Bool()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											if !probeVal && buildVal {
												cmpResult = -1
											} else if probeVal && !buildVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											if !probeVal && buildVal {
												cmpResult = -1
											} else if probeVal && !buildVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										if !probeVal && buildVal {
											cmpResult = -1
										} else if probeVal && !buildVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										if !probeVal && buildVal {
											cmpResult = -1
										} else if probeVal && !buildVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										if !probeVal && buildVal {
											cmpResult = -1
										} else if probeVal && !buildVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											if !probeVal && buildVal {
												cmpResult = -1
											} else if probeVal && !buildVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											if !probeVal && buildVal {
												cmpResult = -1
											} else if probeVal && !buildVal {
												cmpResult = 1
											} else {
												cmpResult = 0
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										if !probeVal && buildVal {
											cmpResult = -1
										} else if probeVal && !buildVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										if !probeVal && buildVal {
											cmpResult = -1
										} else if probeVal && !buildVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										if !probeVal && buildVal {
											cmpResult = -1
										} else if probeVal && !buildVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		default:
			execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", buildType))
		}
	case coltypes.Bytes:
		switch buildType {
		case coltypes.Bytes:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Bytes()
			buildKeys := buildVec.Bytes()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys.Get(int(selIdx))
										buildVal := buildKeys.Get(int(keyID - 1))
										var unique bool

										{
											var cmpResult int
											cmpResult = bytes.Compare(probeVal, buildVal)
											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys.Get(int(selIdx))
										buildVal := buildKeys.Get(int(keyID - 1))
										var unique bool

										{
											var cmpResult int
											cmpResult = bytes.Compare(probeVal, buildVal)
											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys.Get(int(selIdx))
									buildVal := buildKeys.Get(int(keyID - 1))
									var unique bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(probeVal, buildVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys.Get(int(selIdx))
									buildVal := buildKeys.Get(int(keyID - 1))
									var unique bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(probeVal, buildVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys.Get(int(selIdx))
									buildVal := buildKeys.Get(int(keyID - 1))
									var unique bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(probeVal, buildVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys.Get(int(selIdx))
										buildVal := buildKeys.Get(int(keyID - 1))
										var unique bool

										{
											var cmpResult int
											cmpResult = bytes.Compare(probeVal, buildVal)
											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys.Get(int(selIdx))
										buildVal := buildKeys.Get(int(keyID - 1))
										var unique bool

										{
											var cmpResult int
											cmpResult = bytes.Compare(probeVal, buildVal)
											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys.Get(int(selIdx))
									buildVal := buildKeys.Get(int(keyID - 1))
									var unique bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(probeVal, buildVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys.Get(int(selIdx))
									buildVal := buildKeys.Get(int(keyID - 1))
									var unique bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(probeVal, buildVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys.Get(int(selIdx))
									buildVal := buildKeys.Get(int(keyID - 1))
									var unique bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(probeVal, buildVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		default:
			execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", buildType))
		}
	case coltypes.Decimal:
		switch buildType {
		case coltypes.Decimal:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Decimal()
			buildKeys := buildVec.Decimal()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int
											cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&probeVal, &buildVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		case coltypes.Int16:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Decimal()
			buildKeys := buildVec.Int16()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(buildVal), 0)
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(buildVal), 0)
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(buildVal), 0)
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(buildVal), 0)
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(buildVal), 0)
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(buildVal), 0)
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		case coltypes.Int32:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Decimal()
			buildKeys := buildVec.Int32()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(buildVal), 0)
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(buildVal), 0)
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(buildVal), 0)
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(buildVal), 0)
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(buildVal), 0)
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(buildVal), 0)
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		case coltypes.Int64:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Decimal()
			buildKeys := buildVec.Int64()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(buildVal), 0)
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(buildVal), 0)
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(buildVal), 0)
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(buildVal), 0)
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(buildVal), 0)
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(buildVal), 0)
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(buildVal), 0)
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		case coltypes.Float64:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Decimal()
			buildKeys := buildVec.Float64()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
												execerror.NonVectorizedPanic(err)
											}
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
												execerror.NonVectorizedPanic(err)
											}
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
												execerror.NonVectorizedPanic(err)
											}
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
												execerror.NonVectorizedPanic(err)
											}
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
												execerror.NonVectorizedPanic(err)
											}
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											if _, err := tmpDec.SetFloat64(float64(buildVal)); err != nil {
												execerror.NonVectorizedPanic(err)
											}
											cmpResult = tree.CompareDecimals(&probeVal, tmpDec)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		default:
			execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", buildType))
		}
	case coltypes.Int16:
		switch buildType {
		case coltypes.Decimal:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Int16()
			buildKeys := buildVec.Decimal()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(probeVal), 0)
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(probeVal), 0)
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(probeVal), 0)
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(probeVal), 0)
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(probeVal), 0)
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(probeVal), 0)
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		case coltypes.Int16:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Int16()
			buildKeys := buildVec.Int16()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		case coltypes.Int32:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Int16()
			buildKeys := buildVec.Int32()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		case coltypes.Int64:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Int16()
			buildKeys := buildVec.Int64()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		case coltypes.Float64:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Int16()
			buildKeys := buildVec.Float64()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if false {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if false {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if false {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if false {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if false {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if false {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		default:
			execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", buildType))
		}
	case coltypes.Int32:
		switch buildType {
		case coltypes.Decimal:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Int32()
			buildKeys := buildVec.Decimal()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(probeVal), 0)
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(probeVal), 0)
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(probeVal), 0)
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(probeVal), 0)
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(probeVal), 0)
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(probeVal), 0)
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		case coltypes.Int16:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Int32()
			buildKeys := buildVec.Int16()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		case coltypes.Int32:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Int32()
			buildKeys := buildVec.Int32()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		case coltypes.Int64:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Int32()
			buildKeys := buildVec.Int64()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		case coltypes.Float64:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Int32()
			buildKeys := buildVec.Float64()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if false {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if false {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if false {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if false {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if false {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if false {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		default:
			execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", buildType))
		}
	case coltypes.Int64:
		switch buildType {
		case coltypes.Decimal:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Int64()
			buildKeys := buildVec.Decimal()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(probeVal), 0)
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(probeVal), 0)
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(probeVal), 0)
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												tmpDec.SetFinite(int64(probeVal), 0)
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(probeVal), 0)
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(probeVal), 0)
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											tmpDec.SetFinite(int64(probeVal), 0)
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		case coltypes.Int16:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Int64()
			buildKeys := buildVec.Int16()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		case coltypes.Int32:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Int64()
			buildKeys := buildVec.Int32()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		case coltypes.Int64:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Int64()
			buildKeys := buildVec.Int64()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := int64(probeVal), int64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else {
													cmpResult = 0
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(probeVal), int64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		case coltypes.Float64:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Int64()
			buildKeys := buildVec.Float64()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if false {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if false {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if false {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if false {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if false {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if false {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if false {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		default:
			execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", buildType))
		}
	case coltypes.Float64:
		switch buildType {
		case coltypes.Decimal:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Float64()
			buildKeys := buildVec.Decimal()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
												execerror.NonVectorizedPanic(err)
											}
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
												execerror.NonVectorizedPanic(err)
											}
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
												execerror.NonVectorizedPanic(err)
											}
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												tmpDec := &decimalScratch.tmpDec1
												if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
													execerror.NonVectorizedPanic(err)
												}
												cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
												execerror.NonVectorizedPanic(err)
											}
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
												execerror.NonVectorizedPanic(err)
											}
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											tmpDec := &decimalScratch.tmpDec1
											if _, err := tmpDec.SetFloat64(float64(probeVal)); err != nil {
												execerror.NonVectorizedPanic(err)
											}
											cmpResult = tree.CompareDecimals(tmpDec, &buildVal)
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		case coltypes.Int16:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Float64()
			buildKeys := buildVec.Int16()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if false {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if false {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if false {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if false {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if false {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if false {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		case coltypes.Int32:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Float64()
			buildKeys := buildVec.Int32()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if false {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if false {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if false {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if false {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if false {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if false {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		case coltypes.Int64:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Float64()
			buildKeys := buildVec.Int64()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if false {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if false {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if false {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if false {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if false {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if false {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if false {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		case coltypes.Float64:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Float64()
			buildKeys := buildVec.Float64()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											{
												a, b := float64(probeVal), float64(buildVal)
												if a < b {
													cmpResult = -1
												} else if a > b {
													cmpResult = 1
												} else if a == b {
													cmpResult = 0
												} else if math.IsNaN(a) {
													if math.IsNaN(b) {
														cmpResult = 0
													} else {
														cmpResult = -1
													}
												} else {
													cmpResult = 1
												}
											}

											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(probeVal), float64(buildVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		default:
			execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", buildType))
		}
	case coltypes.Timestamp:
		switch buildType {
		case coltypes.Timestamp:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Timestamp()
			buildKeys := buildVec.Timestamp()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											if probeVal.Before(buildVal) {
												cmpResult = -1
											} else if buildVal.Before(probeVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											if probeVal.Before(buildVal) {
												cmpResult = -1
											} else if buildVal.Before(probeVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										if probeVal.Before(buildVal) {
											cmpResult = -1
										} else if buildVal.Before(probeVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										if probeVal.Before(buildVal) {
											cmpResult = -1
										} else if buildVal.Before(probeVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										if probeVal.Before(buildVal) {
											cmpResult = -1
										} else if buildVal.Before(probeVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											if probeVal.Before(buildVal) {
												cmpResult = -1
											} else if buildVal.Before(probeVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int

											if probeVal.Before(buildVal) {
												cmpResult = -1
											} else if buildVal.Before(probeVal) {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										if probeVal.Before(buildVal) {
											cmpResult = -1
										} else if buildVal.Before(probeVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										if probeVal.Before(buildVal) {
											cmpResult = -1
										} else if buildVal.Before(probeVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int

										if probeVal.Before(buildVal) {
											cmpResult = -1
										} else if buildVal.Before(probeVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		default:
			execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", buildType))
		}
	case coltypes.Interval:
		switch buildType {
		case coltypes.Interval:
			probeVec := ht.keys[keyColIdx]
			buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
			probeKeys := probeVec.Interval()
			buildKeys := buildVec.Interval()

			if sel != nil {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int
											cmpResult = probeVal.Compare(buildVal)
											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := sel[toCheck]
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int
											cmpResult = probeVal.Compare(buildVal)
											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int
										cmpResult = probeVal.Compare(buildVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int
										cmpResult = probeVal.Compare(buildVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int
										cmpResult = probeVal.Compare(buildVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			} else {
				if probeVec.MaybeHasNulls() {
					if buildVec.MaybeHasNulls() {
						if ht.allowNullEquality {
							// The allowNullEquality flag only matters if both vectors have nulls.
							// This lets us avoid writing all 2^3 conditional branches.
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull && buildIsNull {
										// Both values are NULLs, and since we're allowing null equality, we
										// proceed to the next value to check.
										continue
									} else if probeIsNull {
										// Only probing value is NULL, so it is different from the build value
										// (which is non-NULL). We mark it as "different" and proceed to the
										// next value to check. This behavior is special in case of allowing
										// null equality because we don't want to reset the groupID of the
										// current probing tuple.
										ht.differs[toCheck] = true
										continue
									}
									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int
											cmpResult = probeVal.Compare(buildVal)
											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						} else {
							probeIsNull := false
							buildIsNull := false
							// Early bounds check.
							_ = ht.toCheck[nToCheck-1]
							for i := uint16(0); i < nToCheck; i++ {
								// keyID of 0 is reserved to represent the end of the next chain.

								toCheck := ht.toCheck[i]
								if keyID := ht.groupID[toCheck]; keyID != 0 {
									// the build table key (calculated using keys[keyID - 1] = key) is
									// compared to the corresponding probe table to determine if a match is
									// found.

									selIdx := toCheck
									probeIsNull = probeVec.Nulls().NullAt(selIdx)

									buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

									if probeIsNull {
										ht.groupID[toCheck] = 0
									} else if buildIsNull {
										ht.differs[toCheck] = true
									} else {
										probeVal := probeKeys[int(selIdx)]
										buildVal := buildKeys[int(keyID-1)]
										var unique bool

										{
											var cmpResult int
											cmpResult = probeVal.Compare(buildVal)
											unique = cmpResult != 0
										}

										ht.differs[toCheck] = ht.differs[toCheck] || unique
									}
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int
										cmpResult = probeVal.Compare(buildVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					if buildVec.MaybeHasNulls() {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int
										cmpResult = probeVal.Compare(buildVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									probeVal := probeKeys[int(selIdx)]
									buildVal := buildKeys[int(keyID-1)]
									var unique bool

									{
										var cmpResult int
										cmpResult = probeVal.Compare(buildVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				}
			}
		default:
			execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", buildType))
		}
	default:
		execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", probeType))
	}
}
