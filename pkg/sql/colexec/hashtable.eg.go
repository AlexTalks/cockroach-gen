// Code generated by execgen; DO NOT EDIT.
// Copyright 2020 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"fmt"
	"math"

	"github.com/cockroachdb/cockroach/pkg/col/coltypes"
	"github.com/cockroachdb/cockroach/pkg/sql/colexec/execerror"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
)

// checkCol determines if the current key column in the groupID buckets matches
// the specified equality column key. If there is a match, then the key is added
// to differs. If the bucket has reached the end, the key is rejected. If the
// hashTable disallows null equality, then if any element in the key is null,
// there is no match.
func (ht *hashTable) checkCol(t coltypes.T, keyColIdx int, nToCheck uint16, sel []uint16) {
	switch t {
	case coltypes.Bool:
		buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Bool()
		probeKeys := probeVec.Bool()

		if sel != nil {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									// Both values are NULLs, and since we're allowing null equality, we
									// proceed to the next value to check.
									continue
								} else if probeIsNull {
									// Only probing value is NULL, so it is different from the build value
									// (which is non-NULL). We mark it as "different" and proceed to the
									// next value to check. This behavior is special in case of allowing
									// null equality because we don't want to reset the groupID of the
									// current probing tuple.
									ht.differs[toCheck] = true
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										if !buildVal && probeVal {
											cmpResult = -1
										} else if buildVal && !probeVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										if !buildVal && probeVal {
											cmpResult = -1
										} else if buildVal && !probeVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if !buildVal && probeVal {
										cmpResult = -1
									} else if buildVal && !probeVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if !buildVal && probeVal {
										cmpResult = -1
									} else if buildVal && !probeVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if !buildVal && probeVal {
										cmpResult = -1
									} else if buildVal && !probeVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			}
		} else {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									// Both values are NULLs, and since we're allowing null equality, we
									// proceed to the next value to check.
									continue
								} else if probeIsNull {
									// Only probing value is NULL, so it is different from the build value
									// (which is non-NULL). We mark it as "different" and proceed to the
									// next value to check. This behavior is special in case of allowing
									// null equality because we don't want to reset the groupID of the
									// current probing tuple.
									ht.differs[toCheck] = true
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										if !buildVal && probeVal {
											cmpResult = -1
										} else if buildVal && !probeVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										if !buildVal && probeVal {
											cmpResult = -1
										} else if buildVal && !probeVal {
											cmpResult = 1
										} else {
											cmpResult = 0
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if !buildVal && probeVal {
										cmpResult = -1
									} else if buildVal && !probeVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if !buildVal && probeVal {
										cmpResult = -1
									} else if buildVal && !probeVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if !buildVal && probeVal {
										cmpResult = -1
									} else if buildVal && !probeVal {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			}
		}
	case coltypes.Bytes:
		buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Bytes()
		probeKeys := probeVec.Bytes()

		if sel != nil {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									// Both values are NULLs, and since we're allowing null equality, we
									// proceed to the next value to check.
									continue
								} else if probeIsNull {
									// Only probing value is NULL, so it is different from the build value
									// (which is non-NULL). We mark it as "different" and proceed to the
									// next value to check. This behavior is special in case of allowing
									// null equality because we don't want to reset the groupID of the
									// current probing tuple.
									ht.differs[toCheck] = true
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys.Get(int(keyID - 1))
									probeVal := probeKeys.Get(int(selIdx))
									var unique bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(buildVal, probeVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys.Get(int(keyID - 1))
									probeVal := probeKeys.Get(int(selIdx))
									var unique bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(buildVal, probeVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys.Get(int(keyID - 1))
								probeVal := probeKeys.Get(int(selIdx))
								var unique bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(buildVal, probeVal)
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys.Get(int(keyID - 1))
								probeVal := probeKeys.Get(int(selIdx))
								var unique bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(buildVal, probeVal)
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys.Get(int(keyID - 1))
								probeVal := probeKeys.Get(int(selIdx))
								var unique bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(buildVal, probeVal)
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			}
		} else {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									// Both values are NULLs, and since we're allowing null equality, we
									// proceed to the next value to check.
									continue
								} else if probeIsNull {
									// Only probing value is NULL, so it is different from the build value
									// (which is non-NULL). We mark it as "different" and proceed to the
									// next value to check. This behavior is special in case of allowing
									// null equality because we don't want to reset the groupID of the
									// current probing tuple.
									ht.differs[toCheck] = true
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys.Get(int(keyID - 1))
									probeVal := probeKeys.Get(int(selIdx))
									var unique bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(buildVal, probeVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys.Get(int(keyID - 1))
									probeVal := probeKeys.Get(int(selIdx))
									var unique bool

									{
										var cmpResult int
										cmpResult = bytes.Compare(buildVal, probeVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys.Get(int(keyID - 1))
								probeVal := probeKeys.Get(int(selIdx))
								var unique bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(buildVal, probeVal)
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys.Get(int(keyID - 1))
								probeVal := probeKeys.Get(int(selIdx))
								var unique bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(buildVal, probeVal)
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys.Get(int(keyID - 1))
								probeVal := probeKeys.Get(int(selIdx))
								var unique bool

								{
									var cmpResult int
									cmpResult = bytes.Compare(buildVal, probeVal)
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			}
		}
	case coltypes.Decimal:
		buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Decimal()
		probeKeys := probeVec.Decimal()

		if sel != nil {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									// Both values are NULLs, and since we're allowing null equality, we
									// proceed to the next value to check.
									continue
								} else if probeIsNull {
									// Only probing value is NULL, so it is different from the build value
									// (which is non-NULL). We mark it as "different" and proceed to the
									// next value to check. This behavior is special in case of allowing
									// null equality because we don't want to reset the groupID of the
									// current probing tuple.
									ht.differs[toCheck] = true
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&buildVal, &probeVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&buildVal, &probeVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&buildVal, &probeVal)
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&buildVal, &probeVal)
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&buildVal, &probeVal)
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			}
		} else {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									// Both values are NULLs, and since we're allowing null equality, we
									// proceed to the next value to check.
									continue
								} else if probeIsNull {
									// Only probing value is NULL, so it is different from the build value
									// (which is non-NULL). We mark it as "different" and proceed to the
									// next value to check. This behavior is special in case of allowing
									// null equality because we don't want to reset the groupID of the
									// current probing tuple.
									ht.differs[toCheck] = true
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&buildVal, &probeVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int
										cmpResult = tree.CompareDecimals(&buildVal, &probeVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&buildVal, &probeVal)
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&buildVal, &probeVal)
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&buildVal, &probeVal)
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			}
		}
	case coltypes.Int16:
		buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Int16()
		probeKeys := probeVec.Int16()

		if sel != nil {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									// Both values are NULLs, and since we're allowing null equality, we
									// proceed to the next value to check.
									continue
								} else if probeIsNull {
									// Only probing value is NULL, so it is different from the build value
									// (which is non-NULL). We mark it as "different" and proceed to the
									// next value to check. This behavior is special in case of allowing
									// null equality because we don't want to reset the groupID of the
									// current probing tuple.
									ht.differs[toCheck] = true
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			}
		} else {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									// Both values are NULLs, and since we're allowing null equality, we
									// proceed to the next value to check.
									continue
								} else if probeIsNull {
									// Only probing value is NULL, so it is different from the build value
									// (which is non-NULL). We mark it as "different" and proceed to the
									// next value to check. This behavior is special in case of allowing
									// null equality because we don't want to reset the groupID of the
									// current probing tuple.
									ht.differs[toCheck] = true
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			}
		}
	case coltypes.Int32:
		buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Int32()
		probeKeys := probeVec.Int32()

		if sel != nil {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									// Both values are NULLs, and since we're allowing null equality, we
									// proceed to the next value to check.
									continue
								} else if probeIsNull {
									// Only probing value is NULL, so it is different from the build value
									// (which is non-NULL). We mark it as "different" and proceed to the
									// next value to check. This behavior is special in case of allowing
									// null equality because we don't want to reset the groupID of the
									// current probing tuple.
									ht.differs[toCheck] = true
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			}
		} else {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									// Both values are NULLs, and since we're allowing null equality, we
									// proceed to the next value to check.
									continue
								} else if probeIsNull {
									// Only probing value is NULL, so it is different from the build value
									// (which is non-NULL). We mark it as "different" and proceed to the
									// next value to check. This behavior is special in case of allowing
									// null equality because we don't want to reset the groupID of the
									// current probing tuple.
									ht.differs[toCheck] = true
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			}
		}
	case coltypes.Int64:
		buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Int64()
		probeKeys := probeVec.Int64()

		if sel != nil {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									// Both values are NULLs, and since we're allowing null equality, we
									// proceed to the next value to check.
									continue
								} else if probeIsNull {
									// Only probing value is NULL, so it is different from the build value
									// (which is non-NULL). We mark it as "different" and proceed to the
									// next value to check. This behavior is special in case of allowing
									// null equality because we don't want to reset the groupID of the
									// current probing tuple.
									ht.differs[toCheck] = true
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			}
		} else {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									// Both values are NULLs, and since we're allowing null equality, we
									// proceed to the next value to check.
									continue
								} else if probeIsNull {
									// Only probing value is NULL, so it is different from the build value
									// (which is non-NULL). We mark it as "different" and proceed to the
									// next value to check. This behavior is special in case of allowing
									// null equality because we don't want to reset the groupID of the
									// current probing tuple.
									ht.differs[toCheck] = true
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := int64(buildVal), int64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else {
												cmpResult = 0
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := int64(buildVal), int64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			}
		}
	case coltypes.Float64:
		buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Float64()
		probeKeys := probeVec.Float64()

		if sel != nil {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									// Both values are NULLs, and since we're allowing null equality, we
									// proceed to the next value to check.
									continue
								} else if probeIsNull {
									// Only probing value is NULL, so it is different from the build value
									// (which is non-NULL). We mark it as "different" and proceed to the
									// next value to check. This behavior is special in case of allowing
									// null equality because we don't want to reset the groupID of the
									// current probing tuple.
									ht.differs[toCheck] = true
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(buildVal), float64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(buildVal), float64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := float64(buildVal), float64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := float64(buildVal), float64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := float64(buildVal), float64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			}
		} else {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									// Both values are NULLs, and since we're allowing null equality, we
									// proceed to the next value to check.
									continue
								} else if probeIsNull {
									// Only probing value is NULL, so it is different from the build value
									// (which is non-NULL). We mark it as "different" and proceed to the
									// next value to check. This behavior is special in case of allowing
									// null equality because we don't want to reset the groupID of the
									// current probing tuple.
									ht.differs[toCheck] = true
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(buildVal), float64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										{
											a, b := float64(buildVal), float64(probeVal)
											if a < b {
												cmpResult = -1
											} else if a > b {
												cmpResult = 1
											} else if a == b {
												cmpResult = 0
											} else if math.IsNaN(a) {
												if math.IsNaN(b) {
													cmpResult = 0
												} else {
													cmpResult = -1
												}
											} else {
												cmpResult = 1
											}
										}

										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := float64(buildVal), float64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := float64(buildVal), float64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									{
										a, b := float64(buildVal), float64(probeVal)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			}
		}
	case coltypes.Timestamp:
		buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Timestamp()
		probeKeys := probeVec.Timestamp()

		if sel != nil {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									// Both values are NULLs, and since we're allowing null equality, we
									// proceed to the next value to check.
									continue
								} else if probeIsNull {
									// Only probing value is NULL, so it is different from the build value
									// (which is non-NULL). We mark it as "different" and proceed to the
									// next value to check. This behavior is special in case of allowing
									// null equality because we don't want to reset the groupID of the
									// current probing tuple.
									ht.differs[toCheck] = true
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										if buildVal.Before(probeVal) {
											cmpResult = -1
										} else if probeVal.Before(buildVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										if buildVal.Before(probeVal) {
											cmpResult = -1
										} else if probeVal.Before(buildVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if buildVal.Before(probeVal) {
										cmpResult = -1
									} else if probeVal.Before(buildVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if buildVal.Before(probeVal) {
										cmpResult = -1
									} else if probeVal.Before(buildVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if buildVal.Before(probeVal) {
										cmpResult = -1
									} else if probeVal.Before(buildVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			}
		} else {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									// Both values are NULLs, and since we're allowing null equality, we
									// proceed to the next value to check.
									continue
								} else if probeIsNull {
									// Only probing value is NULL, so it is different from the build value
									// (which is non-NULL). We mark it as "different" and proceed to the
									// next value to check. This behavior is special in case of allowing
									// null equality because we don't want to reset the groupID of the
									// current probing tuple.
									ht.differs[toCheck] = true
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										if buildVal.Before(probeVal) {
											cmpResult = -1
										} else if probeVal.Before(buildVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int

										if buildVal.Before(probeVal) {
											cmpResult = -1
										} else if probeVal.Before(buildVal) {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if buildVal.Before(probeVal) {
										cmpResult = -1
									} else if probeVal.Before(buildVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if buildVal.Before(probeVal) {
										cmpResult = -1
									} else if probeVal.Before(buildVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int

									if buildVal.Before(probeVal) {
										cmpResult = -1
									} else if probeVal.Before(buildVal) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			}
		}
	case coltypes.Interval:
		buildVec := ht.vals.colVecs[ht.keyCols[keyColIdx]]
		probeVec := ht.keys[keyColIdx]

		buildKeys := buildVec.Interval()
		probeKeys := probeVec.Interval()

		if sel != nil {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									// Both values are NULLs, and since we're allowing null equality, we
									// proceed to the next value to check.
									continue
								} else if probeIsNull {
									// Only probing value is NULL, so it is different from the build value
									// (which is non-NULL). We mark it as "different" and proceed to the
									// next value to check. This behavior is special in case of allowing
									// null equality because we don't want to reset the groupID of the
									// current probing tuple.
									ht.differs[toCheck] = true
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int
										cmpResult = buildVal.Compare(probeVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := sel[toCheck]
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int
										cmpResult = buildVal.Compare(probeVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int
									cmpResult = buildVal.Compare(probeVal)
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int
									cmpResult = buildVal.Compare(probeVal)
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := sel[toCheck]

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int
									cmpResult = buildVal.Compare(probeVal)
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			}
		} else {
			if probeVec.MaybeHasNulls() {
				if buildVec.MaybeHasNulls() {
					if ht.allowNullEquality {
						// The allowNullEquality flag only matters if both vectors have nulls.
						// This lets us avoid writing all 2^3 conditional branches.
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull && buildIsNull {
									// Both values are NULLs, and since we're allowing null equality, we
									// proceed to the next value to check.
									continue
								} else if probeIsNull {
									// Only probing value is NULL, so it is different from the build value
									// (which is non-NULL). We mark it as "different" and proceed to the
									// next value to check. This behavior is special in case of allowing
									// null equality because we don't want to reset the groupID of the
									// current probing tuple.
									ht.differs[toCheck] = true
									continue
								}
								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int
										cmpResult = buildVal.Compare(probeVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					} else {
						probeIsNull := false
						buildIsNull := false
						// Early bounds check.
						_ = ht.toCheck[nToCheck-1]
						for i := uint16(0); i < nToCheck; i++ {
							// keyID of 0 is reserved to represent the end of the next chain.

							toCheck := ht.toCheck[i]
							if keyID := ht.groupID[toCheck]; keyID != 0 {
								// the build table key (calculated using keys[keyID - 1] = key) is
								// compared to the corresponding probe table to determine if a match is
								// found.

								selIdx := toCheck
								probeIsNull = probeVec.Nulls().NullAt(selIdx)

								buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

								if probeIsNull {
									ht.groupID[toCheck] = 0
								} else if buildIsNull {
									ht.differs[toCheck] = true
								} else {
									buildVal := buildKeys[int(keyID-1)]
									probeVal := probeKeys[int(selIdx)]
									var unique bool

									{
										var cmpResult int
										cmpResult = buildVal.Compare(probeVal)
										unique = cmpResult != 0
									}

									ht.differs[toCheck] = ht.differs[toCheck] || unique
								}
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck
							probeIsNull = probeVec.Nulls().NullAt(selIdx)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int
									cmpResult = buildVal.Compare(probeVal)
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			} else {
				if buildVec.MaybeHasNulls() {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							buildIsNull = buildVec.Nulls().NullAt64(keyID - 1)

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int
									cmpResult = buildVal.Compare(probeVal)
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				} else {
					probeIsNull := false
					buildIsNull := false
					// Early bounds check.
					_ = ht.toCheck[nToCheck-1]
					for i := uint16(0); i < nToCheck; i++ {
						// keyID of 0 is reserved to represent the end of the next chain.

						toCheck := ht.toCheck[i]
						if keyID := ht.groupID[toCheck]; keyID != 0 {
							// the build table key (calculated using keys[keyID - 1] = key) is
							// compared to the corresponding probe table to determine if a match is
							// found.

							selIdx := toCheck

							if probeIsNull {
								ht.groupID[toCheck] = 0
							} else if buildIsNull {
								ht.differs[toCheck] = true
							} else {
								buildVal := buildKeys[int(keyID-1)]
								probeVal := probeKeys[int(selIdx)]
								var unique bool

								{
									var cmpResult int
									cmpResult = buildVal.Compare(probeVal)
									unique = cmpResult != 0
								}

								ht.differs[toCheck] = ht.differs[toCheck] || unique
							}
						}
					}
				}
			}
		}
	default:
		execerror.VectorizedInternalPanic(fmt.Sprintf("unhandled type %d", t))
	}
}
