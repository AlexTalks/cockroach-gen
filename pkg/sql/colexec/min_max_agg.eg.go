// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package colexec

import (
	"bytes"
	"math"
	"time"
	"unsafe"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/col/coldata"
	"github.com/cockroachdb/cockroach/pkg/col/coldataext"
	"github.com/cockroachdb/cockroach/pkg/sql/colexecbase/colexecerror"
	"github.com/cockroachdb/cockroach/pkg/sql/colmem"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/util/duration"
)

// Remove unused warning.
var _ = colexecerror.InternalError

type minBoolAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg bool
	// col points to the output vector we are updating.
	col []bool
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minBoolAgg{}

const sizeOfminBoolAgg = int64(unsafe.Sizeof(minBoolAgg{}))

func (a *minBoolAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Bool()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minBoolAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *minBoolAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minBoolAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *minBoolAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bool(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minBoolAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *minBoolAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minBoolAggAlloc struct {
	aggAllocBase
	aggFuncs []minBoolAgg
}

var _ aggregateFuncAlloc = &minBoolAggAlloc{}

func (a *minBoolAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfminBoolAgg * a.allocSize)
		a.aggFuncs = make([]minBoolAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minBytesAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg []byte
	// col points to the output vector we are updating.
	col *coldata.Bytes
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minBytesAgg{}

const sizeOfminBytesAgg = int64(unsafe.Sizeof(minBytesAgg{}))

func (a *minBytesAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Bytes()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minBytesAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *minBytesAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minBytesAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *minBytesAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bytes(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				} else {
					col = col
					_ = 0
					_ = inputLen
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				} else {
					col = col
					_ = 0
					_ = inputLen
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minBytesAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col.Set(a.curIdx, a.curAgg)
	}
	a.curIdx++
}

func (a *minBytesAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minBytesAggAlloc struct {
	aggAllocBase
	aggFuncs []minBytesAgg
}

var _ aggregateFuncAlloc = &minBytesAggAlloc{}

func (a *minBytesAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfminBytesAgg * a.allocSize)
		a.aggFuncs = make([]minBytesAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minDecimalAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg apd.Decimal
	// col points to the output vector we are updating.
	col []apd.Decimal
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minDecimalAgg{}

const sizeOfminDecimalAgg = int64(unsafe.Sizeof(minDecimalAgg{}))

func (a *minDecimalAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Decimal()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minDecimalAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *minDecimalAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minDecimalAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *minDecimalAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Decimal(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minDecimalAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx].Set(&a.curAgg)
	}
	a.curIdx++
}

func (a *minDecimalAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minDecimalAggAlloc struct {
	aggAllocBase
	aggFuncs []minDecimalAgg
}

var _ aggregateFuncAlloc = &minDecimalAggAlloc{}

func (a *minDecimalAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfminDecimalAgg * a.allocSize)
		a.aggFuncs = make([]minDecimalAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minInt16Agg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int64
	// col points to the output vector we are updating.
	col []int64
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minInt16Agg{}

const sizeOfminInt16Agg = int64(unsafe.Sizeof(minInt16Agg{}))

func (a *minInt16Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minInt16Agg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *minInt16Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minInt16Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *minInt16Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int16(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minInt16Agg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *minInt16Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minInt16AggAlloc struct {
	aggAllocBase
	aggFuncs []minInt16Agg
}

var _ aggregateFuncAlloc = &minInt16AggAlloc{}

func (a *minInt16AggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfminInt16Agg * a.allocSize)
		a.aggFuncs = make([]minInt16Agg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minInt32Agg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int64
	// col points to the output vector we are updating.
	col []int64
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minInt32Agg{}

const sizeOfminInt32Agg = int64(unsafe.Sizeof(minInt32Agg{}))

func (a *minInt32Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minInt32Agg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *minInt32Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minInt32Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *minInt32Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int32(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minInt32Agg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *minInt32Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minInt32AggAlloc struct {
	aggAllocBase
	aggFuncs []minInt32Agg
}

var _ aggregateFuncAlloc = &minInt32AggAlloc{}

func (a *minInt32AggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfminInt32Agg * a.allocSize)
		a.aggFuncs = make([]minInt32Agg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minInt64Agg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int64
	// col points to the output vector we are updating.
	col []int64
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minInt64Agg{}

const sizeOfminInt64Agg = int64(unsafe.Sizeof(minInt64Agg{}))

func (a *minInt64Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minInt64Agg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *minInt64Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minInt64Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *minInt64Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int64(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minInt64Agg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *minInt64Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minInt64AggAlloc struct {
	aggAllocBase
	aggFuncs []minInt64Agg
}

var _ aggregateFuncAlloc = &minInt64AggAlloc{}

func (a *minInt64AggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfminInt64Agg * a.allocSize)
		a.aggFuncs = make([]minInt64Agg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minFloat64Agg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg float64
	// col points to the output vector we are updating.
	col []float64
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minFloat64Agg{}

const sizeOfminFloat64Agg = int64(unsafe.Sizeof(minFloat64Agg{}))

func (a *minFloat64Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Float64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minFloat64Agg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *minFloat64Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minFloat64Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *minFloat64Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Float64(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minFloat64Agg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *minFloat64Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minFloat64AggAlloc struct {
	aggAllocBase
	aggFuncs []minFloat64Agg
}

var _ aggregateFuncAlloc = &minFloat64AggAlloc{}

func (a *minFloat64AggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfminFloat64Agg * a.allocSize)
		a.aggFuncs = make([]minFloat64Agg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minTimestampAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg time.Time
	// col points to the output vector we are updating.
	col []time.Time
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minTimestampAgg{}

const sizeOfminTimestampAgg = int64(unsafe.Sizeof(minTimestampAgg{}))

func (a *minTimestampAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Timestamp()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minTimestampAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *minTimestampAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minTimestampAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *minTimestampAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Timestamp(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minTimestampAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *minTimestampAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minTimestampAggAlloc struct {
	aggAllocBase
	aggFuncs []minTimestampAgg
}

var _ aggregateFuncAlloc = &minTimestampAggAlloc{}

func (a *minTimestampAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfminTimestampAgg * a.allocSize)
		a.aggFuncs = make([]minTimestampAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minIntervalAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg duration.Duration
	// col points to the output vector we are updating.
	col []duration.Duration
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minIntervalAgg{}

const sizeOfminIntervalAgg = int64(unsafe.Sizeof(minIntervalAgg{}))

func (a *minIntervalAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Interval()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minIntervalAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *minIntervalAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minIntervalAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *minIntervalAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Interval(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minIntervalAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *minIntervalAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minIntervalAggAlloc struct {
	aggAllocBase
	aggFuncs []minIntervalAgg
}

var _ aggregateFuncAlloc = &minIntervalAggAlloc{}

func (a *minIntervalAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfminIntervalAgg * a.allocSize)
		a.aggFuncs = make([]minIntervalAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type minDatumAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg interface{}
	// col points to the output vector we are updating.
	col coldata.DatumVec
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &minDatumAgg{}

const sizeOfminDatumAgg = int64(unsafe.Sizeof(minDatumAgg{}))

func (a *minDatumAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Datum()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *minDatumAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *minDatumAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *minDatumAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *minDatumAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Datum(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col.Slice(0, inputLen)
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col.Slice(0, inputLen)
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult < 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *minDatumAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col.Set(a.curIdx, a.curAgg)
	}
	a.curIdx++
}

func (a *minDatumAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type minDatumAggAlloc struct {
	aggAllocBase
	aggFuncs []minDatumAgg
}

var _ aggregateFuncAlloc = &minDatumAggAlloc{}

func (a *minDatumAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfminDatumAgg * a.allocSize)
		a.aggFuncs = make([]minDatumAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxBoolAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg bool
	// col points to the output vector we are updating.
	col []bool
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxBoolAgg{}

const sizeOfmaxBoolAgg = int64(unsafe.Sizeof(maxBoolAgg{}))

func (a *maxBoolAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Bool()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxBoolAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *maxBoolAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxBoolAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *maxBoolAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bool(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if !candidate && a.curAgg {
										cmpResult = -1
									} else if candidate && !a.curAgg {
										cmpResult = 1
									} else {
										cmpResult = 0
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxBoolAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *maxBoolAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxBoolAggAlloc struct {
	aggAllocBase
	aggFuncs []maxBoolAgg
}

var _ aggregateFuncAlloc = &maxBoolAggAlloc{}

func (a *maxBoolAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfmaxBoolAgg * a.allocSize)
		a.aggFuncs = make([]maxBoolAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxBytesAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg []byte
	// col points to the output vector we are updating.
	col *coldata.Bytes
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxBytesAgg{}

const sizeOfmaxBytesAgg = int64(unsafe.Sizeof(maxBytesAgg{}))

func (a *maxBytesAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Bytes()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxBytesAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *maxBytesAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxBytesAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *maxBytesAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Bytes(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				} else {
					col = col
					_ = 0
					_ = inputLen
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				} else {
					col = col
					_ = 0
					_ = inputLen
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = append(a.curAgg[:0], val...)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int
									cmpResult = bytes.Compare(candidate, a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = append(a.curAgg[:0], candidate...)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxBytesAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col.Set(a.curIdx, a.curAgg)
	}
	a.curIdx++
}

func (a *maxBytesAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxBytesAggAlloc struct {
	aggAllocBase
	aggFuncs []maxBytesAgg
}

var _ aggregateFuncAlloc = &maxBytesAggAlloc{}

func (a *maxBytesAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfmaxBytesAgg * a.allocSize)
		a.aggFuncs = make([]maxBytesAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxDecimalAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg apd.Decimal
	// col points to the output vector we are updating.
	col []apd.Decimal
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxDecimalAgg{}

const sizeOfmaxDecimalAgg = int64(unsafe.Sizeof(maxDecimalAgg{}))

func (a *maxDecimalAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Decimal()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxDecimalAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *maxDecimalAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxDecimalAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *maxDecimalAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Decimal(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx].Set(&a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg.Set(&val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = tree.CompareDecimals(&candidate, &a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg.Set(&candidate)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxDecimalAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx].Set(&a.curAgg)
	}
	a.curIdx++
}

func (a *maxDecimalAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxDecimalAggAlloc struct {
	aggAllocBase
	aggFuncs []maxDecimalAgg
}

var _ aggregateFuncAlloc = &maxDecimalAggAlloc{}

func (a *maxDecimalAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfmaxDecimalAgg * a.allocSize)
		a.aggFuncs = make([]maxDecimalAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxInt16Agg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int64
	// col points to the output vector we are updating.
	col []int64
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxInt16Agg{}

const sizeOfmaxInt16Agg = int64(unsafe.Sizeof(maxInt16Agg{}))

func (a *maxInt16Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxInt16Agg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *maxInt16Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxInt16Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *maxInt16Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int16(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxInt16Agg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *maxInt16Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxInt16AggAlloc struct {
	aggAllocBase
	aggFuncs []maxInt16Agg
}

var _ aggregateFuncAlloc = &maxInt16AggAlloc{}

func (a *maxInt16AggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfmaxInt16Agg * a.allocSize)
		a.aggFuncs = make([]maxInt16Agg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxInt32Agg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int64
	// col points to the output vector we are updating.
	col []int64
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxInt32Agg{}

const sizeOfmaxInt32Agg = int64(unsafe.Sizeof(maxInt32Agg{}))

func (a *maxInt32Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxInt32Agg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *maxInt32Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxInt32Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *maxInt32Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int32(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxInt32Agg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *maxInt32Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxInt32AggAlloc struct {
	aggAllocBase
	aggFuncs []maxInt32Agg
}

var _ aggregateFuncAlloc = &maxInt32AggAlloc{}

func (a *maxInt32AggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfmaxInt32Agg * a.allocSize)
		a.aggFuncs = make([]maxInt32Agg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxInt64Agg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg int64
	// col points to the output vector we are updating.
	col []int64
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxInt64Agg{}

const sizeOfmaxInt64Agg = int64(unsafe.Sizeof(maxInt64Agg{}))

func (a *maxInt64Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Int64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxInt64Agg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *maxInt64Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxInt64Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *maxInt64Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Int64(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = int64(val)
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := int64(candidate), int64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else {
											cmpResult = 0
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = int64(candidate)
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxInt64Agg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *maxInt64Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxInt64AggAlloc struct {
	aggAllocBase
	aggFuncs []maxInt64Agg
}

var _ aggregateFuncAlloc = &maxInt64AggAlloc{}

func (a *maxInt64AggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfmaxInt64Agg * a.allocSize)
		a.aggFuncs = make([]maxInt64Agg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxFloat64Agg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg float64
	// col points to the output vector we are updating.
	col []float64
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxFloat64Agg{}

const sizeOfmaxFloat64Agg = int64(unsafe.Sizeof(maxFloat64Agg{}))

func (a *maxFloat64Agg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Float64()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxFloat64Agg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *maxFloat64Agg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxFloat64Agg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *maxFloat64Agg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Float64(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									{
										a, b := float64(candidate), float64(a.curAgg)
										if a < b {
											cmpResult = -1
										} else if a > b {
											cmpResult = 1
										} else if a == b {
											cmpResult = 0
										} else if math.IsNaN(a) {
											if math.IsNaN(b) {
												cmpResult = 0
											} else {
												cmpResult = -1
											}
										} else {
											cmpResult = 1
										}
									}

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxFloat64Agg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *maxFloat64Agg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxFloat64AggAlloc struct {
	aggAllocBase
	aggFuncs []maxFloat64Agg
}

var _ aggregateFuncAlloc = &maxFloat64AggAlloc{}

func (a *maxFloat64AggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfmaxFloat64Agg * a.allocSize)
		a.aggFuncs = make([]maxFloat64Agg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxTimestampAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg time.Time
	// col points to the output vector we are updating.
	col []time.Time
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxTimestampAgg{}

const sizeOfmaxTimestampAgg = int64(unsafe.Sizeof(maxTimestampAgg{}))

func (a *maxTimestampAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Timestamp()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxTimestampAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *maxTimestampAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxTimestampAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *maxTimestampAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Timestamp(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int

									if candidate.Before(a.curAgg) {
										cmpResult = -1
									} else if a.curAgg.Before(candidate) {
										cmpResult = 1
									} else {
										cmpResult = 0
									}
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxTimestampAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *maxTimestampAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxTimestampAggAlloc struct {
	aggAllocBase
	aggFuncs []maxTimestampAgg
}

var _ aggregateFuncAlloc = &maxTimestampAggAlloc{}

func (a *maxTimestampAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfmaxTimestampAgg * a.allocSize)
		a.aggFuncs = make([]maxTimestampAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxIntervalAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg duration.Duration
	// col points to the output vector we are updating.
	col []duration.Duration
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxIntervalAgg{}

const sizeOfmaxIntervalAgg = int64(unsafe.Sizeof(maxIntervalAgg{}))

func (a *maxIntervalAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Interval()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxIntervalAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *maxIntervalAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxIntervalAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *maxIntervalAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Interval(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col[0:inputLen]
					for i := range col {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col[a.curIdx] = a.curAgg
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col[i]
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col[i]

								{
									var cmpResult int
									cmpResult = candidate.Compare(a.curAgg)
									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxIntervalAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col[a.curIdx] = a.curAgg
	}
	a.curIdx++
}

func (a *maxIntervalAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxIntervalAggAlloc struct {
	aggAllocBase
	aggFuncs []maxIntervalAgg
}

var _ aggregateFuncAlloc = &maxIntervalAggAlloc{}

func (a *maxIntervalAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfmaxIntervalAgg * a.allocSize)
		a.aggFuncs = make([]maxIntervalAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}

type maxDatumAgg struct {
	allocator *colmem.Allocator
	groups    []bool
	curIdx    int
	// curAgg holds the running min/max, so we can index into the slice once per
	// group, instead of on each iteration.
	// NOTE: if foundNonNullForCurrentGroup is false, curAgg is undefined.
	curAgg interface{}
	// col points to the output vector we are updating.
	col coldata.DatumVec
	// vec is the same as col before conversion from coldata.Vec.
	vec coldata.Vec
	// nulls points to the output null vector that we are updating.
	nulls *coldata.Nulls
	// foundNonNullForCurrentGroup tracks if we have seen any non-null values
	// for the group that is currently being aggregated.
	foundNonNullForCurrentGroup bool
}

var _ aggregateFunc = &maxDatumAgg{}

const sizeOfmaxDatumAgg = int64(unsafe.Sizeof(maxDatumAgg{}))

func (a *maxDatumAgg) Init(groups []bool, v coldata.Vec) {
	a.groups = groups
	a.vec = v
	a.col = v.Datum()
	a.nulls = v.Nulls()
	a.Reset()
}

func (a *maxDatumAgg) Reset() {
	a.curIdx = -1
	a.foundNonNullForCurrentGroup = false
	a.nulls.UnsetNulls()
}

func (a *maxDatumAgg) CurrentOutputIndex() int {
	return a.curIdx
}

func (a *maxDatumAgg) SetOutputIndex(idx int) {
	if a.curIdx != -1 {
		a.curIdx = idx
		a.nulls.UnsetNullsAfter(idx + 1)
	}
}

func (a *maxDatumAgg) Compute(b coldata.Batch, inputIdxs []uint32) {
	inputLen := b.Length()
	vec, sel := b.ColVec(int(inputIdxs[0])), b.Selection()
	col, nulls := vec.Datum(), vec.Nulls()
	a.allocator.PerformOperation(
		[]coldata.Vec{a.vec},
		func() {
			if nulls.MaybeHasNulls() {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col.Slice(0, inputLen)
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = nulls.NullAt(i)
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			} else {
				if sel != nil {
					sel = sel[:inputLen]
					for _, i := range sel {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				} else {
					col = col.Slice(0, inputLen)
					for i := 0; i < inputLen; i++ {

						if a.groups[i] {
							// If we encounter a new group, and we haven't found any non-nulls for the
							// current group, the output for this group should be null. If a.curIdx is
							// negative, it means that this is the first group.
							if a.curIdx >= 0 {
								if !a.foundNonNullForCurrentGroup {
									a.nulls.SetNull(a.curIdx)
								} else {
									a.col.Set(a.curIdx, a.curAgg)
								}
							}
							a.curIdx++
							a.foundNonNullForCurrentGroup = false
						}
						var isNull bool
						isNull = false
						if !isNull {
							if !a.foundNonNullForCurrentGroup {
								val := col.Get(i)
								a.curAgg = val
								a.foundNonNullForCurrentGroup = true
							} else {
								var cmp bool
								candidate := col.Get(i)

								{
									var cmpResult int

									cmpResult = candidate.(*coldataext.Datum).CompareDatum(col, a.curAgg)

									cmp = cmpResult > 0
								}

								if cmp {
									a.curAgg = candidate
								}
							}
						}
					}
				}
			}
		},
	)
}

func (a *maxDatumAgg) Flush() {
	// The aggregation is finished. Flush the last value. If we haven't found
	// any non-nulls for this group so far, the output for this group should
	// be null.
	if !a.foundNonNullForCurrentGroup {
		a.nulls.SetNull(a.curIdx)
	} else {
		a.col.Set(a.curIdx, a.curAgg)
	}
	a.curIdx++
}

func (a *maxDatumAgg) HandleEmptyInputScalar() {
	a.nulls.SetNull(0)
}

type maxDatumAggAlloc struct {
	aggAllocBase
	aggFuncs []maxDatumAgg
}

var _ aggregateFuncAlloc = &maxDatumAggAlloc{}

func (a *maxDatumAggAlloc) newAggFunc() aggregateFunc {
	if len(a.aggFuncs) == 0 {
		a.allocator.AdjustMemoryUsage(sizeOfmaxDatumAgg * a.allocSize)
		a.aggFuncs = make([]maxDatumAgg, a.allocSize)
	}
	f := &a.aggFuncs[0]
	f.allocator = a.allocator
	a.aggFuncs = a.aggFuncs[1:]
	return f
}
