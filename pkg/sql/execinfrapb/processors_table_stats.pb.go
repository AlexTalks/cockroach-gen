// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/execinfrapb/processors_table_stats.proto

// Beware! This package name must not be changed, even though it doesn't match
// the Go package name, because it defines the Protobuf message names which
// can't be changed without breaking backward compatibility.

package execinfrapb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_cockroachdb_cockroach_pkg_jobs_jobspb "github.com/cockroachdb/cockroach/pkg/jobs/jobspb"
	descpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
	github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb "github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type SketchType int32

const (
	// This is the github.com/axiomhq/hyperloglog binary format (as of commit
	// 730eea1) for a sketch with precision 14. Values are encoded using their key
	// encoding, except integers which are encoded in 8 bytes (little-endian).
	SketchType_HLL_PLUS_PLUS_V1 SketchType = 0
)

var SketchType_name = map[int32]string{
	0: "HLL_PLUS_PLUS_V1",
}

var SketchType_value = map[string]int32{
	"HLL_PLUS_PLUS_V1": 0,
}

func (x SketchType) Enum() *SketchType {
	p := new(SketchType)
	*p = x
	return p
}

func (x SketchType) String() string {
	return proto.EnumName(SketchType_name, int32(x))
}

func (x *SketchType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SketchType_value, data, "SketchType")
	if err != nil {
		return err
	}
	*x = SketchType(value)
	return nil
}

func (SketchType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d08bfa18785ff29a, []int{0}
}

// SketchSpec contains the specification for a generated statistic.
type SketchSpec struct {
	SketchType SketchType `protobuf:"varint,1,opt,name=sketch_type,json=sketchType,enum=cockroach.sql.distsqlrun.SketchType" json:"sketch_type"`
	// Each value is an index identifying a column in the input stream.
	// TODO(radu): currently only one column is supported.
	Columns []uint32 `protobuf:"varint,2,rep,name=columns" json:"columns,omitempty"`
	// If set, we generate a histogram for the first column in the sketch.
	GenerateHistogram bool `protobuf:"varint,3,opt,name=generate_histogram,json=generateHistogram" json:"generate_histogram"`
	// Controls the maximum number of buckets in the histogram.
	// Only used by the SampleAggregator.
	HistogramMaxBuckets uint32 `protobuf:"varint,4,opt,name=histogram_max_buckets,json=histogramMaxBuckets" json:"histogram_max_buckets"`
	// Only used by the SampleAggregator.
	StatName string `protobuf:"bytes,5,opt,name=stat_name,json=statName" json:"stat_name"`
	// Index is needed by some types (for example the geo types) when generating
	// inverted index entries, since it may contain configuration.
	Index *descpb.IndexDescriptor `protobuf:"bytes,6,opt,name=index" json:"index,omitempty"`
	// PartialPredicate is a string representing the predicate for a partial statistic,
	// and is the empty string for a full table statistic.
	PartialPredicate string `protobuf:"bytes,7,opt,name=partial_predicate,json=partialPredicate" json:"partial_predicate"`
	// FullStatisticID is non-zero for partial statistics and 0 for full
	// statistics. It is the statistic id of the full statistic that this partial
	// statistic was derived from.
	FullStatisticID uint64 `protobuf:"varint,8,opt,name=full_statistic_id,json=fullStatisticId" json:"full_statistic_id"`
}

func (m *SketchSpec) Reset()         { *m = SketchSpec{} }
func (m *SketchSpec) String() string { return proto.CompactTextString(m) }
func (*SketchSpec) ProtoMessage()    {}
func (*SketchSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d08bfa18785ff29a, []int{0}
}
func (m *SketchSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SketchSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SketchSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SketchSpec.Merge(m, src)
}
func (m *SketchSpec) XXX_Size() int {
	return m.Size()
}
func (m *SketchSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SketchSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SketchSpec proto.InternalMessageInfo

// SamplerSpec is the specification of a "sampler" processor which
// returns a sample (random subset) of the input columns and computes
// cardinality estimation sketches on sets of columns.
//
// The sampler is configured with a sample size and sets of columns for the
// sketches. It produces one row with global statistics, one row with sketch
// information for each sketch plus at least min_sample_size and at most
// sample_size sampled rows.
//
// For each column with an inverted index, a sketch and sample reservoir are
// created. Each of these produces one sketch row and at least min_sample_size
// and at most sample_size sampled rows from the inverted index keys.
//
// The following method is used to do reservoir sampling: we generate a
// "rank" for each row, which is just a random, uniformly distributed
// 64-bit value. The rows with the smallest <sample_size> ranks are selected.
// This method is chosen because it allows to combine sample sets very easily.
//
// The internal schema of the processor is formed of three column groups:
//  1. sampled row columns:
//     - columns that map 1-1 to the columns in the input (same
//     schema as the input). Note that columns unused in a histogram are
//     set to NULL.
//     - an INT column with the "rank" of the row; this is a random value
//     associated with the row (necessary for combining sample sets).
//  2. sketch columns:
//     - an INT column indicating the sketch index
//     (0 to len(sketches) - 1).
//     - an INT column indicating the number of rows processed
//     - an INT column indicating the number of rows with NULL values
//     on all columns of the sketch.
//     - an INT column indicating the sum of the size of all columns of the
//     sketch in bytes.
//     - a BYTES column with the binary sketch data (format
//     dependent on the sketch type).
//  3. inverted columns:
//     - an INT column identifying the column index for this inverted sample
//     - a BYTE column of the inverted index key.
//
// There are four row types produced:
//  1. sample rows, using column group #1 and the numRows column from #2.
//  2. sketch rows, using column group #2.
//  3. inverted sample rows, using column group #3, the rank column from #1,
//     and numRows column from #2.
//  4. inverted sketch rows, using column group #2 and first column from #3.
//
// Rows have NULLs on all columns they do not use.
type SamplerSpec struct {
	Sketches         []SketchSpec `protobuf:"bytes,1,rep,name=sketches" json:"sketches"`
	InvertedSketches []SketchSpec `protobuf:"bytes,4,rep,name=inverted_sketches,json=invertedSketches" json:"inverted_sketches"`
	SampleSize       uint32       `protobuf:"varint,2,opt,name=sample_size,json=sampleSize" json:"sample_size"`
	MinSampleSize    uint32       `protobuf:"varint,5,opt,name=min_sample_size,json=minSampleSize" json:"min_sample_size"`
	// Setting this value enables throttling; this is the fraction of time that
	// the sampler processors will be idle when the recent CPU usage is high. The
	// throttling is adaptive so the actual idle fraction will depend on CPU
	// usage; this value is a ceiling.
	//
	// Currently, this field is set only for automatic statistics based on the
	// value of the cluster setting
	// sql.stats.automatic_collection.max_fraction_idle.
	MaxFractionIdle float64 `protobuf:"fixed64,3,opt,name=max_fraction_idle,json=maxFractionIdle" json:"max_fraction_idle"`
}

func (m *SamplerSpec) Reset()         { *m = SamplerSpec{} }
func (m *SamplerSpec) String() string { return proto.CompactTextString(m) }
func (*SamplerSpec) ProtoMessage()    {}
func (*SamplerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d08bfa18785ff29a, []int{1}
}
func (m *SamplerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SamplerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SamplerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SamplerSpec.Merge(m, src)
}
func (m *SamplerSpec) XXX_Size() int {
	return m.Size()
}
func (m *SamplerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SamplerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SamplerSpec proto.InternalMessageInfo

// SampleAggregatorSpec is the specification of a processor that aggregates the
// results from multiple sampler processors and writes out the statistics to
// system.table_statistics.
//
// The input schema it expects matches the output schema of a sampler spec (see
// the comment for SamplerSpec for all the details):
//  1. sampled row columns:
//     - sampled columns
//     - row rank
//  2. sketch columns:
//     - sketch index
//     - number of rows processed
//     - number of rows encountered with NULL values on all columns of the sketch
//     - average size of the columns of the sketch in bytes
//     - binary sketch data
//  3. inverted columns:
//     - column index for inverted sample
//     - sample column
type SampleAggregatorSpec struct {
	Sketches         []SketchSpec `protobuf:"bytes,1,rep,name=sketches" json:"sketches"`
	InvertedSketches []SketchSpec `protobuf:"bytes,8,rep,name=inverted_sketches,json=invertedSketches" json:"inverted_sketches"`
	// The processor merges reservoir sample sets into a single sample set of
	// this size. (If this size is larger than the size of any sampler, it will
	// shrink dynamically.)
	SampleSize    uint32 `protobuf:"varint,2,opt,name=sample_size,json=sampleSize" json:"sample_size"`
	MinSampleSize uint32 `protobuf:"varint,9,opt,name=min_sample_size,json=minSampleSize" json:"min_sample_size"`
	// The i-th value indicates the ColumnID of the i-th sampled row column.
	// These are necessary for writing out the statistic data.
	SampledColumnIDs []github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID `protobuf:"varint,3,rep,name=sampled_column_ids,json=sampledColumnIds,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ColumnID" json:"sampled_column_ids,omitempty"`
	TableID          github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID         `protobuf:"varint,4,opt,name=table_id,json=tableId,casttype=github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb.ID" json:"table_id"`
	// JobID is the id of the CREATE STATISTICS job.
	JobID github_com_cockroachdb_cockroach_pkg_jobs_jobspb.JobID `protobuf:"varint,6,opt,name=job_id,json=jobId,casttype=github.com/cockroachdb/cockroach/pkg/jobs/jobspb.JobID" json:"job_id"`
	// The total number of rows expected in the table based on previous runs of
	// CREATE STATISTICS. Used for progress reporting. If rows expected is 0,
	// reported progress is 0 until the very end.
	RowsExpected uint64 `protobuf:"varint,7,opt,name=rows_expected,json=rowsExpected" json:"rows_expected"`
	// If true, delete old stats for columns not included in this message.
	DeleteOtherStats bool `protobuf:"varint,10,opt,name=delete_other_stats,json=deleteOtherStats" json:"delete_other_stats"`
	// If true, calculate partial table statistics on the extreme values of
	// the previous full table stat.
	UsingExtremes bool `protobuf:"varint,11,opt,name=using_extremes,json=usingExtremes" json:"using_extremes"`
}

func (m *SampleAggregatorSpec) Reset()         { *m = SampleAggregatorSpec{} }
func (m *SampleAggregatorSpec) String() string { return proto.CompactTextString(m) }
func (*SampleAggregatorSpec) ProtoMessage()    {}
func (*SampleAggregatorSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d08bfa18785ff29a, []int{2}
}
func (m *SampleAggregatorSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SampleAggregatorSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SampleAggregatorSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SampleAggregatorSpec.Merge(m, src)
}
func (m *SampleAggregatorSpec) XXX_Size() int {
	return m.Size()
}
func (m *SampleAggregatorSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SampleAggregatorSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SampleAggregatorSpec proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.sql.distsqlrun.SketchType", SketchType_name, SketchType_value)
	proto.RegisterType((*SketchSpec)(nil), "cockroach.sql.distsqlrun.SketchSpec")
	proto.RegisterType((*SamplerSpec)(nil), "cockroach.sql.distsqlrun.SamplerSpec")
	proto.RegisterType((*SampleAggregatorSpec)(nil), "cockroach.sql.distsqlrun.SampleAggregatorSpec")
}

func init() {
	proto.RegisterFile("sql/execinfrapb/processors_table_stats.proto", fileDescriptor_d08bfa18785ff29a)
}

var fileDescriptor_d08bfa18785ff29a = []byte{
	// 832 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x55, 0x4b, 0x73, 0x1b, 0x45,
	0x10, 0xd6, 0x5a, 0x92, 0x2d, 0x8f, 0x50, 0x2c, 0x0d, 0xa6, 0xd8, 0xca, 0x41, 0x12, 0xe6, 0x51,
	0x02, 0xc2, 0x8a, 0x98, 0x2a, 0x8a, 0xe2, 0x04, 0x8a, 0x62, 0xa2, 0xe0, 0x40, 0x4a, 0x0a, 0x8f,
	0xe2, 0xc0, 0xd4, 0xec, 0x4c, 0x7b, 0x35, 0xf6, 0xec, 0xce, 0x7a, 0x66, 0x16, 0x94, 0xfc, 0x00,
	0xce, 0xfc, 0x19, 0x7e, 0x00, 0x37, 0x1f, 0x73, 0xcc, 0x49, 0x05, 0xf2, 0x2f, 0xe0, 0x9a, 0x13,
	0xb5, 0x2f, 0x45, 0x81, 0x72, 0xf1, 0x38, 0xc0, 0x65, 0x6b, 0xb6, 0xbf, 0x47, 0x6b, 0xbb, 0xa7,
	0x5b, 0xe8, 0x86, 0x39, 0x97, 0x43, 0x58, 0x00, 0x13, 0xd1, 0x89, 0xa6, 0xb1, 0x3f, 0x8c, 0xb5,
	0x62, 0x60, 0x8c, 0xd2, 0x86, 0x58, 0xea, 0x4b, 0x20, 0xc6, 0x52, 0x6b, 0xbc, 0x58, 0x2b, 0xab,
	0xb0, 0xcb, 0x14, 0x3b, 0xd3, 0x8a, 0xb2, 0xb9, 0x67, 0xce, 0xa5, 0xc7, 0x85, 0xb1, 0xe6, 0x5c,
	0xea, 0x24, 0xba, 0xfe, 0x6a, 0xea, 0xc3, 0xa8, 0xa5, 0x52, 0x05, 0x43, 0x0e, 0x86, 0xc5, 0xfe,
	0xd0, 0x58, 0x9d, 0x30, 0x9b, 0x68, 0xe0, 0xb9, 0xfc, 0xfa, 0x7e, 0xa0, 0x02, 0x95, 0x1d, 0x87,
	0xe9, 0x29, 0x8f, 0x1e, 0xfc, 0x5c, 0x45, 0x68, 0x76, 0x06, 0x96, 0xcd, 0x67, 0x31, 0x30, 0xfc,
	0x29, 0x6a, 0x9a, 0xec, 0x8d, 0xd8, 0x87, 0x31, 0xb8, 0x4e, 0xdf, 0x19, 0x5c, 0x3b, 0x7c, 0xcd,
	0xbb, 0x2a, 0xb3, 0x97, 0x4b, 0x1f, 0x3c, 0x8c, 0x61, 0x54, 0xbb, 0x58, 0xf6, 0x2a, 0x53, 0x64,
	0xd6, 0x11, 0xec, 0xa2, 0x1d, 0xa6, 0x64, 0x12, 0x46, 0xc6, 0xdd, 0xea, 0x57, 0x07, 0xad, 0x69,
	0xf9, 0x8a, 0xdf, 0x43, 0x38, 0x80, 0x08, 0x34, 0xb5, 0x40, 0xe6, 0xc2, 0x58, 0x15, 0x68, 0x1a,
	0xba, 0xd5, 0xbe, 0x33, 0x68, 0x14, 0x3e, 0x9d, 0x12, 0xbf, 0x53, 0xc2, 0xf8, 0x03, 0xf4, 0xd2,
	0x9a, 0x4b, 0x42, 0xba, 0x20, 0x7e, 0xc2, 0xce, 0xc0, 0x1a, 0xb7, 0xd6, 0x77, 0x06, 0xad, 0x42,
	0xf7, 0xe2, 0x9a, 0x72, 0x8f, 0x2e, 0x46, 0x39, 0x01, 0xbf, 0x82, 0x76, 0xd3, 0x42, 0x92, 0x88,
	0x86, 0xe0, 0xd6, 0xfb, 0xce, 0x60, 0xb7, 0x60, 0x37, 0xd2, 0xf0, 0x67, 0x34, 0x04, 0x3c, 0x42,
	0x75, 0x11, 0x71, 0x58, 0xb8, 0xdb, 0x7d, 0x67, 0xd0, 0x3c, 0x7c, 0xe3, 0x0f, 0x9f, 0x6c, 0xce,
	0xa5, 0x4f, 0x0d, 0x78, 0x93, 0x94, 0x33, 0x06, 0xc3, 0xb4, 0x88, 0xad, 0xd2, 0x99, 0x8d, 0x33,
	0xcd, 0xa5, 0xf8, 0x26, 0xea, 0xc4, 0x54, 0x5b, 0x41, 0x25, 0x89, 0x35, 0x70, 0xc1, 0xa8, 0x05,
	0x77, 0x67, 0x23, 0x5d, 0xbb, 0x80, 0xef, 0x97, 0x28, 0xbe, 0x85, 0x3a, 0x27, 0x89, 0x94, 0x59,
	0x9f, 0x85, 0xb1, 0x82, 0x11, 0xc1, 0xdd, 0x46, 0xdf, 0x19, 0xd4, 0x46, 0x2f, 0xa7, 0x92, 0xd5,
	0xb2, 0xb7, 0x77, 0x94, 0x48, 0x39, 0x2b, 0xf1, 0xc9, 0x78, 0xba, 0x77, 0xf2, 0x5c, 0x80, 0x1f,
	0xfc, 0xb4, 0x85, 0x9a, 0x33, 0x1a, 0xc6, 0x12, 0x74, 0xd6, 0xc4, 0x23, 0xd4, 0xc8, 0xbb, 0x00,
	0xc6, 0x75, 0xfa, 0xd5, 0x41, 0xf3, 0xaf, 0x3b, 0x98, 0xea, 0xd6, 0x35, 0x29, 0xb4, 0xf8, 0x2b,
	0xd4, 0x11, 0xd1, 0x77, 0xa0, 0x2d, 0x70, 0xb2, 0x36, 0xac, 0xfd, 0x63, 0xc3, 0x76, 0x69, 0x32,
	0x2b, 0x8d, 0x5f, 0x47, 0x4d, 0x93, 0xfd, 0x5e, 0x62, 0xc4, 0x23, 0x70, 0xb7, 0x36, 0xfa, 0x87,
	0x72, 0x60, 0x26, 0x1e, 0x01, 0xbe, 0x81, 0xf6, 0x42, 0x11, 0x91, 0x4d, 0x6a, 0x7d, 0x83, 0xda,
	0x0a, 0x45, 0x34, 0x7b, 0xc6, 0x7e, 0x17, 0x75, 0xd2, 0x4b, 0x71, 0xa2, 0x29, 0xb3, 0x42, 0x45,
	0x44, 0x70, 0x09, 0xd9, 0x95, 0x72, 0x0a, 0xfe, 0x5e, 0x48, 0x17, 0x47, 0x05, 0x3a, 0xe1, 0x12,
	0x0e, 0x7e, 0xab, 0xa3, 0xfd, 0xdc, 0xe0, 0xe3, 0x20, 0xd0, 0x10, 0x50, 0xab, 0xfe, 0x83, 0x02,
	0x36, 0xfe, 0xd7, 0x02, 0xee, 0x5e, 0x5d, 0xc0, 0x1f, 0x1c, 0x84, 0x73, 0x2a, 0x27, 0xf9, 0xa0,
	0x12, 0xc1, 0x8d, 0x5b, 0x4d, 0x47, 0x77, 0xf4, 0xf5, 0x6a, 0xd9, 0x6b, 0xe7, 0x64, 0x7e, 0x2b,
	0x03, 0x27, 0x63, 0xf3, 0x74, 0xd9, 0xfb, 0x28, 0x10, 0x76, 0x9e, 0xf8, 0x1e, 0x53, 0xe1, 0x70,
	0xfd, 0x45, 0xdc, 0x7f, 0x76, 0x1e, 0xc6, 0x67, 0xc1, 0xf0, 0xcf, 0xfb, 0xc9, 0x2b, 0x4d, 0xa6,
	0x6d, 0xf3, 0x9c, 0x2b, 0x37, 0x78, 0x8e, 0x1a, 0xf9, 0xf6, 0x13, 0xbc, 0x98, 0xed, 0x7b, 0xc5,
	0x2c, 0xec, 0x3c, 0x48, 0xe3, 0x93, 0xf1, 0xd3, 0x65, 0xef, 0xc3, 0x7f, 0x9b, 0x78, 0x32, 0x9e,
	0xee, 0x64, 0xf6, 0x13, 0x8e, 0xbf, 0x45, 0xdb, 0xa7, 0xca, 0x4f, 0xf3, 0xa4, 0x63, 0x5f, 0x1d,
	0x7d, 0x52, 0xe4, 0xa9, 0xdf, 0x55, 0x7e, 0x96, 0xe5, 0xfd, 0xbf, 0x95, 0xe5, 0x54, 0xf9, 0x26,
	0x7b, 0xc4, 0xbe, 0x97, 0x29, 0xa7, 0xf5, 0x53, 0xe5, 0x4f, 0x38, 0x7e, 0x13, 0xb5, 0xb4, 0xfa,
	0xde, 0x10, 0x58, 0xc4, 0xc0, 0x2c, 0xf0, 0x6c, 0x1b, 0xd4, 0x8a, 0xf2, 0xbf, 0x90, 0x42, 0xb7,
	0x0b, 0x04, 0x1f, 0x22, 0xcc, 0x41, 0x82, 0x05, 0xa2, 0xec, 0x1c, 0x74, 0xbe, 0xf9, 0x5d, 0xb4,
	0xb1, 0x12, 0xdb, 0x39, 0xfe, 0x79, 0x0a, 0xa7, 0xe3, 0x6f, 0xf0, 0xdb, 0xe8, 0x5a, 0x62, 0x44,
	0x14, 0x10, 0x58, 0x58, 0x0d, 0x21, 0x18, 0xb7, 0xb9, 0xc1, 0x6f, 0x65, 0xd8, 0xed, 0x02, 0xba,
	0x5b, 0x6b, 0xd4, 0xdb, 0xdb, 0x6f, 0x1d, 0x94, 0xeb, 0x3e, 0xdb, 0xd0, 0xfb, 0xa8, 0x7d, 0xe7,
	0xf8, 0x98, 0xdc, 0x3f, 0xfe, 0x62, 0x96, 0x3f, 0xbe, 0xbc, 0xd9, 0xae, 0x8c, 0xde, 0xb9, 0xf8,
	0xb5, 0x5b, 0xb9, 0x58, 0x75, 0x9d, 0xc7, 0xab, 0xae, 0xf3, 0x64, 0xd5, 0x75, 0x7e, 0x59, 0x75,
	0x9d, 0x1f, 0x2f, 0xbb, 0x95, 0xc7, 0x97, 0xdd, 0xca, 0x93, 0xcb, 0x6e, 0xe5, 0x9b, 0xe6, 0xc6,
	0x9f, 0xd6, 0xef, 0x01, 0x00, 0x00, 0xff, 0xff, 0x7f, 0xd2, 0x33, 0xd7, 0xc6, 0x06, 0x00, 0x00,
}

func (m *SketchSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SketchSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SketchSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsTableStats(dAtA, i, uint64(m.FullStatisticID))
	i--
	dAtA[i] = 0x40
	i -= len(m.PartialPredicate)
	copy(dAtA[i:], m.PartialPredicate)
	i = encodeVarintProcessorsTableStats(dAtA, i, uint64(len(m.PartialPredicate)))
	i--
	dAtA[i] = 0x3a
	if m.Index != nil {
		{
			size, err := m.Index.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProcessorsTableStats(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	i -= len(m.StatName)
	copy(dAtA[i:], m.StatName)
	i = encodeVarintProcessorsTableStats(dAtA, i, uint64(len(m.StatName)))
	i--
	dAtA[i] = 0x2a
	i = encodeVarintProcessorsTableStats(dAtA, i, uint64(m.HistogramMaxBuckets))
	i--
	dAtA[i] = 0x20
	i--
	if m.GenerateHistogram {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintProcessorsTableStats(dAtA, i, uint64(m.Columns[iNdEx]))
			i--
			dAtA[i] = 0x10
		}
	}
	i = encodeVarintProcessorsTableStats(dAtA, i, uint64(m.SketchType))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *SamplerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SamplerSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SamplerSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintProcessorsTableStats(dAtA, i, uint64(m.MinSampleSize))
	i--
	dAtA[i] = 0x28
	if len(m.InvertedSketches) > 0 {
		for iNdEx := len(m.InvertedSketches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InvertedSketches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsTableStats(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MaxFractionIdle))))
	i--
	dAtA[i] = 0x19
	i = encodeVarintProcessorsTableStats(dAtA, i, uint64(m.SampleSize))
	i--
	dAtA[i] = 0x10
	if len(m.Sketches) > 0 {
		for iNdEx := len(m.Sketches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sketches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsTableStats(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SampleAggregatorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SampleAggregatorSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SampleAggregatorSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.UsingExtremes {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x58
	i--
	if m.DeleteOtherStats {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x50
	i = encodeVarintProcessorsTableStats(dAtA, i, uint64(m.MinSampleSize))
	i--
	dAtA[i] = 0x48
	if len(m.InvertedSketches) > 0 {
		for iNdEx := len(m.InvertedSketches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InvertedSketches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsTableStats(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	i = encodeVarintProcessorsTableStats(dAtA, i, uint64(m.RowsExpected))
	i--
	dAtA[i] = 0x38
	i = encodeVarintProcessorsTableStats(dAtA, i, uint64(m.JobID))
	i--
	dAtA[i] = 0x30
	i = encodeVarintProcessorsTableStats(dAtA, i, uint64(m.TableID))
	i--
	dAtA[i] = 0x20
	if len(m.SampledColumnIDs) > 0 {
		for iNdEx := len(m.SampledColumnIDs) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintProcessorsTableStats(dAtA, i, uint64(m.SampledColumnIDs[iNdEx]))
			i--
			dAtA[i] = 0x18
		}
	}
	i = encodeVarintProcessorsTableStats(dAtA, i, uint64(m.SampleSize))
	i--
	dAtA[i] = 0x10
	if len(m.Sketches) > 0 {
		for iNdEx := len(m.Sketches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sketches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProcessorsTableStats(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintProcessorsTableStats(dAtA []byte, offset int, v uint64) int {
	offset -= sovProcessorsTableStats(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SketchSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProcessorsTableStats(uint64(m.SketchType))
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			n += 1 + sovProcessorsTableStats(uint64(e))
		}
	}
	n += 2
	n += 1 + sovProcessorsTableStats(uint64(m.HistogramMaxBuckets))
	l = len(m.StatName)
	n += 1 + l + sovProcessorsTableStats(uint64(l))
	if m.Index != nil {
		l = m.Index.Size()
		n += 1 + l + sovProcessorsTableStats(uint64(l))
	}
	l = len(m.PartialPredicate)
	n += 1 + l + sovProcessorsTableStats(uint64(l))
	n += 1 + sovProcessorsTableStats(uint64(m.FullStatisticID))
	return n
}

func (m *SamplerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sketches) > 0 {
		for _, e := range m.Sketches {
			l = e.Size()
			n += 1 + l + sovProcessorsTableStats(uint64(l))
		}
	}
	n += 1 + sovProcessorsTableStats(uint64(m.SampleSize))
	n += 9
	if len(m.InvertedSketches) > 0 {
		for _, e := range m.InvertedSketches {
			l = e.Size()
			n += 1 + l + sovProcessorsTableStats(uint64(l))
		}
	}
	n += 1 + sovProcessorsTableStats(uint64(m.MinSampleSize))
	return n
}

func (m *SampleAggregatorSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sketches) > 0 {
		for _, e := range m.Sketches {
			l = e.Size()
			n += 1 + l + sovProcessorsTableStats(uint64(l))
		}
	}
	n += 1 + sovProcessorsTableStats(uint64(m.SampleSize))
	if len(m.SampledColumnIDs) > 0 {
		for _, e := range m.SampledColumnIDs {
			n += 1 + sovProcessorsTableStats(uint64(e))
		}
	}
	n += 1 + sovProcessorsTableStats(uint64(m.TableID))
	n += 1 + sovProcessorsTableStats(uint64(m.JobID))
	n += 1 + sovProcessorsTableStats(uint64(m.RowsExpected))
	if len(m.InvertedSketches) > 0 {
		for _, e := range m.InvertedSketches {
			l = e.Size()
			n += 1 + l + sovProcessorsTableStats(uint64(l))
		}
	}
	n += 1 + sovProcessorsTableStats(uint64(m.MinSampleSize))
	n += 2
	n += 2
	return n
}

func sovProcessorsTableStats(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProcessorsTableStats(x uint64) (n int) {
	return sovProcessorsTableStats(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SketchSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsTableStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SketchSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SketchSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SketchType", wireType)
			}
			m.SketchType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SketchType |= SketchType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsTableStats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Columns = append(m.Columns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsTableStats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsTableStats
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsTableStats
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Columns) == 0 {
					m.Columns = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsTableStats
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Columns = append(m.Columns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerateHistogram", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GenerateHistogram = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistogramMaxBuckets", wireType)
			}
			m.HistogramMaxBuckets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HistogramMaxBuckets |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Index == nil {
				m.Index = &descpb.IndexDescriptor{}
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialPredicate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartialPredicate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullStatisticID", wireType)
			}
			m.FullStatisticID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FullStatisticID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsTableStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SamplerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsTableStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SamplerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SamplerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sketches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sketches = append(m.Sketches, SketchSpec{})
			if err := m.Sketches[len(m.Sketches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleSize", wireType)
			}
			m.SampleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFractionIdle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MaxFractionIdle = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertedSketches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvertedSketches = append(m.InvertedSketches, SketchSpec{})
			if err := m.InvertedSketches[len(m.InvertedSketches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSampleSize", wireType)
			}
			m.MinSampleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinSampleSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsTableStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SampleAggregatorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProcessorsTableStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SampleAggregatorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SampleAggregatorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sketches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sketches = append(m.Sketches, SketchSpec{})
			if err := m.Sketches[len(m.Sketches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleSize", wireType)
			}
			m.SampleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsTableStats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SampledColumnIDs = append(m.SampledColumnIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProcessorsTableStats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthProcessorsTableStats
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthProcessorsTableStats
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SampledColumnIDs) == 0 {
					m.SampledColumnIDs = make([]github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProcessorsTableStats
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ColumnID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SampledColumnIDs = append(m.SampledColumnIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SampledColumnIDs", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_catalog_descpb.ID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			m.JobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobID |= github_com_cockroachdb_cockroach_pkg_jobs_jobspb.JobID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsExpected", wireType)
			}
			m.RowsExpected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RowsExpected |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertedSketches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvertedSketches = append(m.InvertedSketches, SketchSpec{})
			if err := m.InvertedSketches[len(m.InvertedSketches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSampleSize", wireType)
			}
			m.MinSampleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinSampleSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteOtherStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeleteOtherStats = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsingExtremes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsingExtremes = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProcessorsTableStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProcessorsTableStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProcessorsTableStats(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProcessorsTableStats
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProcessorsTableStats
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProcessorsTableStats
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProcessorsTableStats
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProcessorsTableStats
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProcessorsTableStats        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProcessorsTableStats          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProcessorsTableStats = fmt.Errorf("proto: unexpected end of group")
)
