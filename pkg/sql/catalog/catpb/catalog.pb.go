// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/catalog/catpb/catalog.proto

package catpb

import (
	bytes "bytes"
	fmt "fmt"
	github_com_cockroachdb_cockroach_pkg_sql_sem_catid "github.com/cockroachdb/cockroach/pkg/sql/sem/catid"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ForeignKeyAction describes the action which should be taken when a foreign
// key constraint reference is acted upon.
type ForeignKeyAction int32

const (
	ForeignKeyAction_NO_ACTION   ForeignKeyAction = 0
	ForeignKeyAction_RESTRICT    ForeignKeyAction = 1
	ForeignKeyAction_SET_NULL    ForeignKeyAction = 2
	ForeignKeyAction_SET_DEFAULT ForeignKeyAction = 3
	ForeignKeyAction_CASCADE     ForeignKeyAction = 4
)

var ForeignKeyAction_name = map[int32]string{
	0: "NO_ACTION",
	1: "RESTRICT",
	2: "SET_NULL",
	3: "SET_DEFAULT",
	4: "CASCADE",
}

var ForeignKeyAction_value = map[string]int32{
	"NO_ACTION":   0,
	"RESTRICT":    1,
	"SET_NULL":    2,
	"SET_DEFAULT": 3,
	"CASCADE":     4,
}

func (x ForeignKeyAction) Enum() *ForeignKeyAction {
	p := new(ForeignKeyAction)
	*p = x
	return p
}

func (x ForeignKeyAction) MarshalJSON() ([]byte, error) {
	return proto.MarshalJSONEnum(ForeignKeyAction_name, int32(x))
}

func (x *ForeignKeyAction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ForeignKeyAction_value, data, "ForeignKeyAction")
	if err != nil {
		return err
	}
	*x = ForeignKeyAction(value)
	return nil
}

func (ForeignKeyAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{0}
}

// SystemColumnKind is an enum representing the different kind of system
// columns that can be synthesized by the execution engine.
type SystemColumnKind int32

const (
	// Default value, unused.
	SystemColumnKind_NONE SystemColumnKind = 0
	// A system column containing the value of the MVCC timestamp associated
	// with the kv's corresponding to the row.
	SystemColumnKind_MVCCTIMESTAMP SystemColumnKind = 1
	// A system column containing the OID of the table that the row came from.
	SystemColumnKind_TABLEOID SystemColumnKind = 2
)

var SystemColumnKind_name = map[int32]string{
	0: "NONE",
	1: "MVCCTIMESTAMP",
	2: "TABLEOID",
}

var SystemColumnKind_value = map[string]int32{
	"NONE":          0,
	"MVCCTIMESTAMP": 1,
	"TABLEOID":      2,
}

func (x SystemColumnKind) Enum() *SystemColumnKind {
	p := new(SystemColumnKind)
	*p = x
	return p
}

func (x SystemColumnKind) String() string {
	return proto.EnumName(SystemColumnKind_name, int32(x))
}

func (x *SystemColumnKind) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SystemColumnKind_value, data, "SystemColumnKind")
	if err != nil {
		return err
	}
	*x = SystemColumnKind(value)
	return nil
}

func (SystemColumnKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{1}
}

// GeneratedAsIdentityType is an enum representing how the creation of
// a column is associated with the GENERATED {ALWAYS | BY DEFAULT} AS IDENTITY
// syntax.
type GeneratedAsIdentityType int32

const (
	// A column created without `GENERATED ... AS IDENTITY` syntax.
	GeneratedAsIdentityType_NOT_IDENTITY_COLUMN GeneratedAsIdentityType = 0
	// A column created with `GENERATED ALWAYS AS IDENTITY` syntax.
	// Such a column does not allow override without `OVERRIDING SYSTEM VALUE`
	// syntax.
	GeneratedAsIdentityType_GENERATED_ALWAYS GeneratedAsIdentityType = 1
	// A column created with `GENERATED BY DEFAULT AS IDENTITY` syntax.
	// Such a column can be overridden without `OVERRIDING SYSTEM VALUE` syntax.
	GeneratedAsIdentityType_GENERATED_BY_DEFAULT GeneratedAsIdentityType = 2
)

var GeneratedAsIdentityType_name = map[int32]string{
	0: "NOT_IDENTITY_COLUMN",
	1: "GENERATED_ALWAYS",
	2: "GENERATED_BY_DEFAULT",
}

var GeneratedAsIdentityType_value = map[string]int32{
	"NOT_IDENTITY_COLUMN":  0,
	"GENERATED_ALWAYS":     1,
	"GENERATED_BY_DEFAULT": 2,
}

func (x GeneratedAsIdentityType) Enum() *GeneratedAsIdentityType {
	p := new(GeneratedAsIdentityType)
	*p = x
	return p
}

func (x GeneratedAsIdentityType) String() string {
	return proto.EnumName(GeneratedAsIdentityType_name, int32(x))
}

func (x *GeneratedAsIdentityType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GeneratedAsIdentityType_value, data, "GeneratedAsIdentityType")
	if err != nil {
		return err
	}
	*x = GeneratedAsIdentityType(value)
	return nil
}

func (GeneratedAsIdentityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{2}
}

// LocalityConfig is used to figure the locality of a table.
type LocalityConfig struct {
	// Types that are valid to be assigned to Locality:
	//	*LocalityConfig_Global_
	//	*LocalityConfig_RegionalByTable_
	//	*LocalityConfig_RegionalByRow_
	Locality isLocalityConfig_Locality `protobuf_oneof:"locality"`
}

func (m *LocalityConfig) Reset()         { *m = LocalityConfig{} }
func (m *LocalityConfig) String() string { return proto.CompactTextString(m) }
func (*LocalityConfig) ProtoMessage()    {}
func (*LocalityConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{0}
}
func (m *LocalityConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalityConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LocalityConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalityConfig.Merge(m, src)
}
func (m *LocalityConfig) XXX_Size() int {
	return m.Size()
}
func (m *LocalityConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalityConfig.DiscardUnknown(m)
}

var xxx_messageInfo_LocalityConfig proto.InternalMessageInfo

type isLocalityConfig_Locality interface {
	isLocalityConfig_Locality()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LocalityConfig_Global_ struct {
	Global *LocalityConfig_Global `protobuf:"bytes,1,opt,name=global,oneof" json:"global,omitempty"`
}
type LocalityConfig_RegionalByTable_ struct {
	RegionalByTable *LocalityConfig_RegionalByTable `protobuf:"bytes,2,opt,name=regional_by_table,json=regionalByTable,oneof" json:"regional_by_table,omitempty"`
}
type LocalityConfig_RegionalByRow_ struct {
	RegionalByRow *LocalityConfig_RegionalByRow `protobuf:"bytes,3,opt,name=regional_by_row,json=regionalByRow,oneof" json:"regional_by_row,omitempty"`
}

func (*LocalityConfig_Global_) isLocalityConfig_Locality()          {}
func (*LocalityConfig_RegionalByTable_) isLocalityConfig_Locality() {}
func (*LocalityConfig_RegionalByRow_) isLocalityConfig_Locality()   {}

func (m *LocalityConfig) GetLocality() isLocalityConfig_Locality {
	if m != nil {
		return m.Locality
	}
	return nil
}

func (m *LocalityConfig) GetGlobal() *LocalityConfig_Global {
	if x, ok := m.GetLocality().(*LocalityConfig_Global_); ok {
		return x.Global
	}
	return nil
}

func (m *LocalityConfig) GetRegionalByTable() *LocalityConfig_RegionalByTable {
	if x, ok := m.GetLocality().(*LocalityConfig_RegionalByTable_); ok {
		return x.RegionalByTable
	}
	return nil
}

func (m *LocalityConfig) GetRegionalByRow() *LocalityConfig_RegionalByRow {
	if x, ok := m.GetLocality().(*LocalityConfig_RegionalByRow_); ok {
		return x.RegionalByRow
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LocalityConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LocalityConfig_Global_)(nil),
		(*LocalityConfig_RegionalByTable_)(nil),
		(*LocalityConfig_RegionalByRow_)(nil),
	}
}

// REGIONAL BY TABLE tables have an "implicit" bidirectional dependency with
// the multi-region enum. The dependency is described "implicit" because
// even though no column on the table uses the multi-region type descriptor
// to store the homing region, a value from the type descriptor is stored in
// the locality config below (when the table is homed in the non-primary
// region).
// This changes how type dependencies are constructed for table descriptors.
// After the introduction of REGIONAL BY TABLE tables, a column on the table
// descriptor using a type is no longer a necessary (note it is still a
// sufficient) condition to establish a type dependency. As is the case with
// adding and dropping columns, this type dependency must be negotiated. As
// such, switching locality patterns or adding new locality configs must be
// done so that back references to the multi-region type descriptor are
// kept sane.
type LocalityConfig_RegionalByTable struct {
	// Region is set if the table has an affinity with a non-primary region.
	Region *RegionName `protobuf:"bytes,1,opt,name=region,casttype=RegionName" json:"region,omitempty"`
}

func (m *LocalityConfig_RegionalByTable) Reset()         { *m = LocalityConfig_RegionalByTable{} }
func (m *LocalityConfig_RegionalByTable) String() string { return proto.CompactTextString(m) }
func (*LocalityConfig_RegionalByTable) ProtoMessage()    {}
func (*LocalityConfig_RegionalByTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{0, 0}
}
func (m *LocalityConfig_RegionalByTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalityConfig_RegionalByTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LocalityConfig_RegionalByTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalityConfig_RegionalByTable.Merge(m, src)
}
func (m *LocalityConfig_RegionalByTable) XXX_Size() int {
	return m.Size()
}
func (m *LocalityConfig_RegionalByTable) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalityConfig_RegionalByTable.DiscardUnknown(m)
}

var xxx_messageInfo_LocalityConfig_RegionalByTable proto.InternalMessageInfo

type LocalityConfig_RegionalByRow struct {
	// As is set if the table has a REGIONAL BY ROW AS ... set to a specific column.
	As *string `protobuf:"bytes,1,opt,name=as" json:"as,omitempty"`
}

func (m *LocalityConfig_RegionalByRow) Reset()         { *m = LocalityConfig_RegionalByRow{} }
func (m *LocalityConfig_RegionalByRow) String() string { return proto.CompactTextString(m) }
func (*LocalityConfig_RegionalByRow) ProtoMessage()    {}
func (*LocalityConfig_RegionalByRow) Descriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{0, 1}
}
func (m *LocalityConfig_RegionalByRow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalityConfig_RegionalByRow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LocalityConfig_RegionalByRow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalityConfig_RegionalByRow.Merge(m, src)
}
func (m *LocalityConfig_RegionalByRow) XXX_Size() int {
	return m.Size()
}
func (m *LocalityConfig_RegionalByRow) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalityConfig_RegionalByRow.DiscardUnknown(m)
}

var xxx_messageInfo_LocalityConfig_RegionalByRow proto.InternalMessageInfo

type LocalityConfig_Global struct {
}

func (m *LocalityConfig_Global) Reset()         { *m = LocalityConfig_Global{} }
func (m *LocalityConfig_Global) String() string { return proto.CompactTextString(m) }
func (*LocalityConfig_Global) ProtoMessage()    {}
func (*LocalityConfig_Global) Descriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{0, 2}
}
func (m *LocalityConfig_Global) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalityConfig_Global) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LocalityConfig_Global) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalityConfig_Global.Merge(m, src)
}
func (m *LocalityConfig_Global) XXX_Size() int {
	return m.Size()
}
func (m *LocalityConfig_Global) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalityConfig_Global.DiscardUnknown(m)
}

var xxx_messageInfo_LocalityConfig_Global proto.InternalMessageInfo

// ShardedDescriptor represents an index (either primary or secondary) that is hash
// sharded into a user-specified number of buckets.
//
// As as example, sample field values for the following table:
//
// CREATE TABLE abc (
//   a INT PRIMARY KEY USING HASH WITH (bucket_count=10),  // column id: 1
//   b BYTES
// );
//
// Sharded descriptor:
//   name:          "a_shard"
//   shard_buckets: 10
//   column_names:  ["a"]
type ShardedDescriptor struct {
	// IsSharded indicates whether the index in question is a sharded one.
	IsSharded bool `protobuf:"varint,1,opt,name=is_sharded,json=isSharded" json:"is_sharded"`
	// Name is the name of the shard column.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name"`
	// ShardBuckets indicates the number of shards this index is divided into.
	ShardBuckets int32 `protobuf:"varint,3,opt,name=shard_buckets,json=shardBuckets" json:"shard_buckets"`
	// ColumnNames lists the names of the columns used to compute the shard column's
	// values.
	ColumnNames []string `protobuf:"bytes,4,rep,name=column_names,json=columnNames" json:"column_names,omitempty"`
}

func (m *ShardedDescriptor) Reset()         { *m = ShardedDescriptor{} }
func (m *ShardedDescriptor) String() string { return proto.CompactTextString(m) }
func (*ShardedDescriptor) ProtoMessage()    {}
func (*ShardedDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{1}
}
func (m *ShardedDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardedDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ShardedDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardedDescriptor.Merge(m, src)
}
func (m *ShardedDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *ShardedDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardedDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_ShardedDescriptor proto.InternalMessageInfo

// ScheduledRowLevelTTLArgs represents the arguments for a row-level TTL
// scheduled job.
type ScheduledRowLevelTTLArgs struct {
	TableID github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID `protobuf:"varint,1,opt,name=table_id,json=tableId,casttype=github.com/cockroachdb/cockroach/pkg/sql/sem/catid.DescID" json:"table_id"`
}

func (m *ScheduledRowLevelTTLArgs) Reset()         { *m = ScheduledRowLevelTTLArgs{} }
func (m *ScheduledRowLevelTTLArgs) String() string { return proto.CompactTextString(m) }
func (*ScheduledRowLevelTTLArgs) ProtoMessage()    {}
func (*ScheduledRowLevelTTLArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{2}
}
func (m *ScheduledRowLevelTTLArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduledRowLevelTTLArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ScheduledRowLevelTTLArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduledRowLevelTTLArgs.Merge(m, src)
}
func (m *ScheduledRowLevelTTLArgs) XXX_Size() int {
	return m.Size()
}
func (m *ScheduledRowLevelTTLArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduledRowLevelTTLArgs.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduledRowLevelTTLArgs proto.InternalMessageInfo

// PartitioningDescriptor represents the partitioning of an index into spans
// of keys addressable by a zone config. The key encoding is unchanged. Each
// partition may optionally be itself divided into further partitions, called
// subpartitions.
type PartitioningDescriptor struct {
	// NumColumns is how large of a prefix of the columns in an index are used in
	// the function mapping column values to partitions. If this is a
	// subpartition, this is offset to start from the end of the parent
	// partition's columns. If NumColumns is 0, then there is no partitioning.
	NumColumns uint32 `protobuf:"varint,1,opt,name=num_columns,json=numColumns" json:"num_columns"`
	// NumImplicitColumns specifies the number of columns that implicitly prefix a given index.
	// This occurs if a user specifies a PARTITION BY which is not a prefix of the given index,
	// in which case the ColumnIDs are added in front of the index and this field denotes
	// the number of columns added as a prefix.
	// If NumImplicitColumns is 0, there are no implicit columns defined for the index."
	NumImplicitColumns uint32 `protobuf:"varint,4,opt,name=num_implicit_columns,json=numImplicitColumns" json:"num_implicit_columns"`
	// Exactly one of List or Range is required to be non-empty if NumColumns is
	// non-zero.
	List  []PartitioningDescriptor_List  `protobuf:"bytes,2,rep,name=list" json:"list"`
	Range []PartitioningDescriptor_Range `protobuf:"bytes,3,rep,name=range" json:"range"`
}

func (m *PartitioningDescriptor) Reset()         { *m = PartitioningDescriptor{} }
func (m *PartitioningDescriptor) String() string { return proto.CompactTextString(m) }
func (*PartitioningDescriptor) ProtoMessage()    {}
func (*PartitioningDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{3}
}
func (m *PartitioningDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitioningDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PartitioningDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitioningDescriptor.Merge(m, src)
}
func (m *PartitioningDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *PartitioningDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitioningDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_PartitioningDescriptor proto.InternalMessageInfo

// List represents a list partitioning, which maps individual tuples to
// partitions.
type PartitioningDescriptor_List struct {
	// Name is the partition name.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	// Values is an unordered set of the tuples included in this partition. Each
	// tuple is encoded with the EncDatum value encoding. DEFAULT is encoded as
	// NOT NULL followed by PartitionDefaultVal encoded as a non-sorting
	// uvarint.
	Values [][]byte `protobuf:"bytes,2,rep,name=values" json:"values,omitempty"`
	// Subpartitioning represents a further partitioning of this list partition.
	Subpartitioning PartitioningDescriptor `protobuf:"bytes,3,opt,name=subpartitioning" json:"subpartitioning"`
}

func (m *PartitioningDescriptor_List) Reset()         { *m = PartitioningDescriptor_List{} }
func (m *PartitioningDescriptor_List) String() string { return proto.CompactTextString(m) }
func (*PartitioningDescriptor_List) ProtoMessage()    {}
func (*PartitioningDescriptor_List) Descriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{3, 0}
}
func (m *PartitioningDescriptor_List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitioningDescriptor_List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PartitioningDescriptor_List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitioningDescriptor_List.Merge(m, src)
}
func (m *PartitioningDescriptor_List) XXX_Size() int {
	return m.Size()
}
func (m *PartitioningDescriptor_List) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitioningDescriptor_List.DiscardUnknown(m)
}

var xxx_messageInfo_PartitioningDescriptor_List proto.InternalMessageInfo

// Range represents a range partitioning, which maps ranges of tuples to
// partitions by specifying exclusive upper bounds. The range partitions in a
// PartitioningDescriptor are required to be sorted by UpperBound.
type PartitioningDescriptor_Range struct {
	// Name is the partition name.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	// FromInclusive is the inclusive lower bound of this range partition. It is
	// encoded with the EncDatum value encoding. MINVALUE and MAXVALUE are
	// encoded as NOT NULL followed by a PartitionSpecialValCode encoded as a
	// non-sorting uvarint.
	FromInclusive []byte `protobuf:"bytes,3,opt,name=from_inclusive,json=fromInclusive" json:"from_inclusive,omitempty"`
	// ToExclusive is the exclusive upper bound of this range partition. It is
	// encoded in the same way as From.
	ToExclusive []byte `protobuf:"bytes,2,opt,name=to_exclusive,json=toExclusive" json:"to_exclusive,omitempty"`
}

func (m *PartitioningDescriptor_Range) Reset()         { *m = PartitioningDescriptor_Range{} }
func (m *PartitioningDescriptor_Range) String() string { return proto.CompactTextString(m) }
func (*PartitioningDescriptor_Range) ProtoMessage()    {}
func (*PartitioningDescriptor_Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{3, 1}
}
func (m *PartitioningDescriptor_Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitioningDescriptor_Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PartitioningDescriptor_Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitioningDescriptor_Range.Merge(m, src)
}
func (m *PartitioningDescriptor_Range) XXX_Size() int {
	return m.Size()
}
func (m *PartitioningDescriptor_Range) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitioningDescriptor_Range.DiscardUnknown(m)
}

var xxx_messageInfo_PartitioningDescriptor_Range proto.InternalMessageInfo

// RowLevelTTL represents the TTL configured on a table.
type RowLevelTTL struct {
	// DurationExpr is the automatically assigned interval for when the TTL should apply to a row.
	DurationExpr string `protobuf:"bytes,1,opt,name=duration_expr,json=durationExpr" json:"duration_expr"`
	// SelectBatchSize is the amount of rows that should be fetched at a time
	SelectBatchSize int64 `protobuf:"varint,2,opt,name=select_batch_size,json=selectBatchSize" json:"select_batch_size"`
	// DeleteBatchSize is the amount of rows that should be deleted at a time.
	DeleteBatchSize int64 `protobuf:"varint,3,opt,name=delete_batch_size,json=deleteBatchSize" json:"delete_batch_size"`
	// DeletionCron signifies how often the TTL deletion job runs in a cron format.
	DeletionCron string `protobuf:"bytes,4,opt,name=deletion_cron,json=deletionCron" json:"deletion_cron"`
	// ScheduleID is the ID of the row-level TTL job schedules.
	ScheduleID int64 `protobuf:"varint,5,opt,name=schedule_id,json=scheduleId" json:"schedule_id"`
}

func (m *RowLevelTTL) Reset()         { *m = RowLevelTTL{} }
func (m *RowLevelTTL) String() string { return proto.CompactTextString(m) }
func (*RowLevelTTL) ProtoMessage()    {}
func (*RowLevelTTL) Descriptor() ([]byte, []int) {
	return fileDescriptor_98c5e4146b266e21, []int{4}
}
func (m *RowLevelTTL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowLevelTTL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RowLevelTTL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowLevelTTL.Merge(m, src)
}
func (m *RowLevelTTL) XXX_Size() int {
	return m.Size()
}
func (m *RowLevelTTL) XXX_DiscardUnknown() {
	xxx_messageInfo_RowLevelTTL.DiscardUnknown(m)
}

var xxx_messageInfo_RowLevelTTL proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("cockroach.sql.catalog.catpb.ForeignKeyAction", ForeignKeyAction_name, ForeignKeyAction_value)
	proto.RegisterEnum("cockroach.sql.catalog.catpb.SystemColumnKind", SystemColumnKind_name, SystemColumnKind_value)
	proto.RegisterEnum("cockroach.sql.catalog.catpb.GeneratedAsIdentityType", GeneratedAsIdentityType_name, GeneratedAsIdentityType_value)
	proto.RegisterType((*LocalityConfig)(nil), "cockroach.sql.catalog.catpb.LocalityConfig")
	proto.RegisterType((*LocalityConfig_RegionalByTable)(nil), "cockroach.sql.catalog.catpb.LocalityConfig.RegionalByTable")
	proto.RegisterType((*LocalityConfig_RegionalByRow)(nil), "cockroach.sql.catalog.catpb.LocalityConfig.RegionalByRow")
	proto.RegisterType((*LocalityConfig_Global)(nil), "cockroach.sql.catalog.catpb.LocalityConfig.Global")
	proto.RegisterType((*ShardedDescriptor)(nil), "cockroach.sql.catalog.catpb.ShardedDescriptor")
	proto.RegisterType((*ScheduledRowLevelTTLArgs)(nil), "cockroach.sql.catalog.catpb.ScheduledRowLevelTTLArgs")
	proto.RegisterType((*PartitioningDescriptor)(nil), "cockroach.sql.catalog.catpb.PartitioningDescriptor")
	proto.RegisterType((*PartitioningDescriptor_List)(nil), "cockroach.sql.catalog.catpb.PartitioningDescriptor.List")
	proto.RegisterType((*PartitioningDescriptor_Range)(nil), "cockroach.sql.catalog.catpb.PartitioningDescriptor.Range")
	proto.RegisterType((*RowLevelTTL)(nil), "cockroach.sql.catalog.catpb.RowLevelTTL")
}

func init() { proto.RegisterFile("sql/catalog/catpb/catalog.proto", fileDescriptor_98c5e4146b266e21) }

var fileDescriptor_98c5e4146b266e21 = []byte{
	// 1031 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x53, 0x41, 0x4f, 0xe3, 0x56,
	0x10, 0xb6, 0x13, 0xc3, 0xc2, 0x24, 0x01, 0xf3, 0x8a, 0x76, 0x23, 0x2a, 0x25, 0x94, 0x8a, 0x96,
	0x72, 0x08, 0x15, 0x2b, 0x55, 0xa5, 0x55, 0x55, 0xd9, 0x89, 0x17, 0xac, 0x35, 0xc9, 0xca, 0x31,
	0xad, 0xe8, 0xc5, 0x72, 0xec, 0xb7, 0xe6, 0x09, 0xc7, 0x2f, 0xf8, 0xd9, 0x40, 0xf6, 0xd8, 0xfe,
	0x81, 0xfe, 0x84, 0x4a, 0xed, 0xa1, 0xbf, 0xa0, 0xea, 0xb5, 0x37, 0x8e, 0x7b, 0xdc, 0x13, 0x6a,
	0xe1, 0xd2, 0xdf, 0xb0, 0xa7, 0xea, 0x3d, 0x3b, 0x10, 0xb6, 0x15, 0x52, 0xb9, 0x24, 0x9e, 0x99,
	0x6f, 0xbe, 0xf9, 0x3c, 0x9e, 0x0f, 0x9a, 0xec, 0x24, 0xda, 0xf2, 0xbd, 0xd4, 0x8b, 0x68, 0xc8,
	0xff, 0x47, 0x83, 0x49, 0xd4, 0x1a, 0x25, 0x34, 0xa5, 0xe8, 0x7d, 0x9f, 0xfa, 0xc7, 0x09, 0xf5,
	0xfc, 0xa3, 0x16, 0x3b, 0x89, 0x5a, 0x93, 0xa2, 0x80, 0xae, 0x2c, 0x87, 0x34, 0xa4, 0x02, 0xb7,
	0xc5, 0x9f, 0xf2, 0x96, 0xb5, 0xdf, 0xcb, 0xb0, 0x60, 0x51, 0xdf, 0x8b, 0x48, 0x3a, 0x6e, 0xd3,
	0xf8, 0x25, 0x09, 0x91, 0x05, 0xb3, 0x61, 0x44, 0x07, 0x5e, 0x54, 0x97, 0x57, 0xe5, 0x8d, 0xca,
	0xf6, 0x76, 0xeb, 0x1e, 0xda, 0xd6, 0xdd, 0xe6, 0xd6, 0xae, 0xe8, 0xdc, 0x93, 0xec, 0x82, 0x03,
	0x11, 0x58, 0x4a, 0x70, 0x48, 0x68, 0xec, 0x45, 0xee, 0x60, 0xec, 0xa6, 0xde, 0x20, 0xc2, 0xf5,
	0x92, 0x20, 0xfe, 0xf2, 0xff, 0x10, 0xdb, 0x05, 0x89, 0x3e, 0x76, 0x38, 0xc5, 0x9e, 0x64, 0x2f,
	0x26, 0x77, 0x53, 0xc8, 0x87, 0xc5, 0xe9, 0x51, 0x09, 0x3d, 0xab, 0x97, 0xc5, 0xa0, 0x9d, 0x87,
	0x0d, 0xb2, 0xe9, 0xd9, 0x9e, 0x64, 0xd7, 0x92, 0xe9, 0xc4, 0xca, 0xd7, 0xb0, 0xf8, 0x8e, 0x14,
	0xf4, 0x11, 0xcc, 0xe6, 0x18, 0xb1, 0xb0, 0x79, 0x7d, 0xe1, 0xed, 0x65, 0x13, 0x72, 0x50, 0xd7,
	0x1b, 0x62, 0xbb, 0xa8, 0x7e, 0xa1, 0xfc, 0xfd, 0x53, 0x53, 0x5e, 0x59, 0x87, 0xda, 0x9d, 0x11,
	0x68, 0x01, 0x4a, 0x1e, 0xcb, 0x5b, 0xed, 0x92, 0xc7, 0x0a, 0xd8, 0x02, 0xcc, 0xe6, 0xbb, 0xcc,
	0xe3, 0xfc, 0x57, 0x07, 0x98, 0x8b, 0x0a, 0xb9, 0x6b, 0xbf, 0xc9, 0xb0, 0xd4, 0x3f, 0xf2, 0x92,
	0x00, 0x07, 0x1d, 0xcc, 0xfc, 0x84, 0x8c, 0x52, 0x9a, 0xa0, 0x0f, 0x01, 0x08, 0x73, 0x59, 0x9e,
	0x17, 0xac, 0x73, 0xba, 0x72, 0x71, 0xd9, 0x94, 0xec, 0x79, 0xc2, 0x0a, 0x38, 0xaa, 0x83, 0x12,
	0x7b, 0xc3, 0xfc, 0x3b, 0xcc, 0x17, 0x65, 0x91, 0x41, 0x3b, 0x50, 0x13, 0xbd, 0xee, 0x20, 0xf3,
	0x8f, 0x71, 0xca, 0xc4, 0x06, 0x67, 0xf4, 0x65, 0x0e, 0xb9, 0xba, 0x6c, 0x56, 0x05, 0x83, 0x9e,
	0xd7, 0xec, 0x2a, 0x9b, 0x8a, 0xd0, 0x07, 0x50, 0xf5, 0x69, 0x94, 0x0d, 0x63, 0x97, 0x33, 0xb1,
	0xba, 0xb2, 0x5a, 0xde, 0x98, 0xb7, 0x2b, 0x79, 0x8e, 0x2f, 0xa2, 0x78, 0xb5, 0xb5, 0x1f, 0x64,
	0xa8, 0xf7, 0xfd, 0x23, 0x1c, 0x64, 0x11, 0x0e, 0x6c, 0x7a, 0x66, 0xe1, 0x53, 0x1c, 0x39, 0x8e,
	0xa5, 0x25, 0x21, 0x43, 0x21, 0xcc, 0x89, 0x1b, 0x71, 0x49, 0xae, 0xbe, 0xa6, 0x5b, 0xc5, 0xec,
	0x47, 0x62, 0xdb, 0x66, 0xe7, 0xed, 0x65, 0x73, 0x27, 0x24, 0xe9, 0x51, 0x36, 0x68, 0xf9, 0x74,
	0xb8, 0x75, 0xf3, 0x69, 0x83, 0xc1, 0xed, 0xf3, 0xd6, 0xe8, 0x38, 0xdc, 0xe2, 0x76, 0x61, 0x78,
	0xc8, 0x4d, 0x42, 0x82, 0x16, 0xdf, 0x91, 0xd9, 0xb1, 0x1f, 0x09, 0x76, 0x33, 0x58, 0xfb, 0x43,
	0x81, 0xc7, 0x2f, 0xbc, 0x24, 0x25, 0x29, 0xa1, 0x31, 0x89, 0xc3, 0xa9, 0x1d, 0xae, 0x43, 0x25,
	0xce, 0x86, 0x6e, 0xae, 0x9c, 0x15, 0x32, 0xf2, 0x2d, 0x41, 0x9c, 0x0d, 0xdb, 0x79, 0x1e, 0x7d,
	0x06, 0xcb, 0x1c, 0x46, 0x86, 0xa3, 0x88, 0xf8, 0x24, 0xbd, 0xc1, 0x2b, 0x53, 0x78, 0x14, 0x67,
	0x43, 0xb3, 0x00, 0x4c, 0xfa, 0x6c, 0x50, 0x22, 0xc2, 0xd2, 0x7a, 0x69, 0xb5, 0xbc, 0x51, 0xd9,
	0xfe, 0xfc, 0xde, 0xe3, 0xfc, 0x6f, 0x85, 0x2d, 0x8b, 0xb0, 0x74, 0xf2, 0xdd, 0x38, 0x17, 0x3a,
	0x80, 0x99, 0xc4, 0x8b, 0x43, 0x5c, 0x2f, 0x0b, 0xd2, 0x9d, 0x87, 0x90, 0xda, 0x9c, 0xa0, 0x60,
	0xcd, 0xd9, 0x56, 0x7e, 0x96, 0x41, 0xe1, 0xb3, 0x6e, 0x2e, 0x46, 0xfe, 0xd7, 0xc5, 0x3c, 0x86,
	0xd9, 0x53, 0x2f, 0xca, 0x30, 0x13, 0xef, 0x53, 0xb5, 0x8b, 0x88, 0xbb, 0x91, 0x65, 0x83, 0xd1,
	0xd4, 0xa8, 0xc2, 0x8d, 0x4f, 0x1f, 0xa0, 0xad, 0x98, 0xf8, 0x2e, 0x63, 0xe1, 0x95, 0x13, 0x98,
	0x11, 0xda, 0xef, 0x51, 0xb9, 0x0e, 0x0b, 0x2f, 0x13, 0x3a, 0x74, 0x49, 0xec, 0x47, 0x19, 0x23,
	0xa7, 0x58, 0x88, 0xa9, 0xda, 0x35, 0x9e, 0x35, 0x27, 0x49, 0x7e, 0xc3, 0x29, 0x75, 0xf1, 0xf9,
	0x04, 0x54, 0x12, 0xa0, 0x4a, 0x4a, 0x8d, 0x49, 0x6a, 0xda, 0x8e, 0x6b, 0xdf, 0x97, 0xa0, 0x32,
	0x75, 0xc0, 0xe8, 0x13, 0xa8, 0x05, 0x59, 0xe2, 0x71, 0x75, 0x2e, 0x3e, 0x1f, 0x25, 0x77, 0x84,
	0x54, 0x27, 0x25, 0xe3, 0x7c, 0x94, 0xa0, 0x4f, 0x61, 0x89, 0xe1, 0x08, 0xfb, 0xa9, 0x3b, 0xf0,
	0x52, 0xff, 0xc8, 0x65, 0xe4, 0x55, 0x3e, 0xae, 0x7c, 0xf3, 0xae, 0xa2, 0xac, 0xf3, 0x6a, 0x9f,
	0xbc, 0xc2, 0xbc, 0x23, 0xc0, 0x11, 0x4e, 0xf1, 0x74, 0x47, 0x79, 0xba, 0x23, 0x2f, 0xdf, 0x76,
	0x70, 0x39, 0x3c, 0xc5, 0xe5, 0xf8, 0x09, 0x8d, 0xc5, 0x65, 0xde, 0xca, 0x29, 0x4a, 0xed, 0x84,
	0xc6, 0xe8, 0x29, 0x54, 0x58, 0x61, 0x49, 0xee, 0xbc, 0x19, 0x41, 0x8b, 0x0a, 0xe7, 0xc1, 0xc4,
	0xad, 0x66, 0xc7, 0x86, 0x09, 0xcc, 0x0c, 0xf2, 0x25, 0x6c, 0x7a, 0xa0, 0x3e, 0xa3, 0x09, 0x26,
	0x61, 0xfc, 0x1c, 0x8f, 0x35, 0x9f, 0x53, 0xa2, 0x1a, 0xcc, 0x77, 0x7b, 0xae, 0xd6, 0x76, 0xcc,
	0x5e, 0x57, 0x95, 0x50, 0x15, 0xe6, 0x6c, 0xa3, 0xef, 0xd8, 0x66, 0xdb, 0x51, 0x65, 0x1e, 0xf5,
	0x0d, 0xc7, 0xed, 0x1e, 0x58, 0x96, 0x5a, 0x42, 0x8b, 0x50, 0xe1, 0x51, 0xc7, 0x78, 0xa6, 0x1d,
	0x58, 0x8e, 0x5a, 0x46, 0x15, 0x78, 0xd4, 0xd6, 0xfa, 0x6d, 0xad, 0x63, 0xa8, 0xca, 0x8a, 0xf2,
	0xeb, 0x2f, 0x0d, 0x69, 0xf3, 0x2b, 0x50, 0xfb, 0x63, 0x96, 0xe2, 0xc2, 0x7a, 0xcf, 0x49, 0x1c,
	0xa0, 0x39, 0x50, 0xba, 0xbd, 0xae, 0xa1, 0x4a, 0x68, 0x09, 0x6a, 0xfb, 0xdf, 0xb4, 0xdb, 0x8e,
	0xb9, 0x6f, 0xf4, 0x1d, 0x6d, 0xff, 0x45, 0x3e, 0xc2, 0xd1, 0x74, 0xcb, 0xe8, 0x99, 0x1d, 0xb5,
	0xb4, 0x39, 0x80, 0x27, 0xbb, 0x38, 0xc6, 0x89, 0x97, 0xe2, 0x40, 0x63, 0x66, 0x80, 0xe3, 0x94,
	0xa4, 0x63, 0x67, 0x3c, 0xc2, 0xe8, 0x09, 0xbc, 0xd7, 0xed, 0x39, 0xae, 0xd9, 0x31, 0xba, 0x8e,
	0xe9, 0x1c, 0xba, 0xed, 0x9e, 0x75, 0xb0, 0xcf, 0x25, 0x2f, 0x83, 0xba, 0x6b, 0x74, 0x0d, 0x5b,
	0x73, 0x8c, 0x8e, 0xab, 0x59, 0xdf, 0x6a, 0x87, 0x7d, 0x55, 0x46, 0x75, 0x58, 0xbe, 0xcd, 0xea,
	0x87, 0x37, 0xaa, 0x4b, 0xfa, 0xc7, 0x17, 0x7f, 0x35, 0xa4, 0x8b, 0xab, 0x86, 0xfc, 0xfa, 0xaa,
	0x21, 0xbf, 0xb9, 0x6a, 0xc8, 0x7f, 0x5e, 0x35, 0xe4, 0x1f, 0xaf, 0x1b, 0xd2, 0xeb, 0xeb, 0x86,
	0xf4, 0xe6, 0xba, 0x21, 0x7d, 0x37, 0x23, 0x0e, 0xfc, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xee,
	0xe2, 0x16, 0xa3, 0xc6, 0x07, 0x00, 0x00,
}

func (this *LocalityConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalityConfig)
	if !ok {
		that2, ok := that.(LocalityConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Locality == nil {
		if this.Locality != nil {
			return false
		}
	} else if this.Locality == nil {
		return false
	} else if !this.Locality.Equal(that1.Locality) {
		return false
	}
	return true
}
func (this *LocalityConfig_Global_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalityConfig_Global_)
	if !ok {
		that2, ok := that.(LocalityConfig_Global_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Global.Equal(that1.Global) {
		return false
	}
	return true
}
func (this *LocalityConfig_RegionalByTable_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalityConfig_RegionalByTable_)
	if !ok {
		that2, ok := that.(LocalityConfig_RegionalByTable_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RegionalByTable.Equal(that1.RegionalByTable) {
		return false
	}
	return true
}
func (this *LocalityConfig_RegionalByRow_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalityConfig_RegionalByRow_)
	if !ok {
		that2, ok := that.(LocalityConfig_RegionalByRow_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RegionalByRow.Equal(that1.RegionalByRow) {
		return false
	}
	return true
}
func (this *LocalityConfig_RegionalByTable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalityConfig_RegionalByTable)
	if !ok {
		that2, ok := that.(LocalityConfig_RegionalByTable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Region != nil && that1.Region != nil {
		if *this.Region != *that1.Region {
			return false
		}
	} else if this.Region != nil {
		return false
	} else if that1.Region != nil {
		return false
	}
	return true
}
func (this *LocalityConfig_RegionalByRow) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalityConfig_RegionalByRow)
	if !ok {
		that2, ok := that.(LocalityConfig_RegionalByRow)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.As != nil && that1.As != nil {
		if *this.As != *that1.As {
			return false
		}
	} else if this.As != nil {
		return false
	} else if that1.As != nil {
		return false
	}
	return true
}
func (this *LocalityConfig_Global) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalityConfig_Global)
	if !ok {
		that2, ok := that.(LocalityConfig_Global)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ShardedDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShardedDescriptor)
	if !ok {
		that2, ok := that.(ShardedDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IsSharded != that1.IsSharded {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.ShardBuckets != that1.ShardBuckets {
		return false
	}
	if len(this.ColumnNames) != len(that1.ColumnNames) {
		return false
	}
	for i := range this.ColumnNames {
		if this.ColumnNames[i] != that1.ColumnNames[i] {
			return false
		}
	}
	return true
}
func (this *PartitioningDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PartitioningDescriptor)
	if !ok {
		that2, ok := that.(PartitioningDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NumColumns != that1.NumColumns {
		return false
	}
	if this.NumImplicitColumns != that1.NumImplicitColumns {
		return false
	}
	if len(this.List) != len(that1.List) {
		return false
	}
	for i := range this.List {
		if !this.List[i].Equal(&that1.List[i]) {
			return false
		}
	}
	if len(this.Range) != len(that1.Range) {
		return false
	}
	for i := range this.Range {
		if !this.Range[i].Equal(&that1.Range[i]) {
			return false
		}
	}
	return true
}
func (this *PartitioningDescriptor_List) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PartitioningDescriptor_List)
	if !ok {
		that2, ok := that.(PartitioningDescriptor_List)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if !bytes.Equal(this.Values[i], that1.Values[i]) {
			return false
		}
	}
	if !this.Subpartitioning.Equal(&that1.Subpartitioning) {
		return false
	}
	return true
}
func (this *PartitioningDescriptor_Range) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PartitioningDescriptor_Range)
	if !ok {
		that2, ok := that.(PartitioningDescriptor_Range)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !bytes.Equal(this.FromInclusive, that1.FromInclusive) {
		return false
	}
	if !bytes.Equal(this.ToExclusive, that1.ToExclusive) {
		return false
	}
	return true
}
func (this *RowLevelTTL) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RowLevelTTL)
	if !ok {
		that2, ok := that.(RowLevelTTL)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DurationExpr != that1.DurationExpr {
		return false
	}
	if this.SelectBatchSize != that1.SelectBatchSize {
		return false
	}
	if this.DeleteBatchSize != that1.DeleteBatchSize {
		return false
	}
	if this.DeletionCron != that1.DeletionCron {
		return false
	}
	if this.ScheduleID != that1.ScheduleID {
		return false
	}
	return true
}
func (m *LocalityConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalityConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalityConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Locality != nil {
		{
			size := m.Locality.Size()
			i -= size
			if _, err := m.Locality.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *LocalityConfig_Global_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalityConfig_Global_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Global != nil {
		{
			size, err := m.Global.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCatalog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *LocalityConfig_RegionalByTable_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalityConfig_RegionalByTable_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RegionalByTable != nil {
		{
			size, err := m.RegionalByTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCatalog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *LocalityConfig_RegionalByRow_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalityConfig_RegionalByRow_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RegionalByRow != nil {
		{
			size, err := m.RegionalByRow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCatalog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *LocalityConfig_RegionalByTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalityConfig_RegionalByTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalityConfig_RegionalByTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Region != nil {
		i -= len(*m.Region)
		copy(dAtA[i:], *m.Region)
		i = encodeVarintCatalog(dAtA, i, uint64(len(*m.Region)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocalityConfig_RegionalByRow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalityConfig_RegionalByRow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalityConfig_RegionalByRow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.As != nil {
		i -= len(*m.As)
		copy(dAtA[i:], *m.As)
		i = encodeVarintCatalog(dAtA, i, uint64(len(*m.As)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocalityConfig_Global) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalityConfig_Global) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalityConfig_Global) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ShardedDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardedDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardedDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ColumnNames) > 0 {
		for iNdEx := len(m.ColumnNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ColumnNames[iNdEx])
			copy(dAtA[i:], m.ColumnNames[iNdEx])
			i = encodeVarintCatalog(dAtA, i, uint64(len(m.ColumnNames[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	i = encodeVarintCatalog(dAtA, i, uint64(m.ShardBuckets))
	i--
	dAtA[i] = 0x18
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintCatalog(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0x12
	i--
	if m.IsSharded {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ScheduledRowLevelTTLArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduledRowLevelTTLArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduledRowLevelTTLArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintCatalog(dAtA, i, uint64(m.TableID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *PartitioningDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitioningDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitioningDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintCatalog(dAtA, i, uint64(m.NumImplicitColumns))
	i--
	dAtA[i] = 0x20
	if len(m.Range) > 0 {
		for iNdEx := len(m.Range) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Range[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCatalog(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCatalog(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	i = encodeVarintCatalog(dAtA, i, uint64(m.NumColumns))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *PartitioningDescriptor_List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitioningDescriptor_List) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitioningDescriptor_List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Subpartitioning.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCatalog(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Values[iNdEx])
			copy(dAtA[i:], m.Values[iNdEx])
			i = encodeVarintCatalog(dAtA, i, uint64(len(m.Values[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintCatalog(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PartitioningDescriptor_Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitioningDescriptor_Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitioningDescriptor_Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FromInclusive != nil {
		i -= len(m.FromInclusive)
		copy(dAtA[i:], m.FromInclusive)
		i = encodeVarintCatalog(dAtA, i, uint64(len(m.FromInclusive)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ToExclusive != nil {
		i -= len(m.ToExclusive)
		copy(dAtA[i:], m.ToExclusive)
		i = encodeVarintCatalog(dAtA, i, uint64(len(m.ToExclusive)))
		i--
		dAtA[i] = 0x12
	}
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintCatalog(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RowLevelTTL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowLevelTTL) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowLevelTTL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintCatalog(dAtA, i, uint64(m.ScheduleID))
	i--
	dAtA[i] = 0x28
	i -= len(m.DeletionCron)
	copy(dAtA[i:], m.DeletionCron)
	i = encodeVarintCatalog(dAtA, i, uint64(len(m.DeletionCron)))
	i--
	dAtA[i] = 0x22
	i = encodeVarintCatalog(dAtA, i, uint64(m.DeleteBatchSize))
	i--
	dAtA[i] = 0x18
	i = encodeVarintCatalog(dAtA, i, uint64(m.SelectBatchSize))
	i--
	dAtA[i] = 0x10
	i -= len(m.DurationExpr)
	copy(dAtA[i:], m.DurationExpr)
	i = encodeVarintCatalog(dAtA, i, uint64(len(m.DurationExpr)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintCatalog(dAtA []byte, offset int, v uint64) int {
	offset -= sovCatalog(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LocalityConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Locality != nil {
		n += m.Locality.Size()
	}
	return n
}

func (m *LocalityConfig_Global_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Global != nil {
		l = m.Global.Size()
		n += 1 + l + sovCatalog(uint64(l))
	}
	return n
}
func (m *LocalityConfig_RegionalByTable_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegionalByTable != nil {
		l = m.RegionalByTable.Size()
		n += 1 + l + sovCatalog(uint64(l))
	}
	return n
}
func (m *LocalityConfig_RegionalByRow_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegionalByRow != nil {
		l = m.RegionalByRow.Size()
		n += 1 + l + sovCatalog(uint64(l))
	}
	return n
}
func (m *LocalityConfig_RegionalByTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Region != nil {
		l = len(*m.Region)
		n += 1 + l + sovCatalog(uint64(l))
	}
	return n
}

func (m *LocalityConfig_RegionalByRow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.As != nil {
		l = len(*m.As)
		n += 1 + l + sovCatalog(uint64(l))
	}
	return n
}

func (m *LocalityConfig_Global) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ShardedDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	l = len(m.Name)
	n += 1 + l + sovCatalog(uint64(l))
	n += 1 + sovCatalog(uint64(m.ShardBuckets))
	if len(m.ColumnNames) > 0 {
		for _, s := range m.ColumnNames {
			l = len(s)
			n += 1 + l + sovCatalog(uint64(l))
		}
	}
	return n
}

func (m *ScheduledRowLevelTTLArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCatalog(uint64(m.TableID))
	return n
}

func (m *PartitioningDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCatalog(uint64(m.NumColumns))
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovCatalog(uint64(l))
		}
	}
	if len(m.Range) > 0 {
		for _, e := range m.Range {
			l = e.Size()
			n += 1 + l + sovCatalog(uint64(l))
		}
	}
	n += 1 + sovCatalog(uint64(m.NumImplicitColumns))
	return n
}

func (m *PartitioningDescriptor_List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovCatalog(uint64(l))
	if len(m.Values) > 0 {
		for _, b := range m.Values {
			l = len(b)
			n += 1 + l + sovCatalog(uint64(l))
		}
	}
	l = m.Subpartitioning.Size()
	n += 1 + l + sovCatalog(uint64(l))
	return n
}

func (m *PartitioningDescriptor_Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovCatalog(uint64(l))
	if m.ToExclusive != nil {
		l = len(m.ToExclusive)
		n += 1 + l + sovCatalog(uint64(l))
	}
	if m.FromInclusive != nil {
		l = len(m.FromInclusive)
		n += 1 + l + sovCatalog(uint64(l))
	}
	return n
}

func (m *RowLevelTTL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DurationExpr)
	n += 1 + l + sovCatalog(uint64(l))
	n += 1 + sovCatalog(uint64(m.SelectBatchSize))
	n += 1 + sovCatalog(uint64(m.DeleteBatchSize))
	l = len(m.DeletionCron)
	n += 1 + l + sovCatalog(uint64(l))
	n += 1 + sovCatalog(uint64(m.ScheduleID))
	return n
}

func sovCatalog(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCatalog(x uint64) (n int) {
	return sovCatalog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LocalityConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalityConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalityConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LocalityConfig_Global{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Locality = &LocalityConfig_Global_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionalByTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LocalityConfig_RegionalByTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Locality = &LocalityConfig_RegionalByTable_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionalByRow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LocalityConfig_RegionalByRow{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Locality = &LocalityConfig_RegionalByRow_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalityConfig_RegionalByTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionalByTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionalByTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := RegionName(dAtA[iNdEx:postIndex])
			m.Region = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalityConfig_RegionalByRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionalByRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionalByRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field As", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.As = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalityConfig_Global) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Global: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Global: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardedDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardedDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardedDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSharded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSharded = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardBuckets", wireType)
			}
			m.ShardBuckets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardBuckets |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnNames = append(m.ColumnNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduledRowLevelTTLArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduledRowLevelTTLArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduledRowLevelTTLArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_cockroachdb_cockroach_pkg_sql_sem_catid.DescID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitioningDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitioningDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitioningDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumColumns", wireType)
			}
			m.NumColumns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumColumns |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, PartitioningDescriptor_List{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Range = append(m.Range, PartitioningDescriptor_Range{})
			if err := m.Range[len(m.Range)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumImplicitColumns", wireType)
			}
			m.NumImplicitColumns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumImplicitColumns |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitioningDescriptor_List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, make([]byte, postIndex-iNdEx))
			copy(m.Values[len(m.Values)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subpartitioning", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Subpartitioning.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitioningDescriptor_Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToExclusive", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToExclusive = append(m.ToExclusive[:0], dAtA[iNdEx:postIndex]...)
			if m.ToExclusive == nil {
				m.ToExclusive = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromInclusive", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromInclusive = append(m.FromInclusive[:0], dAtA[iNdEx:postIndex]...)
			if m.FromInclusive == nil {
				m.FromInclusive = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowLevelTTL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowLevelTTL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowLevelTTL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationExpr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DurationExpr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectBatchSize", wireType)
			}
			m.SelectBatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelectBatchSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteBatchSize", wireType)
			}
			m.DeleteBatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteBatchSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionCron", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCatalog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCatalog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeletionCron = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduleID", wireType)
			}
			m.ScheduleID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScheduleID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCatalog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCatalog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCatalog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCatalog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCatalog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCatalog
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCatalog
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCatalog
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCatalog        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCatalog          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCatalog = fmt.Errorf("proto: unexpected end of group")
)
