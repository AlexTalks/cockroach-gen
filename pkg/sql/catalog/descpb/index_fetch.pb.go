// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/catalog/descpb/index_fetch.proto

package descpb

import (
	fmt "fmt"
	types "github.com/cockroachdb/cockroach/pkg/sql/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// IndexFetchSpec contains the subset of information (from TableDescriptor and
// IndexDescriptor) that is necessary to decode KVs into SQL keys and values.
type IndexFetchSpec struct {
	TableName        string `protobuf:"bytes,2,opt,name=table_name,json=tableName" json:"table_name"`
	TableID          ID     `protobuf:"varint,3,opt,name=table_id,json=tableId,casttype=ID" json:"table_id"`
	IndexName        string `protobuf:"bytes,4,opt,name=index_name,json=indexName" json:"index_name"`
	IsSecondaryIndex bool   `protobuf:"varint,5,opt,name=is_secondary_index,json=isSecondaryIndex" json:"is_secondary_index"`
	IsUniqueIndex    bool   `protobuf:"varint,6,opt,name=is_unique_index,json=isUniqueIndex" json:"is_unique_index"`
	// EncodingType represents what sort of k/v encoding is used to store the
	// table data.
	EncodingType IndexDescriptorEncodingType `protobuf:"varint,7,opt,name=encoding_type,json=encodingType,casttype=IndexDescriptorEncodingType" json:"encoding_type"`
	// NumKeySuffixColumns is the number of suffix columns (corresponding to a
	// suffix of KeyAndSuffixColumns).
	//
	// If the index is not unique, the suffix columns are always part of the key.
	//
	// If the index is unique, the suffix columns are encoded (using key encoding)
	// into the KV value. If one of the indexed columns is NULL, the key will
	// also contain the suffix column values.
	NumKeySuffixColumns uint32 `protobuf:"varint,8,opt,name=num_key_suffix_columns,json=numKeySuffixColumns" json:"num_key_suffix_columns"`
	// MaxKeysPerRow is the maximum number of keys per row in this index. It is
	// used for various optimizations.
	MaxKeysPerRow uint32 `protobuf:"varint,9,opt,name=max_keys_per_row,json=maxKeysPerRow" json:"max_keys_per_row"`
	// KeyPrefixLength is the length of the key prefix that encodes the table and
	// index ID.
	KeyPrefixLength uint32   `protobuf:"varint,10,opt,name=key_prefix_length,json=keyPrefixLength" json:"key_prefix_length"`
	MaxFamilyID     FamilyID `protobuf:"varint,11,opt,name=max_family_id,json=maxFamilyId,casttype=FamilyID" json:"max_family_id"`
	// FamilyDefaultColumns contains the default column IDs for families with a
	// default column. This is used to decode values that use the single column
	// optimization (where the column ID is omitted).
	FamilyDefaultColumns []IndexFetchSpec_FamilyDefaultColumn `protobuf:"bytes,12,rep,name=family_default_columns,json=familyDefaultColumns" json:"family_default_columns"`
	// KeyAndSuffixColumns contains all the key and suffix columns, in order.
	KeyAndSuffixColumns []IndexFetchSpec_KeyColumn `protobuf:"bytes,13,rep,name=key_and_suffix_columns,json=keyAndSuffixColumns" json:"key_and_suffix_columns"`
	// FetchedColumns contains all the columns we are producing values for. The
	// fetched columns can overlap with the key columns.
	//
	// Any other column IDs present in the fetched KVs will be ignored.
	FetchedColumns []IndexFetchSpec_Column `protobuf:"bytes,14,rep,name=fetched_columns,json=fetchedColumns" json:"fetched_columns"`
}

func (m *IndexFetchSpec) Reset()         { *m = IndexFetchSpec{} }
func (m *IndexFetchSpec) String() string { return proto.CompactTextString(m) }
func (*IndexFetchSpec) ProtoMessage()    {}
func (*IndexFetchSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a92d74b9af70e0, []int{0}
}
func (m *IndexFetchSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexFetchSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexFetchSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexFetchSpec.Merge(m, src)
}
func (m *IndexFetchSpec) XXX_Size() int {
	return m.Size()
}
func (m *IndexFetchSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexFetchSpec.DiscardUnknown(m)
}

var xxx_messageInfo_IndexFetchSpec proto.InternalMessageInfo

type IndexFetchSpec_Column struct {
	ColumnID ColumnID `protobuf:"varint,1,opt,name=column_id,json=columnId,casttype=ColumnID" json:"column_id"`
	// Name of the column, as it is expected to appear in debug and error
	// messages.
	Name string `protobuf:"bytes,2,opt,name=name" json:"name"`
	// Type of the column. If this is the key column of an inverted index, this
	// is the actual type of whan the index encodes (usually Bytes), rather than
	// the table column type (e.g. JSON).
	Type *types.T `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
	// IsNonNullable indicates that it would be a corruption error if we ever
	// encounter a NULL value for this column (i.e. the column is non-nullable
	// and not a mutation column).
	IsNonNullable bool `protobuf:"varint,4,opt,name=is_non_nullable,json=isNonNullable" json:"is_non_nullable"`
}

func (m *IndexFetchSpec_Column) Reset()         { *m = IndexFetchSpec_Column{} }
func (m *IndexFetchSpec_Column) String() string { return proto.CompactTextString(m) }
func (*IndexFetchSpec_Column) ProtoMessage()    {}
func (*IndexFetchSpec_Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a92d74b9af70e0, []int{0, 0}
}
func (m *IndexFetchSpec_Column) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexFetchSpec_Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexFetchSpec_Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexFetchSpec_Column.Merge(m, src)
}
func (m *IndexFetchSpec_Column) XXX_Size() int {
	return m.Size()
}
func (m *IndexFetchSpec_Column) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexFetchSpec_Column.DiscardUnknown(m)
}

var xxx_messageInfo_IndexFetchSpec_Column proto.InternalMessageInfo

// KeyColumn describes a column that is encoded using the key encoding.
type IndexFetchSpec_KeyColumn struct {
	IndexFetchSpec_Column `protobuf:"bytes,1,opt,name=column,embedded=column" json:"column"`
	Direction             IndexDescriptor_Direction `protobuf:"varint,2,opt,name=direction,enum=cockroach.sql.sqlbase.IndexDescriptor_Direction" json:"direction"`
	// IsComposite is true if this column can have a composite encoding (i.e. it
	// can appear in the value in addition to the key).
	IsComposite bool `protobuf:"varint,3,opt,name=is_composite,json=isComposite" json:"is_composite"`
	// IsInverted is true if this column is the inverted key of an inverted index.
	// In this case, the type of this column is the type of the data element
	// (currently always Bytes).
	IsInverted bool `protobuf:"varint,4,opt,name=is_inverted,json=isInverted" json:"is_inverted"`
}

func (m *IndexFetchSpec_KeyColumn) Reset()         { *m = IndexFetchSpec_KeyColumn{} }
func (m *IndexFetchSpec_KeyColumn) String() string { return proto.CompactTextString(m) }
func (*IndexFetchSpec_KeyColumn) ProtoMessage()    {}
func (*IndexFetchSpec_KeyColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a92d74b9af70e0, []int{0, 1}
}
func (m *IndexFetchSpec_KeyColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexFetchSpec_KeyColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexFetchSpec_KeyColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexFetchSpec_KeyColumn.Merge(m, src)
}
func (m *IndexFetchSpec_KeyColumn) XXX_Size() int {
	return m.Size()
}
func (m *IndexFetchSpec_KeyColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexFetchSpec_KeyColumn.DiscardUnknown(m)
}

var xxx_messageInfo_IndexFetchSpec_KeyColumn proto.InternalMessageInfo

// FamilyDefaultColumn specifies the default column ID for a given family ID.
type IndexFetchSpec_FamilyDefaultColumn struct {
	FamilyID FamilyID `protobuf:"varint,1,opt,name=family_id,json=familyId,casttype=FamilyID" json:"family_id"`
	// DefaultColumnID is the implicit column ID when a single value is encoded
	// for the family. See ColumnFamilyDescriptor.DefaultColumnID.
	DefaultColumnID ColumnID `protobuf:"varint,2,opt,name=default_column_id,json=defaultColumnId,casttype=ColumnID" json:"default_column_id"`
}

func (m *IndexFetchSpec_FamilyDefaultColumn) Reset()         { *m = IndexFetchSpec_FamilyDefaultColumn{} }
func (m *IndexFetchSpec_FamilyDefaultColumn) String() string { return proto.CompactTextString(m) }
func (*IndexFetchSpec_FamilyDefaultColumn) ProtoMessage()    {}
func (*IndexFetchSpec_FamilyDefaultColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_53a92d74b9af70e0, []int{0, 2}
}
func (m *IndexFetchSpec_FamilyDefaultColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexFetchSpec_FamilyDefaultColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IndexFetchSpec_FamilyDefaultColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexFetchSpec_FamilyDefaultColumn.Merge(m, src)
}
func (m *IndexFetchSpec_FamilyDefaultColumn) XXX_Size() int {
	return m.Size()
}
func (m *IndexFetchSpec_FamilyDefaultColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexFetchSpec_FamilyDefaultColumn.DiscardUnknown(m)
}

var xxx_messageInfo_IndexFetchSpec_FamilyDefaultColumn proto.InternalMessageInfo

func init() {
	proto.RegisterType((*IndexFetchSpec)(nil), "cockroach.sql.sqlbase.IndexFetchSpec")
	proto.RegisterType((*IndexFetchSpec_Column)(nil), "cockroach.sql.sqlbase.IndexFetchSpec.Column")
	proto.RegisterType((*IndexFetchSpec_KeyColumn)(nil), "cockroach.sql.sqlbase.IndexFetchSpec.KeyColumn")
	proto.RegisterType((*IndexFetchSpec_FamilyDefaultColumn)(nil), "cockroach.sql.sqlbase.IndexFetchSpec.FamilyDefaultColumn")
}

func init() {
	proto.RegisterFile("sql/catalog/descpb/index_fetch.proto", fileDescriptor_53a92d74b9af70e0)
}

var fileDescriptor_53a92d74b9af70e0 = []byte{
	// 806 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x41, 0x53, 0xe3, 0x36,
	0x14, 0x8e, 0x59, 0x0a, 0x8e, 0x4c, 0xc8, 0xae, 0x58, 0x18, 0x4f, 0xda, 0x71, 0x98, 0xd2, 0x4e,
	0x73, 0xd8, 0x3a, 0x0c, 0x37, 0x8e, 0x85, 0x74, 0xa7, 0x19, 0x5a, 0xba, 0x63, 0xe8, 0xa5, 0x3d,
	0x78, 0x8c, 0xf5, 0x12, 0x54, 0x6c, 0xc9, 0x58, 0x76, 0x37, 0x3e, 0xf6, 0x1f, 0xf4, 0x2f, 0xf4,
	0x77, 0xf4, 0xd0, 0x2b, 0x47, 0x8e, 0x7b, 0xca, 0xb4, 0xe1, 0x5f, 0xec, 0xa9, 0x23, 0xc9, 0x0e,
	0x71, 0x36, 0xd3, 0x61, 0x0f, 0xc9, 0xc8, 0xef, 0x7d, 0xfa, 0xbe, 0xa7, 0xf7, 0xf4, 0x09, 0x7d,
	0x21, 0x6e, 0xa3, 0x7e, 0x18, 0x64, 0x41, 0xc4, 0xc7, 0x7d, 0x02, 0x22, 0x4c, 0xae, 0xfa, 0x94,
	0x11, 0x98, 0xf8, 0x23, 0xc8, 0xc2, 0x6b, 0x37, 0x49, 0x79, 0xc6, 0xf1, 0x6e, 0xc8, 0xc3, 0x9b,
	0x94, 0x07, 0xe1, 0xb5, 0x2b, 0x6e, 0x23, 0xf9, 0xbb, 0x0a, 0x04, 0x74, 0x5e, 0x8e, 0xf9, 0x98,
	0x2b, 0x44, 0x5f, 0xae, 0x34, 0xb8, 0xb3, 0x2b, 0x29, 0xb3, 0x22, 0x01, 0xa1, 0xff, 0xcb, 0xf0,
	0xc1, 0x0a, 0x25, 0x91, 0xa5, 0x79, 0x98, 0xe5, 0x29, 0x10, 0x0d, 0xfa, 0xfc, 0x6f, 0x0b, 0x6d,
	0x0f, 0xa5, 0xfc, 0x6b, 0xa9, 0x7e, 0x91, 0x40, 0x88, 0x0f, 0x10, 0xca, 0x82, 0xab, 0x08, 0x7c,
	0x16, 0xc4, 0x60, 0xaf, 0xed, 0x1b, 0xbd, 0xe6, 0xc9, 0xfa, 0xdd, 0xb4, 0xdb, 0xf0, 0x9a, 0x2a,
	0x7e, 0x1e, 0xc4, 0x80, 0x0f, 0x91, 0xa9, 0x41, 0x94, 0xd8, 0xcf, 0xf6, 0x8d, 0x5e, 0xeb, 0x64,
	0x57, 0x42, 0x66, 0xd3, 0xee, 0xe6, 0xa5, 0x8c, 0x0f, 0x07, 0xef, 0xa7, 0xdd, 0xb5, 0xe1, 0xc0,
	0xdb, 0x54, 0xb0, 0x21, 0x91, 0xb4, 0xfa, 0x9c, 0x8a, 0x76, 0x7d, 0x91, 0x56, 0xc5, 0x15, 0xed,
	0x11, 0xc2, 0x54, 0xf8, 0x02, 0x42, 0xce, 0x48, 0x90, 0x16, 0xbe, 0xca, 0xd8, 0x9f, 0xec, 0x1b,
	0x3d, 0xb3, 0x04, 0x3f, 0xa7, 0xe2, 0xa2, 0x4a, 0xab, 0xc2, 0xf1, 0x2b, 0xd4, 0xa6, 0xc2, 0xcf,
	0x19, 0xbd, 0xcd, 0xa1, 0xdc, 0xb0, 0xb1, 0xb0, 0xa1, 0x45, 0xc5, 0x4f, 0x2a, 0xa7, 0xd1, 0xdf,
	0xa1, 0x16, 0xb0, 0x90, 0x13, 0xca, 0xc6, 0xbe, 0xec, 0x96, 0xbd, 0xa9, 0xaa, 0x3f, 0x90, 0xd8,
	0xf7, 0xd3, 0xee, 0xa7, 0x0a, 0x35, 0x00, 0x11, 0xa6, 0x34, 0xc9, 0x78, 0xfa, 0x6d, 0x89, 0xbd,
	0x2c, 0x12, 0xf0, 0xb6, 0x60, 0xe1, 0x0b, 0x1f, 0xa3, 0x3d, 0x96, 0xc7, 0xfe, 0x0d, 0x14, 0xbe,
	0xc8, 0x47, 0x23, 0x3a, 0xf1, 0x43, 0x1e, 0xe5, 0x31, 0x13, 0xb6, 0xa9, 0x28, 0xb5, 0xfc, 0x0e,
	0xcb, 0xe3, 0x33, 0x28, 0x2e, 0x14, 0xe2, 0x54, 0x03, 0xf0, 0xd7, 0xe8, 0x79, 0x1c, 0x4c, 0xe4,
	0x56, 0xe1, 0x27, 0x90, 0xfa, 0x29, 0x7f, 0x6b, 0x37, 0x17, 0x36, 0xb5, 0xe2, 0x60, 0x72, 0x06,
	0x85, 0x78, 0x03, 0xa9, 0xc7, 0xdf, 0xe2, 0x43, 0xf4, 0x42, 0xaa, 0x24, 0x29, 0x48, 0x95, 0x08,
	0xd8, 0x38, 0xbb, 0xb6, 0xd1, 0x02, 0xbe, 0x7d, 0x03, 0xc5, 0x1b, 0x95, 0xfd, 0x5e, 0x25, 0xf1,
	0x29, 0x92, 0x14, 0xfe, 0x28, 0x88, 0x69, 0x54, 0xc8, 0x19, 0x59, 0x0a, 0xdd, 0x2d, 0x67, 0x64,
	0xfd, 0x10, 0x4c, 0x5e, 0xab, 0x9c, 0x9a, 0x93, 0x59, 0xad, 0x3d, 0x2b, 0x9e, 0x27, 0x08, 0xce,
	0xd1, 0x5e, 0x49, 0x40, 0x60, 0x14, 0xe4, 0x51, 0x36, 0x3f, 0xe0, 0xd6, 0xfe, 0xb3, 0x9e, 0x75,
	0x74, 0xec, 0xae, 0xbc, 0xa5, 0x6e, 0xfd, 0x3e, 0xb9, 0x9a, 0x6f, 0xa0, 0x29, 0x74, 0x07, 0xca,
	0xb2, 0x5f, 0x8e, 0x3e, 0x4c, 0x09, 0xfc, 0x2b, 0xda, 0x93, 0xa7, 0x0d, 0x18, 0x59, 0xee, 0x6b,
	0x4b, 0xc9, 0xf6, 0x9f, 0x26, 0x7b, 0x06, 0x45, 0x4d, 0x6c, 0xe7, 0x06, 0x8a, 0x6f, 0x18, 0xa9,
	0x0f, 0xe2, 0x17, 0xd4, 0x56, 0xb6, 0x03, 0x32, 0x17, 0xd9, 0x56, 0x22, 0xaf, 0x9e, 0x26, 0x52,
	0x53, 0xd8, 0x2e, 0xa9, 0x4a, 0xf2, 0xce, 0x5f, 0x06, 0xda, 0xd0, 0x6b, 0x7c, 0x8c, 0x9a, 0x9a,
	0x5f, 0xce, 0xc2, 0x50, 0xb3, 0xf8, 0xac, 0x9c, 0x85, 0xa9, 0x21, 0x7a, 0x10, 0xd5, 0xda, 0x33,
	0x35, 0x7c, 0x48, 0xb0, 0x8d, 0xd6, 0x3f, 0x30, 0xa2, 0x8a, 0x60, 0x17, 0xad, 0xab, 0x1b, 0x2c,
	0xfd, 0x67, 0x1d, 0x75, 0x96, 0x2b, 0x86, 0xd8, 0xd5, 0xcf, 0xc1, 0xa5, 0xa7, 0x70, 0xa5, 0x51,
	0x18, 0x67, 0x3e, 0xcb, 0xa3, 0x48, 0xda, 0x52, 0xd9, 0x70, 0xc1, 0x28, 0xe7, 0x9c, 0x9d, 0x97,
	0xa9, 0xce, 0xef, 0x6b, 0xa8, 0x39, 0xef, 0x21, 0x3e, 0x47, 0x1b, 0xba, 0x22, 0x55, 0xfd, 0xc7,
	0xf6, 0xc7, 0x94, 0x02, 0xf7, 0xd3, 0xae, 0xe1, 0x95, 0x2c, 0xf8, 0x12, 0x35, 0x09, 0x4d, 0x21,
	0xcc, 0x28, 0x67, 0xea, 0x68, 0xdb, 0x47, 0x87, 0xff, 0x47, 0xf9, 0xe8, 0x48, 0x77, 0x50, 0xed,
	0xab, 0x9e, 0x8f, 0x39, 0x11, 0xfe, 0x0a, 0x6d, 0x51, 0xe1, 0x87, 0x3c, 0x4e, 0xb8, 0xa0, 0x99,
	0xee, 0x4c, 0x75, 0x3c, 0x8b, 0x8a, 0xd3, 0x2a, 0x81, 0xbf, 0x44, 0x16, 0x15, 0x3e, 0x65, 0xbf,
	0x41, 0x9a, 0x01, 0xa9, 0xb5, 0x01, 0x51, 0x31, 0x2c, 0xe3, 0x9d, 0x3f, 0x0d, 0xb4, 0xb3, 0xe2,
	0xfa, 0xca, 0x71, 0x3e, 0x5a, 0x6b, 0x69, 0x9c, 0x2b, 0x7d, 0x65, 0x8e, 0x2a, 0x53, 0xfd, 0x88,
	0x5e, 0xd4, 0xdd, 0x24, 0x29, 0xd6, 0x1e, 0xdf, 0xa0, 0xd9, 0xb4, 0xdb, 0xae, 0x89, 0x2d, 0x5d,
	0x8c, 0x36, 0xa9, 0x25, 0xc9, 0x49, 0xef, 0xee, 0x5f, 0xa7, 0x71, 0x37, 0x73, 0x8c, 0xfb, 0x99,
	0x63, 0xbc, 0x9b, 0x39, 0xc6, 0x3f, 0x33, 0xc7, 0xf8, 0xe3, 0xc1, 0x69, 0xdc, 0x3f, 0x38, 0x8d,
	0x77, 0x0f, 0x4e, 0xe3, 0xe7, 0x0d, 0xfd, 0xf8, 0xff, 0x17, 0x00, 0x00, 0xff, 0xff, 0x87, 0x79,
	0xcd, 0xa0, 0x7b, 0x06, 0x00, 0x00,
}

func (m *IndexFetchSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexFetchSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexFetchSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FetchedColumns) > 0 {
		for iNdEx := len(m.FetchedColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FetchedColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIndexFetch(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.KeyAndSuffixColumns) > 0 {
		for iNdEx := len(m.KeyAndSuffixColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.KeyAndSuffixColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIndexFetch(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.FamilyDefaultColumns) > 0 {
		for iNdEx := len(m.FamilyDefaultColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FamilyDefaultColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIndexFetch(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.MaxFamilyID))
	i--
	dAtA[i] = 0x58
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.KeyPrefixLength))
	i--
	dAtA[i] = 0x50
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.MaxKeysPerRow))
	i--
	dAtA[i] = 0x48
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.NumKeySuffixColumns))
	i--
	dAtA[i] = 0x40
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.EncodingType))
	i--
	dAtA[i] = 0x38
	i--
	if m.IsUniqueIndex {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x30
	i--
	if m.IsSecondaryIndex {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x28
	i -= len(m.IndexName)
	copy(dAtA[i:], m.IndexName)
	i = encodeVarintIndexFetch(dAtA, i, uint64(len(m.IndexName)))
	i--
	dAtA[i] = 0x22
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.TableID))
	i--
	dAtA[i] = 0x18
	i -= len(m.TableName)
	copy(dAtA[i:], m.TableName)
	i = encodeVarintIndexFetch(dAtA, i, uint64(len(m.TableName)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}

func (m *IndexFetchSpec_Column) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexFetchSpec_Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexFetchSpec_Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.IsNonNullable {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	if m.Type != nil {
		{
			size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIndexFetch(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintIndexFetch(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.ColumnID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *IndexFetchSpec_KeyColumn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexFetchSpec_KeyColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexFetchSpec_KeyColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.IsInverted {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	i--
	if m.IsComposite {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.Direction))
	i--
	dAtA[i] = 0x10
	{
		size, err := m.IndexFetchSpec_Column.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintIndexFetch(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IndexFetchSpec_FamilyDefaultColumn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexFetchSpec_FamilyDefaultColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexFetchSpec_FamilyDefaultColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.DefaultColumnID))
	i--
	dAtA[i] = 0x10
	i = encodeVarintIndexFetch(dAtA, i, uint64(m.FamilyID))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func encodeVarintIndexFetch(dAtA []byte, offset int, v uint64) int {
	offset -= sovIndexFetch(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *IndexFetchSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TableName)
	n += 1 + l + sovIndexFetch(uint64(l))
	n += 1 + sovIndexFetch(uint64(m.TableID))
	l = len(m.IndexName)
	n += 1 + l + sovIndexFetch(uint64(l))
	n += 2
	n += 2
	n += 1 + sovIndexFetch(uint64(m.EncodingType))
	n += 1 + sovIndexFetch(uint64(m.NumKeySuffixColumns))
	n += 1 + sovIndexFetch(uint64(m.MaxKeysPerRow))
	n += 1 + sovIndexFetch(uint64(m.KeyPrefixLength))
	n += 1 + sovIndexFetch(uint64(m.MaxFamilyID))
	if len(m.FamilyDefaultColumns) > 0 {
		for _, e := range m.FamilyDefaultColumns {
			l = e.Size()
			n += 1 + l + sovIndexFetch(uint64(l))
		}
	}
	if len(m.KeyAndSuffixColumns) > 0 {
		for _, e := range m.KeyAndSuffixColumns {
			l = e.Size()
			n += 1 + l + sovIndexFetch(uint64(l))
		}
	}
	if len(m.FetchedColumns) > 0 {
		for _, e := range m.FetchedColumns {
			l = e.Size()
			n += 1 + l + sovIndexFetch(uint64(l))
		}
	}
	return n
}

func (m *IndexFetchSpec_Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovIndexFetch(uint64(m.ColumnID))
	l = len(m.Name)
	n += 1 + l + sovIndexFetch(uint64(l))
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovIndexFetch(uint64(l))
	}
	n += 2
	return n
}

func (m *IndexFetchSpec_KeyColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.IndexFetchSpec_Column.Size()
	n += 1 + l + sovIndexFetch(uint64(l))
	n += 1 + sovIndexFetch(uint64(m.Direction))
	n += 2
	n += 2
	return n
}

func (m *IndexFetchSpec_FamilyDefaultColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovIndexFetch(uint64(m.FamilyID))
	n += 1 + sovIndexFetch(uint64(m.DefaultColumnID))
	return n
}

func sovIndexFetch(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozIndexFetch(x uint64) (n int) {
	return sovIndexFetch(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IndexFetchSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexFetch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexFetchSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexFetchSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexFetch
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= ID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexFetch
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSecondaryIndex", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSecondaryIndex = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUniqueIndex", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUniqueIndex = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodingType", wireType)
			}
			m.EncodingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncodingType |= IndexDescriptorEncodingType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumKeySuffixColumns", wireType)
			}
			m.NumKeySuffixColumns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumKeySuffixColumns |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxKeysPerRow", wireType)
			}
			m.MaxKeysPerRow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxKeysPerRow |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPrefixLength", wireType)
			}
			m.KeyPrefixLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyPrefixLength |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFamilyID", wireType)
			}
			m.MaxFamilyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFamilyID |= FamilyID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FamilyDefaultColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexFetch
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FamilyDefaultColumns = append(m.FamilyDefaultColumns, IndexFetchSpec_FamilyDefaultColumn{})
			if err := m.FamilyDefaultColumns[len(m.FamilyDefaultColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyAndSuffixColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexFetch
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyAndSuffixColumns = append(m.KeyAndSuffixColumns, IndexFetchSpec_KeyColumn{})
			if err := m.KeyAndSuffixColumns[len(m.KeyAndSuffixColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FetchedColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexFetch
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FetchedColumns = append(m.FetchedColumns, IndexFetchSpec_Column{})
			if err := m.FetchedColumns[len(m.FetchedColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIndexFetch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexFetchSpec_Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexFetch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnID", wireType)
			}
			m.ColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnID |= ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIndexFetch
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexFetch
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &types.T{}
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNonNullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNonNullable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipIndexFetch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexFetchSpec_KeyColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexFetch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexFetchSpec_Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIndexFetch
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IndexFetchSpec_Column.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= IndexDescriptor_Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsComposite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsComposite = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInverted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInverted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipIndexFetch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexFetchSpec_FamilyDefaultColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIndexFetch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FamilyDefaultColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FamilyDefaultColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FamilyID", wireType)
			}
			m.FamilyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FamilyID |= FamilyID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultColumnID", wireType)
			}
			m.DefaultColumnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultColumnID |= ColumnID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIndexFetch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIndexFetch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIndexFetch(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIndexFetch
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIndexFetch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthIndexFetch
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupIndexFetch
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthIndexFetch
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthIndexFetch        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIndexFetch          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupIndexFetch = fmt.Errorf("proto: unexpected end of group")
)
