// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sql/appstatspb/app_stats.proto

package appstatspb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// StatementStatistics represent the statement statistics sent to the DB
// Console for a given statement fingerprint. Note that these stats are cleared
// ever diagnostics.sql_stat_reset_interval.
// N.B. When fields are added to this struct, make sure to update
// (*StatementStatistics).Add and (*StatementStatistics).AlmostEqual
// in app_stats.go.
type StatementStatistics struct {
	// Count is the total number of times this statement was executed
	// since the begin of the reporting period.
	// When transmitted to the reporting server, this value gets
	// quantized into buckets (few <10, dozens 10+, 100 or more).
	Count int64 `protobuf:"varint,1,opt,name=count" json:"count"`
	// FirstAttemptCount collects the total number of times a first
	// attempt was executed (either the one time in explicitly committed
	// statements, or the first time in implicitly committed statements
	// with implicit retries).
	// The proportion of statements that could be executed without retry
	// can be computed as FirstAttemptCount / Count.
	// The cumulative number of retries can be computed with
	// Count - FirstAttemptCount.
	//
	// When transmitted to the reporting server, this value gets
	// simplified so that the proportion of statements that could be
	// executed without retry remains as FirstAttemptCount / Count.
	FirstAttemptCount int64 `protobuf:"varint,2,opt,name=first_attempt_count,json=firstAttemptCount" json:"first_attempt_count"`
	// MaxRetries collects the maximum observed number of automatic
	// retries in the reporting period.
	// When transmitted to the reporting server, this value gets
	// quantized into buckets (few <10, dozens 10+, 100 or more).
	MaxRetries int64 `protobuf:"varint,3,opt,name=max_retries,json=maxRetries" json:"max_retries"`
	// DEPRECATED: LastErr collects the last error encountered.
	// Use sensitive_info.last_err instead.
	LegacyLastErr string `protobuf:"bytes,4,opt,name=legacy_last_err,json=legacyLastErr" json:"legacy_last_err"`
	// DEPRECATED: LastErrRedacted collects the last error, redacted for reporting.
	LegacyLastErrRedacted string `protobuf:"bytes,11,opt,name=legacy_last_err_redacted,json=legacyLastErrRedacted" json:"legacy_last_err_redacted"`
	// NumRows collects the number of rows returned or observed.
	NumRows NumericStat `protobuf:"bytes,5,opt,name=num_rows,json=numRows" json:"num_rows"`
	// IdleLat is the time spent in seconds in an open transaction waiting
	// for the client to send the statement.
	IdleLat NumericStat `protobuf:"bytes,28,opt,name=idle_lat,json=idleLat" json:"idle_lat"`
	// ParseLat is the time in seconds to transform the SQL string into an AST.
	ParseLat NumericStat `protobuf:"bytes,6,opt,name=parse_lat,json=parseLat" json:"parse_lat"`
	// PlanLat is the time spent in seconds to transform the AST into a logical query plan.
	PlanLat NumericStat `protobuf:"bytes,7,opt,name=plan_lat,json=planLat" json:"plan_lat"`
	// RunLat is the time in seconds to run the query and fetch/compute the result rows.
	RunLat NumericStat `protobuf:"bytes,8,opt,name=run_lat,json=runLat" json:"run_lat"`
	// ServiceLat is the time in seconds to service the query, from start of parse to end of execute.
	ServiceLat NumericStat `protobuf:"bytes,9,opt,name=service_lat,json=serviceLat" json:"service_lat"`
	// OverheadLat is the difference (seconds) between ServiceLat and the sum of parse+plan+run latencies.
	// We store it separately (as opposed to computing it post-hoc) because the combined
	// variance for the overhead cannot be derived from the variance of the separate latencies.
	OverheadLat NumericStat `protobuf:"bytes,10,opt,name=overhead_lat,json=overheadLat" json:"overhead_lat"`
	// SensitiveInfo is info that needs to be scrubbed or redacted before being
	// sent to the reg cluster.
	SensitiveInfo SensitiveInfo `protobuf:"bytes,12,opt,name=sensitive_info,json=sensitiveInfo" json:"sensitive_info"`
	// BytesRead collects the number of bytes read from disk.
	BytesRead NumericStat `protobuf:"bytes,15,opt,name=bytes_read,json=bytesRead" json:"bytes_read"`
	// RowsRead collects the number of rows read from disk.
	RowsRead NumericStat `protobuf:"bytes,16,opt,name=rows_read,json=rowsRead" json:"rows_read"`
	// RowsWritten collects the number of rows written to disk.
	RowsWritten NumericStat `protobuf:"bytes,25,opt,name=rows_written,json=rowsWritten" json:"rows_written"`
	// ExecStats are the execution statistics for this statement. These statistics
	// are sampled.
	ExecStats ExecStats `protobuf:"bytes,21,opt,name=exec_stats,json=execStats" json:"exec_stats"`
	// SQLType is the type of the sql (DDL, DML, DCL or TCL)
	SQLType string `protobuf:"bytes,22,opt,name=sql_type,json=sqlType" json:"sql_type"`
	// LastExecTimestamp is the last timestamp the statement was executed.
	LastExecTimestamp time.Time `protobuf:"bytes,23,opt,name=last_exec_timestamp,json=lastExecTimestamp,stdtime" json:"last_exec_timestamp"`
	// Nodes is the ordered list of nodes ids on which the statement was executed.
	Nodes []int64 `protobuf:"varint,24,rep,name=nodes" json:"nodes,omitempty"`
	// Regions is the ordered list of regions on which the statement was executed.
	Regions []string `protobuf:"bytes,29,rep,name=regions" json:"regions,omitempty"`
	// PlanGists is the list of a compressed version of plan that can be converted (lossily)
	// back into a logical plan.
	// Each statement contain only one plan gist, but the same statement fingerprint id
	// can contain more than one value.
	PlanGists []string `protobuf:"bytes,26,rep,name=plan_gists,json=planGists" json:"plan_gists,omitempty"`
	// IndexRecommendations is the list of index recommendations generated for the statement fingerprint.
	IndexRecommendations []string `protobuf:"bytes,27,rep,name=index_recommendations,json=indexRecommendations" json:"index_recommendations,omitempty"`
	// Indexes is the list of indexes used by the particular plan when executing the statement.
	Indexes []string `protobuf:"bytes,30,rep,name=indexes" json:"indexes,omitempty"`
	// LatencyInfo is the information about latency, such min, max, p50, p90 and p99.
	LatencyInfo LatencyInfo `protobuf:"bytes,31,opt,name=latency_info,json=latencyInfo" json:"latency_info"`
	// last_error_code is the last error code for a failed statement, if it exists.
	LastErrorCode string `protobuf:"bytes,32,opt,name=last_error_code,json=lastErrorCode" json:"last_error_code"`
	// failure_count is the count of failed executions for a given statement fingerprint.
	FailureCount int64 `protobuf:"varint,33,opt,name=failure_count,json=failureCount" json:"failure_count"`
}

func (m *StatementStatistics) Reset()         { *m = StatementStatistics{} }
func (m *StatementStatistics) String() string { return proto.CompactTextString(m) }
func (*StatementStatistics) ProtoMessage()    {}
func (*StatementStatistics) Descriptor() ([]byte, []int) {
	return fileDescriptor_a882f4627f6c3313, []int{0}
}
func (m *StatementStatistics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementStatistics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatementStatistics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementStatistics.Merge(m, src)
}
func (m *StatementStatistics) XXX_Size() int {
	return m.Size()
}
func (m *StatementStatistics) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementStatistics.DiscardUnknown(m)
}

var xxx_messageInfo_StatementStatistics proto.InternalMessageInfo

type TransactionStatistics struct {
	// Count is the total number of times this transaction was executed
	// since the beginning of the reporting period.
	Count int64 `protobuf:"varint,1,opt,name=count" json:"count"`
	// MaxRetries collects the maximum observed number of automatic
	// retries in the reporting period.
	MaxRetries int64 `protobuf:"varint,2,opt,name=max_retries,json=maxRetries" json:"max_retries"`
	// NumRows collects the total number of rows returned, observed or affected
	// across all statements.
	NumRows NumericStat `protobuf:"bytes,3,opt,name=num_rows,json=numRows" json:"num_rows"`
	// ServiceLat is the time in seconds to service the transaction, from the time a
	// transaction was received to end of execution.
	ServiceLat NumericStat `protobuf:"bytes,4,opt,name=service_lat,json=serviceLat" json:"service_lat"`
	// RetryLat is the amount of time in seconds spent retrying the transaction.
	RetryLat NumericStat `protobuf:"bytes,5,opt,name=retry_lat,json=retryLat" json:"retry_lat"`
	// CommitLat is the amount of time in seconds required to commit the transaction after
	// all statement operations have been applied.
	CommitLat NumericStat `protobuf:"bytes,6,opt,name=commit_lat,json=commitLat" json:"commit_lat"`
	// IdleLat is the cumulative amount of time spent in seconds waiting for
	// the client to send statements while holding the transaction open.
	IdleLat NumericStat `protobuf:"bytes,11,opt,name=idle_lat,json=idleLat" json:"idle_lat"`
	// BytesRead collects the number of bytes read from disk.
	BytesRead NumericStat `protobuf:"bytes,7,opt,name=bytes_read,json=bytesRead" json:"bytes_read"`
	// RowsRead collects the number of rows read from disk.
	RowsRead NumericStat `protobuf:"bytes,8,opt,name=rows_read,json=rowsRead" json:"rows_read"`
	// ExecStats are the execution statistics for this transaction, i.e. an
	// aggregation of all its statements' execution statistics. These statistics
	// are sampled.
	ExecStats ExecStats `protobuf:"bytes,9,opt,name=exec_stats,json=execStats" json:"exec_stats"`
	// RowsWritten collects the number of rows written to disk.
	RowsWritten NumericStat `protobuf:"bytes,10,opt,name=rows_written,json=rowsWritten" json:"rows_written"`
}

func (m *TransactionStatistics) Reset()         { *m = TransactionStatistics{} }
func (m *TransactionStatistics) String() string { return proto.CompactTextString(m) }
func (*TransactionStatistics) ProtoMessage()    {}
func (*TransactionStatistics) Descriptor() ([]byte, []int) {
	return fileDescriptor_a882f4627f6c3313, []int{1}
}
func (m *TransactionStatistics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionStatistics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TransactionStatistics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionStatistics.Merge(m, src)
}
func (m *TransactionStatistics) XXX_Size() int {
	return m.Size()
}
func (m *TransactionStatistics) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionStatistics.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionStatistics proto.InternalMessageInfo

type SensitiveInfo struct {
	// LastErr collects the last error encountered.
	// It is only reported once it's been redacted.
	// See also: https://github.com/cockroachdb/cockroach/issues/53191
	LastErr string `protobuf:"bytes,1,opt,name=last_err,json=lastErr" json:"last_err"`
	// MostRecentPlanDescription is a serialized representation of the logical plan most recently captured for this query.
	MostRecentPlanDescription ExplainTreePlanNode `protobuf:"bytes,2,opt,name=most_recent_plan_description,json=mostRecentPlanDescription" json:"most_recent_plan_description"`
	// Timestamp is the time at which the logical plan was last sampled.
	MostRecentPlanTimestamp time.Time `protobuf:"bytes,3,opt,name=most_recent_plan_timestamp,json=mostRecentPlanTimestamp,stdtime" json:"most_recent_plan_timestamp"`
}

func (m *SensitiveInfo) Reset()         { *m = SensitiveInfo{} }
func (m *SensitiveInfo) String() string { return proto.CompactTextString(m) }
func (*SensitiveInfo) ProtoMessage()    {}
func (*SensitiveInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a882f4627f6c3313, []int{2}
}
func (m *SensitiveInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SensitiveInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SensitiveInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SensitiveInfo.Merge(m, src)
}
func (m *SensitiveInfo) XXX_Size() int {
	return m.Size()
}
func (m *SensitiveInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SensitiveInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SensitiveInfo proto.InternalMessageInfo

// N.B. When this changes, make sure to update (*NumericStat).AlmostEqual
// in app_stats.go.
type NumericStat struct {
	// NumericStat keeps track of two running values --- the running mean and
	// the running sum of squared differences from the mean. Using this along
	// with the total count of values, we can compute variance using Welford's
	// method. This is more reliable than keeping track of the sum of
	// squared values, which is liable to overflow. See
	// https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Online_algorithm
	Mean         float64 `protobuf:"fixed64,1,opt,name=mean" json:"mean"`
	SquaredDiffs float64 `protobuf:"fixed64,2,opt,name=squared_diffs,json=squaredDiffs" json:"squared_diffs"`
}

func (m *NumericStat) Reset()         { *m = NumericStat{} }
func (m *NumericStat) String() string { return proto.CompactTextString(m) }
func (*NumericStat) ProtoMessage()    {}
func (*NumericStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_a882f4627f6c3313, []int{3}
}
func (m *NumericStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NumericStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NumericStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NumericStat.Merge(m, src)
}
func (m *NumericStat) XXX_Size() int {
	return m.Size()
}
func (m *NumericStat) XXX_DiscardUnknown() {
	xxx_messageInfo_NumericStat.DiscardUnknown(m)
}

var xxx_messageInfo_NumericStat proto.InternalMessageInfo

type StatementStatisticsKey struct {
	Query                    string                   `protobuf:"bytes,1,opt,name=query" json:"query"`
	App                      string                   `protobuf:"bytes,2,opt,name=app" json:"app"`
	DistSQL                  bool                     `protobuf:"varint,3,opt,name=distSQL" json:"distSQL"`
	ImplicitTxn              bool                     `protobuf:"varint,6,opt,name=implicit_txn,json=implicitTxn" json:"implicit_txn"`
	Vec                      bool                     `protobuf:"varint,7,opt,name=vec" json:"vec"`
	FullScan                 bool                     `protobuf:"varint,8,opt,name=full_scan,json=fullScan" json:"full_scan"`
	Database                 string                   `protobuf:"bytes,9,opt,name=database" json:"database"`
	PlanHash                 uint64                   `protobuf:"varint,10,opt,name=plan_hash,json=planHash" json:"plan_hash"`
	QuerySummary             string                   `protobuf:"bytes,12,opt,name=query_summary,json=querySummary" json:"query_summary"`
	TransactionFingerprintID TransactionFingerprintID `protobuf:"varint,11,opt,name=transaction_fingerprint_id,json=transactionFingerprintId,casttype=TransactionFingerprintID" json:"transaction_fingerprint_id"`
}

func (m *StatementStatisticsKey) Reset()         { *m = StatementStatisticsKey{} }
func (m *StatementStatisticsKey) String() string { return proto.CompactTextString(m) }
func (*StatementStatisticsKey) ProtoMessage()    {}
func (*StatementStatisticsKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_a882f4627f6c3313, []int{4}
}
func (m *StatementStatisticsKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementStatisticsKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatementStatisticsKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementStatisticsKey.Merge(m, src)
}
func (m *StatementStatisticsKey) XXX_Size() int {
	return m.Size()
}
func (m *StatementStatisticsKey) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementStatisticsKey.DiscardUnknown(m)
}

var xxx_messageInfo_StatementStatisticsKey proto.InternalMessageInfo

type AggregatedStatementMetadata struct {
	Query string `protobuf:"bytes,1,opt,name=query" json:"query"`
	// Formatted query is the same value of query. It used to be formatted with prettify_statement,
	// but until that function is improved (#91197), it should not be used.
	FormattedQuery string   `protobuf:"bytes,2,opt,name=formatted_query,json=formattedQuery" json:"formatted_query"`
	QuerySummary   string   `protobuf:"bytes,3,opt,name=query_summary,json=querySummary" json:"query_summary"`
	StmtType       string   `protobuf:"bytes,4,opt,name=stmt_type,json=stmtType" json:"stmt_type"`
	AppNames       []string `protobuf:"bytes,5,rep,name=app_names,json=appNames" json:"app_names,omitempty"`
	Databases      []string `protobuf:"bytes,6,rep,name=databases" json:"databases,omitempty"`
	ImplicitTxn    bool     `protobuf:"varint,7,opt,name=implicit_txn,json=implicitTxn" json:"implicit_txn"`
	DistSQLCount   int64    `protobuf:"varint,8,opt,name=dist_sql_count,json=distSqlCount" json:"dist_sql_count"`
	FullScanCount  int64    `protobuf:"varint,10,opt,name=full_scan_count,json=fullScanCount" json:"full_scan_count"`
	VecCount       int64    `protobuf:"varint,11,opt,name=vec_count,json=vecCount" json:"vec_count"`
	TotalCount     int64    `protobuf:"varint,12,opt,name=total_count,json=totalCount" json:"total_count"`
	FingerprintID  string   `protobuf:"bytes,13,opt,name=fingerprint_id,json=fingerprintId" json:"fingerprint_id"`
}

func (m *AggregatedStatementMetadata) Reset()         { *m = AggregatedStatementMetadata{} }
func (m *AggregatedStatementMetadata) String() string { return proto.CompactTextString(m) }
func (*AggregatedStatementMetadata) ProtoMessage()    {}
func (*AggregatedStatementMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_a882f4627f6c3313, []int{5}
}
func (m *AggregatedStatementMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregatedStatementMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AggregatedStatementMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregatedStatementMetadata.Merge(m, src)
}
func (m *AggregatedStatementMetadata) XXX_Size() int {
	return m.Size()
}
func (m *AggregatedStatementMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregatedStatementMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_AggregatedStatementMetadata proto.InternalMessageInfo

// CollectedStatementStatistics wraps collected timings and metadata for some
// query's execution.
type CollectedStatementStatistics struct {
	// ID is a hash of the statement key (query fingerprint, failure status,
	// implicit txn or not) which can be used to identify the statement
	// for instance in transaction statistics.
	ID           StmtFingerprintID      `protobuf:"varint,3,opt,name=id,casttype=StmtFingerprintID" json:"id"`
	Key          StatementStatisticsKey `protobuf:"bytes,1,opt,name=key" json:"key"`
	Stats        StatementStatistics    `protobuf:"bytes,2,opt,name=stats" json:"stats"`
	AggregatedTs time.Time              `protobuf:"bytes,4,opt,name=aggregated_ts,json=aggregatedTs,stdtime" json:"aggregated_ts"`
	// The aggregation duration.
	AggregationInterval time.Duration `protobuf:"bytes,5,opt,name=aggregation_interval,json=aggregationInterval,stdduration" json:"aggregation_interval"`
}

func (m *CollectedStatementStatistics) Reset()         { *m = CollectedStatementStatistics{} }
func (m *CollectedStatementStatistics) String() string { return proto.CompactTextString(m) }
func (*CollectedStatementStatistics) ProtoMessage()    {}
func (*CollectedStatementStatistics) Descriptor() ([]byte, []int) {
	return fileDescriptor_a882f4627f6c3313, []int{6}
}
func (m *CollectedStatementStatistics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectedStatementStatistics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CollectedStatementStatistics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectedStatementStatistics.Merge(m, src)
}
func (m *CollectedStatementStatistics) XXX_Size() int {
	return m.Size()
}
func (m *CollectedStatementStatistics) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectedStatementStatistics.DiscardUnknown(m)
}

var xxx_messageInfo_CollectedStatementStatistics proto.InternalMessageInfo

// CollectedTransactionStatistics wraps collected timings and metadata for some
// transaction executions.
type CollectedTransactionStatistics struct {
	// StatementFingerprintIDs is the fingerprint IDs of the statements which this
	// transaction comprises, in order.
	StatementFingerprintIDs []StmtFingerprintID `protobuf:"varint,1,rep,name=statement_fingerprint_ids,json=statementFingerprintIds,casttype=StmtFingerprintID" json:"statement_fingerprint_ids,omitempty"`
	// App is the name of the app which executed the transaction.
	App                      string                   `protobuf:"bytes,2,opt,name=app" json:"app"`
	Stats                    TransactionStatistics    `protobuf:"bytes,3,opt,name=stats" json:"stats"`
	AggregatedTs             time.Time                `protobuf:"bytes,4,opt,name=aggregated_ts,json=aggregatedTs,stdtime" json:"aggregated_ts"`
	TransactionFingerprintID TransactionFingerprintID `protobuf:"varint,5,opt,name=transaction_fingerprint_id,json=transactionFingerprintId,casttype=TransactionFingerprintID" json:"transaction_fingerprint_id"`
	// The aggregation duration.
	AggregationInterval time.Duration `protobuf:"bytes,6,opt,name=aggregation_interval,json=aggregationInterval,stdduration" json:"aggregation_interval"`
}

func (m *CollectedTransactionStatistics) Reset()         { *m = CollectedTransactionStatistics{} }
func (m *CollectedTransactionStatistics) String() string { return proto.CompactTextString(m) }
func (*CollectedTransactionStatistics) ProtoMessage()    {}
func (*CollectedTransactionStatistics) Descriptor() ([]byte, []int) {
	return fileDescriptor_a882f4627f6c3313, []int{7}
}
func (m *CollectedTransactionStatistics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectedTransactionStatistics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CollectedTransactionStatistics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectedTransactionStatistics.Merge(m, src)
}
func (m *CollectedTransactionStatistics) XXX_Size() int {
	return m.Size()
}
func (m *CollectedTransactionStatistics) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectedTransactionStatistics.DiscardUnknown(m)
}

var xxx_messageInfo_CollectedTransactionStatistics proto.InternalMessageInfo

// ExplainTreePlanNode is a serialized representation of an EXPLAIN tree for a logical plan.
type ExplainTreePlanNode struct {
	// Name is the type of node this is, e.g. "scan" or "index-join".
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	// Attrs are attributes of this plan node.
	// Often there are many attributes with the same key, e.g. "render".
	Attrs []*ExplainTreePlanNode_Attr `protobuf:"bytes,2,rep,name=attrs" json:"attrs,omitempty"`
	// Children are the nodes that feed into this one, e.g. two scans for a join.
	Children []*ExplainTreePlanNode `protobuf:"bytes,3,rep,name=children" json:"children,omitempty"`
}

func (m *ExplainTreePlanNode) Reset()         { *m = ExplainTreePlanNode{} }
func (m *ExplainTreePlanNode) String() string { return proto.CompactTextString(m) }
func (*ExplainTreePlanNode) ProtoMessage()    {}
func (*ExplainTreePlanNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_a882f4627f6c3313, []int{8}
}
func (m *ExplainTreePlanNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExplainTreePlanNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExplainTreePlanNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExplainTreePlanNode.Merge(m, src)
}
func (m *ExplainTreePlanNode) XXX_Size() int {
	return m.Size()
}
func (m *ExplainTreePlanNode) XXX_DiscardUnknown() {
	xxx_messageInfo_ExplainTreePlanNode.DiscardUnknown(m)
}

var xxx_messageInfo_ExplainTreePlanNode proto.InternalMessageInfo

type ExplainTreePlanNode_Attr struct {
	Key   string `protobuf:"bytes,1,opt,name=key" json:"key"`
	Value string `protobuf:"bytes,2,opt,name=value" json:"value"`
}

func (m *ExplainTreePlanNode_Attr) Reset()         { *m = ExplainTreePlanNode_Attr{} }
func (m *ExplainTreePlanNode_Attr) String() string { return proto.CompactTextString(m) }
func (*ExplainTreePlanNode_Attr) ProtoMessage()    {}
func (*ExplainTreePlanNode_Attr) Descriptor() ([]byte, []int) {
	return fileDescriptor_a882f4627f6c3313, []int{8, 0}
}
func (m *ExplainTreePlanNode_Attr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExplainTreePlanNode_Attr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExplainTreePlanNode_Attr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExplainTreePlanNode_Attr.Merge(m, src)
}
func (m *ExplainTreePlanNode_Attr) XXX_Size() int {
	return m.Size()
}
func (m *ExplainTreePlanNode_Attr) XXX_DiscardUnknown() {
	xxx_messageInfo_ExplainTreePlanNode_Attr.DiscardUnknown(m)
}

var xxx_messageInfo_ExplainTreePlanNode_Attr proto.InternalMessageInfo

// TxnStats contains statistics about transactions of one application.
// N.B. When field are added to this struct, make sure to updated
// (*TxnStats).Add in app_stats.go.
type TxnStats struct {
	TxnCount       int64       `protobuf:"varint,1,opt,name=txn_count,json=txnCount" json:"txn_count"`
	TxnTimeSec     NumericStat `protobuf:"bytes,2,opt,name=txn_time_sec,json=txnTimeSec" json:"txn_time_sec"`
	CommittedCount int64       `protobuf:"varint,3,opt,name=committed_count,json=committedCount" json:"committed_count"`
	ImplicitCount  int64       `protobuf:"varint,4,opt,name=implicit_count,json=implicitCount" json:"implicit_count"`
}

func (m *TxnStats) Reset()         { *m = TxnStats{} }
func (m *TxnStats) String() string { return proto.CompactTextString(m) }
func (*TxnStats) ProtoMessage()    {}
func (*TxnStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_a882f4627f6c3313, []int{9}
}
func (m *TxnStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TxnStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnStats.Merge(m, src)
}
func (m *TxnStats) XXX_Size() int {
	return m.Size()
}
func (m *TxnStats) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnStats.DiscardUnknown(m)
}

var xxx_messageInfo_TxnStats proto.InternalMessageInfo

// ExecStats contains execution statistics that apply to both statements
// and transactions. These stats are currently collected using a sampling
// approach.
// When adding additional fields to this message, please make the corresponding
// changes to 'SampledExecStats' in telemetry.proto to keep the two messages in sync
// with respect to the information stored.
type ExecStats struct {
	// Count keeps track of how many times execution stats were recorded. This is
	// not necessarily equal to the number of times a statement/transaction was
	// run.
	Count int64 `protobuf:"varint,1,opt,name=count" json:"count"`
	// NetworkBytes collects the number of bytes sent over the network.
	NetworkBytes NumericStat `protobuf:"bytes,2,opt,name=network_bytes,json=networkBytes" json:"network_bytes"`
	// MaxMemUsage collects the maximum memory usage that occurred on a node.
	MaxMemUsage NumericStat `protobuf:"bytes,3,opt,name=max_mem_usage,json=maxMemUsage" json:"max_mem_usage"`
	// ContentionTime collects the time in seconds this statement spent contending.
	ContentionTime NumericStat `protobuf:"bytes,4,opt,name=contention_time,json=contentionTime" json:"contention_time"`
	// NetworkMessages collects the number of messages that were sent over the
	// network.
	NetworkMessages NumericStat `protobuf:"bytes,5,opt,name=network_messages,json=networkMessages" json:"network_messages"`
	// MaxDiskUsage collects the maximum temporary disk usage that occurred. This
	// is set in cases where a query had to spill to disk, e.g. when performing a
	// large sort where not all of the tuples fit in memory.
	MaxDiskUsage NumericStat `protobuf:"bytes,6,opt,name=max_disk_usage,json=maxDiskUsage" json:"max_disk_usage"`
	// CPUSQLNanos collects the cumulative CPU time spent executing SQL operations in
	// nanoseconds. Currently, it is only collected for statements without
	// mutations that have a vectorized plan.
	CPUSQLNanos NumericStat `protobuf:"bytes,7,opt,name=cpu_sql_nanos,json=cpuSqlNanos" json:"cpu_sql_nanos"`
	// Internal storage iteration statistics.
	MVCCIteratorStats MVCCIteratorStats `protobuf:"bytes,8,opt,name=mvcc_iterator_stats,json=mvccIteratorStats" json:"mvcc_iterator_stats"`
}

func (m *ExecStats) Reset()         { *m = ExecStats{} }
func (m *ExecStats) String() string { return proto.CompactTextString(m) }
func (*ExecStats) ProtoMessage()    {}
func (*ExecStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_a882f4627f6c3313, []int{10}
}
func (m *ExecStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ExecStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecStats.Merge(m, src)
}
func (m *ExecStats) XXX_Size() int {
	return m.Size()
}
func (m *ExecStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecStats.DiscardUnknown(m)
}

var xxx_messageInfo_ExecStats proto.InternalMessageInfo

// LatencyInfo contains more details about the latency.
type LatencyInfo struct {
	// Min is the minimum time in seconds spent executing the fingerprint.
	Min float64 `protobuf:"fixed64,1,opt,name=min" json:"min"`
	// Max is the maximum time in seconds spent executing the fingerprint.
	Max float64 `protobuf:"fixed64,2,opt,name=max" json:"max"`
	// P50 is the 50 Percentile in seconds for the fingerprint.
	P50 float64 `protobuf:"fixed64,3,opt,name=p50" json:"p50"`
	// P90 is the 90 Percentile in seconds for the fingerprint.
	P90 float64 `protobuf:"fixed64,4,opt,name=p90" json:"p90"`
	// P99 is the 99 Percentile in seconds for the fingerprint.
	P99 float64 `protobuf:"fixed64,5,opt,name=p99" json:"p99"`
}

func (m *LatencyInfo) Reset()         { *m = LatencyInfo{} }
func (m *LatencyInfo) String() string { return proto.CompactTextString(m) }
func (*LatencyInfo) ProtoMessage()    {}
func (*LatencyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a882f4627f6c3313, []int{11}
}
func (m *LatencyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LatencyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LatencyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LatencyInfo.Merge(m, src)
}
func (m *LatencyInfo) XXX_Size() int {
	return m.Size()
}
func (m *LatencyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LatencyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LatencyInfo proto.InternalMessageInfo

// Internal storage iteration statistics.
type MVCCIteratorStats struct {
	// StepCount collects the number of times the iterator moved forward or backward over the
	// DB's underlying storage keyspace.
	// For details, see pkg/storage/engine.go and pkg/sql/opt/exec/factory.go.
	StepCount NumericStat `protobuf:"bytes,1,opt,name=step_count,json=stepCount" json:"step_count"`
	// StepCountInternal collects the number of times the iterator moved forward or backward
	// over LSM internal keys.
	// For details, see pkg/storage/engine.go and pkg/sql/opt/exec/factory.go.
	StepCountInternal NumericStat `protobuf:"bytes,2,opt,name=step_count_internal,json=stepCountInternal" json:"step_count_internal"`
	// SeekCount collects the number of times the iterator moved to a specific key/value pair
	// in the DB's underlying storage keyspace.
	// For details, see pkg/storage/engine.go and pkg/sql/opt/exec/factory.go.
	SeekCount NumericStat `protobuf:"bytes,3,opt,name=seek_count,json=seekCount" json:"seek_count"`
	// SeekCountInternal collects the number of times the iterator moved to a specific LSM
	// internal key.
	// For details, see pkg/storage/engine.go and pkg/sql/opt/exec/factory.go.
	SeekCountInternal NumericStat `protobuf:"bytes,4,opt,name=seek_count_internal,json=seekCountInternal" json:"seek_count_internal"`
	// BlockBytes collects the bytes in the loaded SSTable data blocks.
	// For details, see pebble.InternalIteratorStats.
	BlockBytes NumericStat `protobuf:"bytes,5,opt,name=block_bytes,json=blockBytes" json:"block_bytes"`
	// BlockBytesInCache collects the subset of BlockBytes in the block cache.
	// For details, see pebble.InternalIteratorStats.
	BlockBytesInCache NumericStat `protobuf:"bytes,6,opt,name=block_bytes_in_cache,json=blockBytesInCache" json:"block_bytes_in_cache"`
	// KeyBytes collects the bytes in keys that were iterated over.
	// For details, see pebble.InternalIteratorStats.
	KeyBytes NumericStat `protobuf:"bytes,7,opt,name=key_bytes,json=keyBytes" json:"key_bytes"`
	// ValueBytes collects the bytes in values that were iterated over.
	// For details, see pebble.InternalIteratorStats.
	ValueBytes NumericStat `protobuf:"bytes,8,opt,name=value_bytes,json=valueBytes" json:"value_bytes"`
	// PointCount collects the count of point keys iterated over.
	// For details, see pebble.InternalIteratorStats.
	PointCount NumericStat `protobuf:"bytes,9,opt,name=point_count,json=pointCount" json:"point_count"`
	// PointsCoveredByRangeTombstones collects the count of point keys that were iterated over that
	// were covered by range tombstones.
	// For details, see pebble.InternalIteratorStats and
	// https://github.com/cockroachdb/cockroach/blob/master/docs/tech-notes/mvcc-range-tombstones.md.
	PointsCoveredByRangeTombstones NumericStat `protobuf:"bytes,10,opt,name=points_covered_by_range_tombstones,json=pointsCoveredByRangeTombstones" json:"points_covered_by_range_tombstones"`
	// RangeKeyCount collects the count of range keys encountered during iteration.
	// For details, see pebble.RangeKeyIteratorStats and
	// https://github.com/cockroachdb/cockroach/blob/master/docs/tech-notes/mvcc-range-tombstones.md.
	RangeKeyCount NumericStat `protobuf:"bytes,11,opt,name=range_key_count,json=rangeKeyCount" json:"range_key_count"`
	// RangeKeyContainedPoints collects the count of point keys encountered within the bounds of
	// a range key.
	// For details, see pebble.RangeKeyIteratorStats and
	// https://github.com/cockroachdb/cockroach/blob/master/docs/tech-notes/mvcc-range-tombstones.md.
	RangeKeyContainedPoints NumericStat `protobuf:"bytes,12,opt,name=range_key_contained_points,json=rangeKeyContainedPoints" json:"range_key_contained_points"`
	// RangeKeySkippedPoints collects the count of the subset of ContainedPoints point keys that
	// were skipped during iteration due to range-key masking.
	// For details, see pkg/storage/engine.go, pebble.RangeKeyIteratorStats, and
	// https://github.com/cockroachdb/cockroach/blob/master/docs/tech-notes/mvcc-range-tombstones.md.
	RangeKeySkippedPoints NumericStat `protobuf:"bytes,13,opt,name=range_key_skipped_points,json=rangeKeySkippedPoints" json:"range_key_skipped_points"`
}

func (m *MVCCIteratorStats) Reset()         { *m = MVCCIteratorStats{} }
func (m *MVCCIteratorStats) String() string { return proto.CompactTextString(m) }
func (*MVCCIteratorStats) ProtoMessage()    {}
func (*MVCCIteratorStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_a882f4627f6c3313, []int{12}
}
func (m *MVCCIteratorStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MVCCIteratorStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MVCCIteratorStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MVCCIteratorStats.Merge(m, src)
}
func (m *MVCCIteratorStats) XXX_Size() int {
	return m.Size()
}
func (m *MVCCIteratorStats) XXX_DiscardUnknown() {
	xxx_messageInfo_MVCCIteratorStats.DiscardUnknown(m)
}

var xxx_messageInfo_MVCCIteratorStats proto.InternalMessageInfo

func init() {
	proto.RegisterType((*StatementStatistics)(nil), "cockroach.sql.StatementStatistics")
	proto.RegisterType((*TransactionStatistics)(nil), "cockroach.sql.TransactionStatistics")
	proto.RegisterType((*SensitiveInfo)(nil), "cockroach.sql.SensitiveInfo")
	proto.RegisterType((*NumericStat)(nil), "cockroach.sql.NumericStat")
	proto.RegisterType((*StatementStatisticsKey)(nil), "cockroach.sql.StatementStatisticsKey")
	proto.RegisterType((*AggregatedStatementMetadata)(nil), "cockroach.sql.AggregatedStatementMetadata")
	proto.RegisterType((*CollectedStatementStatistics)(nil), "cockroach.sql.CollectedStatementStatistics")
	proto.RegisterType((*CollectedTransactionStatistics)(nil), "cockroach.sql.CollectedTransactionStatistics")
	proto.RegisterType((*ExplainTreePlanNode)(nil), "cockroach.sql.ExplainTreePlanNode")
	proto.RegisterType((*ExplainTreePlanNode_Attr)(nil), "cockroach.sql.ExplainTreePlanNode.Attr")
	proto.RegisterType((*TxnStats)(nil), "cockroach.sql.TxnStats")
	proto.RegisterType((*ExecStats)(nil), "cockroach.sql.ExecStats")
	proto.RegisterType((*LatencyInfo)(nil), "cockroach.sql.LatencyInfo")
	proto.RegisterType((*MVCCIteratorStats)(nil), "cockroach.sql.MVCCIteratorStats")
}

func init() { proto.RegisterFile("sql/appstatspb/app_stats.proto", fileDescriptor_a882f4627f6c3313) }

var fileDescriptor_a882f4627f6c3313 = []byte{
	// 2295 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x59, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0x37, 0xc5, 0x95, 0xb5, 0x7c, 0x24, 0xf5, 0xb1, 0x92, 0xec, 0xb5, 0xec, 0x50, 0x32, 0xd1,
	0x20, 0x6a, 0x9b, 0x4a, 0x86, 0xd3, 0x1c, 0x9c, 0xc4, 0x49, 0xf4, 0xe1, 0x34, 0x92, 0x65, 0xc3,
	0x26, 0xe5, 0x14, 0x2d, 0x50, 0x2c, 0x46, 0xbb, 0x23, 0x6a, 0xc1, 0xdd, 0xd9, 0xd5, 0xcc, 0x50,
	0x26, 0x7b, 0xee, 0xc7, 0x35, 0xe8, 0xa9, 0x40, 0x2f, 0xfd, 0x73, 0x7c, 0x29, 0x90, 0x53, 0x91,
	0x93, 0xdb, 0xca, 0x28, 0xd0, 0x6b, 0x2f, 0x3d, 0xf4, 0x14, 0xbc, 0x99, 0xdd, 0xe5, 0x92, 0xa2,
	0x9d, 0x55, 0x82, 0xdc, 0xb8, 0xef, 0xbd, 0xdf, 0x6f, 0xe7, 0xe3, 0xbd, 0xdf, 0xbc, 0x59, 0x42,
	0x43, 0x9c, 0x06, 0x9b, 0x24, 0x8e, 0x85, 0x24, 0x52, 0xc4, 0x47, 0xf8, 0xd3, 0x51, 0xbf, 0x37,
	0x62, 0x1e, 0xc9, 0xc8, 0xaa, 0xbb, 0x91, 0xdb, 0xe5, 0x11, 0x71, 0x4f, 0x36, 0xc4, 0x69, 0xb0,
	0xb2, 0xd4, 0x89, 0x3a, 0x91, 0xf2, 0x6c, 0xe2, 0x2f, 0x1d, 0xb4, 0xb2, 0xda, 0x89, 0xa2, 0x4e,
	0x40, 0x37, 0xd5, 0xd3, 0x51, 0xef, 0x78, 0x53, 0xfa, 0x21, 0x15, 0x92, 0x84, 0x71, 0x12, 0xd0,
	0x18, 0x0f, 0xf0, 0x7a, 0x9c, 0x48, 0x3f, 0x62, 0xda, 0xdf, 0xfc, 0x77, 0x15, 0x16, 0xdb, 0x92,
	0x48, 0x1a, 0x52, 0x26, 0xf1, 0x87, 0x2f, 0xa4, 0xef, 0x0a, 0x6b, 0x05, 0xa6, 0xdd, 0xa8, 0xc7,
	0xa4, 0x5d, 0x5a, 0x2b, 0xad, 0x97, 0xb7, 0x8d, 0x17, 0x2f, 0x57, 0xaf, 0xb4, 0xb4, 0xc9, 0xfa,
	0x39, 0x2c, 0x1e, 0xfb, 0x5c, 0x48, 0x87, 0x48, 0x49, 0xc3, 0x58, 0x3a, 0x3a, 0x72, 0x2a, 0x17,
	0xb9, 0xa0, 0x02, 0xb6, 0xb4, 0x7f, 0x47, 0xa1, 0xde, 0x86, 0x6a, 0x48, 0xfa, 0x0e, 0xa7, 0x92,
	0xfb, 0x54, 0xd8, 0xe5, 0x5c, 0x34, 0x84, 0xa4, 0xdf, 0xd2, 0x76, 0xeb, 0x5d, 0x98, 0x0b, 0x68,
	0x87, 0xb8, 0x03, 0x27, 0x20, 0x42, 0x3a, 0x94, 0x73, 0xdb, 0x58, 0x2b, 0xad, 0x57, 0x92, 0xd0,
	0xba, 0x76, 0x1e, 0x10, 0x21, 0x1f, 0x70, 0x6e, 0xdd, 0x07, 0x7b, 0x2c, 0xda, 0xe1, 0xd4, 0x23,
	0xae, 0xa4, 0x9e, 0x5d, 0xcd, 0xc1, 0x96, 0x47, 0x60, 0xad, 0x24, 0xc4, 0xfa, 0x10, 0x4c, 0xd6,
	0x0b, 0x1d, 0x1e, 0x3d, 0x17, 0xf6, 0xf4, 0x5a, 0x69, 0xbd, 0x7a, 0x77, 0x65, 0x63, 0x64, 0xd9,
	0x37, 0x1e, 0xf7, 0x42, 0xca, 0x7d, 0x17, 0x57, 0x26, 0xa1, 0x9a, 0x61, 0xbd, 0xb0, 0x15, 0x3d,
	0x17, 0x08, 0xf6, 0xbd, 0x80, 0x3a, 0x01, 0x91, 0xf6, 0xad, 0xa2, 0x60, 0x44, 0x1c, 0x10, 0x69,
	0xdd, 0x87, 0x4a, 0x4c, 0xb8, 0xd0, 0xe8, 0xab, 0x05, 0xd1, 0xa6, 0x82, 0x20, 0xfc, 0x43, 0x30,
	0xe3, 0x80, 0x30, 0x85, 0x9e, 0x29, 0xfa, 0x6e, 0x44, 0x20, 0xf8, 0x1e, 0xcc, 0xf0, 0x9e, 0xc6,
	0x9a, 0x05, 0xb1, 0x57, 0x79, 0x4f, 0x41, 0xb7, 0xa0, 0x2a, 0x28, 0x3f, 0xf3, 0x5d, 0x3d, 0xf0,
	0x4a, 0x41, 0x38, 0x24, 0x20, 0xa4, 0xd8, 0x81, 0x5a, 0x74, 0x46, 0xf9, 0x09, 0x25, 0x9e, 0xe2,
	0x80, 0x82, 0x1c, 0xd5, 0x14, 0x85, 0x24, 0x7b, 0x30, 0x2b, 0x28, 0x13, 0xbe, 0xf4, 0xcf, 0xa8,
	0xe3, 0xb3, 0xe3, 0xc8, 0xae, 0x29, 0x9a, 0x5b, 0x63, 0x34, 0xed, 0x34, 0x68, 0x8f, 0x1d, 0x47,
	0x69, 0x0a, 0x89, 0xbc, 0xd1, 0xfa, 0x04, 0xe0, 0x68, 0x20, 0xa9, 0x70, 0x38, 0x25, 0x9e, 0x3d,
	0x57, 0x70, 0x34, 0x15, 0x85, 0x69, 0x51, 0xe2, 0xe1, 0x56, 0x62, 0x02, 0x69, 0xfc, 0x7c, 0xd1,
	0xad, 0x44, 0x88, 0x82, 0xef, 0x40, 0x4d, 0xc1, 0x9f, 0x73, 0x5f, 0x4a, 0xca, 0xec, 0x1b, 0x45,
	0xd7, 0x03, 0x51, 0xbf, 0xd4, 0x20, 0xeb, 0x3e, 0x00, 0xed, 0x53, 0x57, 0x0b, 0x88, 0xbd, 0xac,
	0x28, 0xec, 0x31, 0x8a, 0x07, 0x7d, 0xaa, 0xf0, 0x22, 0x9d, 0x02, 0x4d, 0x0d, 0xd6, 0x4f, 0xc0,
	0x14, 0xa7, 0x81, 0x23, 0x07, 0x31, 0xb5, 0xaf, 0xa9, 0xb2, 0x99, 0xc3, 0x90, 0xf3, 0x97, 0xab,
	0x33, 0xed, 0xa7, 0x07, 0x87, 0x83, 0x98, 0xb6, 0x66, 0xc4, 0x69, 0x80, 0x3f, 0xac, 0x43, 0x58,
	0xd4, 0xb5, 0x86, 0xef, 0xcb, 0xe4, 0xc6, 0xbe, 0x9e, 0x0c, 0x5b, 0xeb, 0xcd, 0x46, 0xaa, 0x37,
	0x1b, 0x87, 0x69, 0xc4, 0xb6, 0x89, 0x94, 0x5f, 0xfe, 0x63, 0xb5, 0xd4, 0x5a, 0x40, 0x02, 0x1c,
	0x4e, 0xe6, 0xb4, 0x96, 0x60, 0x9a, 0x45, 0x1e, 0x15, 0xb6, 0xbd, 0x56, 0x5e, 0x2f, 0xb7, 0xf4,
	0x83, 0x65, 0xc3, 0x0c, 0xa7, 0x1d, 0x3f, 0x62, 0xc2, 0x7e, 0x6b, 0xad, 0xbc, 0x5e, 0x69, 0xa5,
	0x8f, 0xd6, 0x5b, 0x00, 0xaa, 0x00, 0x3a, 0xbe, 0x90, 0xc2, 0x5e, 0x51, 0xce, 0x0a, 0x5a, 0x7e,
	0x81, 0x06, 0xeb, 0x3d, 0x58, 0xf6, 0x99, 0x47, 0x51, 0x6e, 0xdc, 0x28, 0x0c, 0x29, 0xf3, 0x94,
	0xe8, 0x09, 0xfb, 0xa6, 0x8a, 0x5c, 0x52, 0xce, 0xd6, 0xa8, 0x0f, 0xdf, 0xa6, 0xec, 0x54, 0xd8,
	0x0d, 0xfd, 0xb6, 0xe4, 0x11, 0xf7, 0x28, 0x20, 0x92, 0x32, 0x77, 0xa0, 0x93, 0x6d, 0x75, 0xe2,
	0x1e, 0x1d, 0xe8, 0x90, 0x5c, 0xaa, 0x55, 0x83, 0xa1, 0x49, 0x29, 0x5b, 0x22, 0x52, 0x11, 0x77,
	0xdc, 0xc8, 0xa3, 0xf6, 0xda, 0x88, 0xb2, 0x69, 0x71, 0x8a, 0xf8, 0x4e, 0xe4, 0x51, 0xeb, 0xc7,
	0x50, 0x3f, 0x26, 0x7e, 0xd0, 0xe3, 0x34, 0x91, 0xd7, 0xdb, 0x39, 0xc1, 0xac, 0x25, 0x2e, 0xa5,
	0xac, 0xfb, 0x86, 0x59, 0x9f, 0x9f, 0xdd, 0x37, 0xcc, 0xd9, 0xf9, 0xb9, 0x7d, 0xc3, 0x5c, 0x98,
	0xb7, 0xf6, 0x0d, 0xd3, 0x9a, 0x5f, 0xdc, 0x37, 0xcc, 0xc5, 0xf9, 0xa5, 0x7d, 0xc3, 0x5c, 0x9a,
	0x5f, 0x6e, 0xfe, 0x65, 0x1a, 0x96, 0x0f, 0x39, 0x61, 0x82, 0xb8, 0x38, 0xd9, 0x82, 0x4a, 0x3f,
	0xa6, 0xd9, 0x53, 0xaf, 0xd1, 0xec, 0xbc, 0x8c, 0x96, 0x2f, 0x2b, 0xa3, 0x63, 0x92, 0x62, 0x7c,
	0x07, 0x49, 0xc1, 0x0a, 0xa4, 0x92, 0x0f, 0x14, 0xc1, 0x74, 0xe1, 0x0a, 0x44, 0x08, 0xc2, 0x3f,
	0x01, 0xc0, 0x44, 0xf0, 0xe5, 0xa5, 0xc4, 0xb8, 0xa2, 0x31, 0x89, 0x1a, 0x67, 0x27, 0x41, 0xf5,
	0xb2, 0x27, 0xc1, 0xa8, 0xfe, 0xcc, 0x7c, 0x4f, 0xfd, 0x31, 0x2f, 0xad, 0x3f, 0xa3, 0xd2, 0x51,
	0xb9, 0xac, 0x74, 0x8c, 0xcb, 0x17, 0x7c, 0x07, 0xf9, 0x6a, 0xfe, 0x6e, 0x0a, 0xea, 0x23, 0x52,
	0x6d, 0xad, 0x82, 0x99, 0x9d, 0xff, 0xa5, 0x5c, 0x95, 0xcc, 0x24, 0x55, 0x62, 0xf9, 0x70, 0x2b,
	0x8c, 0x84, 0xc4, 0x02, 0xa7, 0x4c, 0x3a, 0x4a, 0x0c, 0x3c, 0x2a, 0x5c, 0xee, 0xc7, 0x98, 0xe0,
	0x2a, 0x57, 0xab, 0x77, 0x9b, 0x17, 0x26, 0x12, 0x07, 0xc4, 0x67, 0x87, 0x9c, 0xd2, 0x27, 0x01,
	0x61, 0x8f, 0x23, 0x8f, 0x26, 0xc4, 0x37, 0x90, 0xad, 0xa5, 0xc8, 0xd0, 0xb3, 0x3b, 0xa4, 0xb2,
	0x08, 0xac, 0x5c, 0x78, 0xd5, 0x50, 0xf8, 0xca, 0x97, 0x10, 0xbe, 0xeb, 0xa3, 0x2f, 0xc9, 0x42,
	0x3e, 0x30, 0xfe, 0xf3, 0xd7, 0xd5, 0x52, 0xb3, 0x05, 0xd5, 0xdc, 0x42, 0x59, 0x36, 0x18, 0x21,
	0x25, 0x4c, 0xcd, 0xbf, 0x94, 0x0c, 0x53, 0x59, 0x50, 0x1c, 0xc4, 0x69, 0x8f, 0x70, 0xea, 0x39,
	0x9e, 0x7f, 0x7c, 0xac, 0x2b, 0x33, 0x0d, 0xa9, 0x25, 0xae, 0x5d, 0xf4, 0x34, 0x5f, 0x94, 0xe1,
	0xda, 0x84, 0x06, 0xef, 0x21, 0x1d, 0x60, 0xe5, 0x9f, 0xf6, 0x28, 0x1f, 0x8c, 0x2c, 0xb0, 0x36,
	0x59, 0xd7, 0xa0, 0x4c, 0xe2, 0x58, 0xf1, 0xa6, 0x1e, 0x34, 0x58, 0x0d, 0x98, 0xf1, 0x7c, 0x21,
	0xdb, 0x4f, 0x0f, 0xd4, 0xc4, 0xcd, 0x74, 0x5b, 0x12, 0xa3, 0xf5, 0x0e, 0xd4, 0xfc, 0x30, 0x0e,
	0x7c, 0xd7, 0x97, 0x8e, 0xec, 0x33, 0x55, 0x4d, 0x69, 0x50, 0x35, 0xf5, 0x1c, 0xf6, 0x19, 0xbe,
	0xe0, 0x8c, 0xba, 0x2a, 0xdf, 0x53, 0x3f, 0x1a, 0xac, 0xdb, 0x50, 0x39, 0xee, 0x05, 0x81, 0x23,
	0x5c, 0xc2, 0x54, 0x36, 0xa7, 0x5e, 0x13, 0xcd, 0x6d, 0x97, 0x30, 0x6b, 0x0d, 0x4c, 0x8f, 0x48,
	0x72, 0x44, 0x04, 0x55, 0xf9, 0x9a, 0x0e, 0x30, 0xb3, 0x22, 0x89, 0xda, 0xa5, 0x13, 0x22, 0x4e,
	0x54, 0x46, 0x1a, 0x59, 0x07, 0x15, 0x10, 0xf6, 0x39, 0x11, 0x27, 0xb8, 0x84, 0x6a, 0xa6, 0x8e,
	0xe8, 0x85, 0x21, 0xe1, 0x03, 0xd5, 0x40, 0xa4, 0x4c, 0x35, 0xe5, 0x6a, 0x6b, 0x8f, 0xf5, 0x5b,
	0x58, 0x91, 0x43, 0xe9, 0x74, 0x8e, 0x7d, 0xd6, 0xa1, 0x3c, 0xe6, 0x3e, 0x93, 0x8e, 0xaf, 0xdb,
	0x4c, 0x63, 0xfb, 0xa3, 0xe4, 0xbc, 0xb4, 0x73, 0x22, 0xfb, 0xd9, 0x30, 0x70, 0x6f, 0xf7, 0xff,
	0x6f, 0xf0, 0xb5, 0x6c, 0x39, 0xd9, 0xe3, 0xed, 0x1b, 0xa6, 0x31, 0x3f, 0xbd, 0x6f, 0x98, 0xd3,
	0xf3, 0x57, 0x9b, 0x7f, 0x32, 0xe0, 0xe6, 0x56, 0xa7, 0xc3, 0x69, 0x87, 0x48, 0xea, 0x65, 0x9b,
	0xfa, 0x88, 0x4a, 0x82, 0x33, 0x7f, 0xe3, 0x7e, 0xfe, 0x0c, 0xe6, 0x8e, 0x23, 0x1e, 0x62, 0xc7,
	0xee, 0x39, 0x3a, 0x2a, 0xbf, 0xb7, 0xb3, 0x99, 0xf3, 0xa9, 0x0a, 0xbf, 0xb0, 0x3a, 0xe5, 0xd7,
	0xae, 0xce, 0x6d, 0xa8, 0x08, 0x19, 0x4a, 0xdd, 0x3c, 0xe4, 0x5b, 0x75, 0x13, 0xcd, 0xaa, 0x65,
	0xb8, 0x09, 0x15, 0xbc, 0xdd, 0x30, 0x12, 0x52, 0xec, 0xb3, 0xf1, 0x68, 0x35, 0x49, 0x1c, 0x3f,
	0xc6, 0x67, 0xeb, 0x16, 0x54, 0xd2, 0x7d, 0x13, 0xf6, 0x55, 0x7d, 0x90, 0x67, 0x86, 0x0b, 0xf9,
	0x34, 0xf3, 0xba, 0x7c, 0xfa, 0x00, 0x66, 0x31, 0x07, 0x1d, 0xec, 0x63, 0xf4, 0x79, 0x66, 0xaa,
	0xd3, 0x6a, 0x29, 0xd9, 0x98, 0xda, 0xae, 0xce, 0x50, 0x75, 0x64, 0xb6, 0x6a, 0x2a, 0x5f, 0x4f,
	0x03, 0x7d, 0x35, 0x79, 0x17, 0xe6, 0xb2, 0x9c, 0x4b, 0xc0, 0x90, 0x3b, 0xea, 0xea, 0x69, 0xe6,
	0xe9, 0xe8, 0xdb, 0x50, 0x39, 0xa3, 0x6e, 0x12, 0x57, 0xcd, 0xc5, 0x99, 0x67, 0xd4, 0xcd, 0xee,
	0x3a, 0x32, 0x92, 0x24, 0x1d, 0x49, 0x2d, 0x7f, 0x6e, 0x2a, 0x87, 0x0e, 0xfb, 0x08, 0x66, 0xc7,
	0x92, 0xa9, 0xae, 0xd6, 0x6f, 0x39, 0x19, 0x73, 0x7d, 0x34, 0x4b, 0xea, 0xc7, 0x63, 0xa9, 0x51,
	0x99, 0x87, 0xe6, 0x7f, 0xa7, 0xe0, 0xd6, 0x4e, 0x14, 0x04, 0xd4, 0xcd, 0xe7, 0x44, 0xee, 0x7c,
	0xdf, 0x84, 0x29, 0xdf, 0x53, 0xfb, 0x67, 0x6c, 0xaf, 0x26, 0xc4, 0x53, 0x2a, 0x1f, 0x17, 0xda,
	0x32, 0x94, 0xa3, 0xaf, 0x98, 0xf2, 0xf1, 0x40, 0x28, 0x77, 0xa9, 0x4e, 0xa2, 0xea, 0xdd, 0xb7,
	0xc7, 0x1b, 0xea, 0x89, 0x52, 0x92, 0x16, 0x70, 0x97, 0x0e, 0xac, 0x8f, 0x61, 0x5a, 0x1f, 0x25,
	0x93, 0x15, 0x78, 0x02, 0x41, 0x9a, 0xa9, 0x0a, 0x66, 0xed, 0x41, 0x9d, 0x64, 0x49, 0xee, 0x48,
	0x91, 0x75, 0x04, 0x45, 0x04, 0xb6, 0x36, 0x84, 0x1e, 0x0a, 0xeb, 0x0b, 0x58, 0x4a, 0x9f, 0xb1,
	0x70, 0x7d, 0x26, 0x29, 0x3f, 0x23, 0x41, 0xd2, 0x22, 0xdc, 0xb8, 0xc0, 0xb8, 0x9b, 0xdc, 0x8d,
	0x35, 0xe1, 0x9f, 0x91, 0x70, 0x31, 0x47, 0xb0, 0x97, 0xe0, 0x9b, 0x7f, 0x34, 0xa0, 0x91, 0xad,
	0xf9, 0xe4, 0xae, 0x2a, 0x80, 0x1b, 0x22, 0x9d, 0xe9, 0x98, 0x62, 0x08, 0xbb, 0xb4, 0x56, 0x5e,
	0x37, 0xb6, 0xef, 0x9c, 0xbf, 0x5c, 0xbd, 0x9e, 0x2d, 0xc7, 0xc8, 0x3e, 0x88, 0xc9, 0xbb, 0x73,
	0x5d, 0x4c, 0x8a, 0xf6, 0xc4, 0x6b, 0xd5, 0xfa, 0xd3, 0x74, 0x2f, 0xf4, 0x21, 0xf5, 0xa3, 0xb1,
	0xbd, 0x98, 0x38, 0xf4, 0x1f, 0x6c, 0x37, 0xde, 0x2c, 0xa3, 0xd3, 0x3f, 0xa4, 0x8c, 0xbe, 0x36,
	0x13, 0xae, 0x7e, 0xcf, 0x4c, 0xf8, 0x5f, 0x09, 0x16, 0x27, 0xf4, 0x14, 0x78, 0x74, 0xa3, 0xda,
	0x8d, 0x28, 0xb1, 0xb2, 0x58, 0xf7, 0x61, 0x9a, 0x48, 0xc9, 0xb1, 0x3c, 0xca, 0xeb, 0xd5, 0xbb,
	0xef, 0x7c, 0x7b, 0x83, 0xb2, 0xb1, 0x25, 0x25, 0x6f, 0x69, 0x94, 0xf5, 0x31, 0x98, 0xee, 0x89,
	0x1f, 0x78, 0x9c, 0x32, 0xbb, 0xac, 0x18, 0x0a, 0xb4, 0x38, 0xad, 0x0c, 0xb3, 0xf2, 0x29, 0x18,
	0x48, 0x87, 0x19, 0x93, 0x16, 0x79, 0x25, 0x5f, 0xbd, 0x2b, 0x30, 0x7d, 0x46, 0x82, 0x1e, 0x1d,
	0xc9, 0x25, 0x6d, 0xd2, 0x4d, 0x4a, 0xd2, 0xaa, 0xfc, 0xad, 0x04, 0xe6, 0x61, 0x9f, 0xe9, 0x1e,
	0xf0, 0x36, 0x54, 0x64, 0x3f, 0x55, 0xce, 0xfc, 0x35, 0xc2, 0x94, 0xfd, 0x44, 0x34, 0xb7, 0xa1,
	0x86, 0x21, 0xd8, 0x36, 0x39, 0x82, 0xba, 0x89, 0x38, 0x14, 0x68, 0xf3, 0x65, 0x5f, 0xb5, 0x49,
	0x6d, 0xea, 0xe2, 0x19, 0xa6, 0x7b, 0x6e, 0x4c, 0x45, 0xfd, 0xb2, 0xfc, 0x57, 0xa4, 0xd9, 0xcc,
	0xa9, 0x5f, 0xf9, 0x53, 0x98, 0xcd, 0x8e, 0x0e, 0x1d, 0x6d, 0xe4, 0x45, 0x3d, 0xf5, 0xa9, 0xe0,
	0xe6, 0xdf, 0x0d, 0xa8, 0x64, 0x5d, 0xee, 0x1b, 0xef, 0x44, 0x0f, 0xa0, 0xce, 0xa8, 0x7c, 0x1e,
	0xf1, 0xae, 0xa3, 0x7a, 0xf0, 0xc2, 0x53, 0xa9, 0x25, 0xb0, 0x6d, 0x44, 0x59, 0xbb, 0x50, 0xc7,
	0xab, 0x55, 0x48, 0x43, 0xa7, 0x27, 0x48, 0x87, 0x16, 0xbe, 0x38, 0xe1, 0x8d, 0xec, 0x11, 0x0d,
	0x9f, 0x21, 0xc8, 0xda, 0xc3, 0x25, 0x61, 0x92, 0x32, 0x95, 0xd6, 0xb8, 0xba, 0x85, 0x2f, 0x50,
	0xb3, 0x43, 0x20, 0x2e, 0xb0, 0xf5, 0x10, 0xe6, 0xd3, 0x79, 0x85, 0x54, 0x20, 0x7b, 0xf1, 0x6f,
	0x62, 0x73, 0x09, 0xf2, 0x51, 0x02, 0xb4, 0x3e, 0x83, 0x59, 0x9c, 0x9d, 0xe7, 0x8b, 0x6e, 0x32,
	0xbd, 0xa2, 0xd7, 0xaa, 0x5a, 0x48, 0xfa, 0xbb, 0xbe, 0xe8, 0xea, 0xf9, 0xb5, 0xa1, 0xee, 0xc6,
	0x3d, 0x75, 0xa8, 0x33, 0xc2, 0x22, 0x51, 0xe0, 0x7e, 0xb4, 0x98, 0x48, 0x48, 0x75, 0xe7, 0xc9,
	0xb3, 0xf6, 0xd3, 0x83, 0xc7, 0x08, 0x6b, 0x55, 0xdd, 0xb8, 0xd7, 0x3e, 0x0d, 0xd4, 0x83, 0xd5,
	0x85, 0xc5, 0xf0, 0xcc, 0x75, 0x1d, 0x5f, 0x52, 0x4e, 0x64, 0xc4, 0x93, 0xab, 0x8f, 0xbe, 0x3a,
	0xad, 0x8d, 0x51, 0x3f, 0xfa, 0x62, 0x67, 0x67, 0x2f, 0x09, 0xd4, 0x57, 0xa0, 0x1b, 0xc9, 0x0b,
	0x16, 0x2e, 0xb8, 0x5a, 0x0b, 0xc8, 0x3b, 0x62, 0x6a, 0xfe, 0xbe, 0x04, 0xd5, 0xdc, 0x87, 0x01,
	0x2c, 0xbc, 0xd0, 0x1f, 0xed, 0xe9, 0xd1, 0xa0, 0xec, 0xa4, 0x3f, 0xd2, 0xc8, 0xa3, 0x01, 0xed,
	0xf1, 0xfb, 0x77, 0x54, 0x76, 0x64, 0xf6, 0xf8, 0xfd, 0x3b, 0xca, 0x7e, 0xef, 0x8e, 0xda, 0xed,
	0xa1, 0xfd, 0x5e, 0x62, 0xbf, 0xa7, 0x76, 0x2e, 0x67, 0xbf, 0xd7, 0xfc, 0x83, 0x09, 0x17, 0x07,
	0x8c, 0x97, 0x4f, 0x21, 0x69, 0x9c, 0x2b, 0xdd, 0x42, 0x97, 0x4f, 0xc4, 0xe8, 0x22, 0x7b, 0x02,
	0x8b, 0x43, 0x02, 0xad, 0xab, 0x8c, 0x04, 0x85, 0x6b, 0x62, 0x21, 0x63, 0xda, 0x4b, 0xa0, 0x6a,
	0x48, 0x94, 0x76, 0x73, 0x05, 0x5e, 0x6c, 0x48, 0x94, 0x76, 0x87, 0x43, 0xca, 0x08, 0x86, 0x43,
	0x32, 0x0a, 0x0f, 0x29, 0x65, 0xca, 0x86, 0xb4, 0x05, 0xd5, 0xa3, 0x20, 0x72, 0xd3, 0x82, 0x2f,
	0x5a, 0x15, 0xa0, 0x40, 0xba, 0xdc, 0x9f, 0xc2, 0x52, 0x8e, 0xc2, 0xf1, 0x99, 0xe3, 0x12, 0xf7,
	0xa4, 0x78, 0x59, 0x2c, 0x0c, 0xb9, 0xf6, 0xd8, 0x0e, 0x42, 0xf1, 0xde, 0xdf, 0xa5, 0x83, 0x64,
	0x4c, 0x45, 0xbf, 0x1b, 0x98, 0x5d, 0x3a, 0xd0, 0x23, 0xda, 0x82, 0xaa, 0x92, 0xf5, 0x84, 0xa0,
	0xe8, 0x87, 0x03, 0x50, 0xa0, 0x8c, 0x22, 0x8e, 0xf0, 0xfc, 0xd6, 0x7b, 0x55, 0xf8, 0x6b, 0xb0,
	0x02, 0xe9, 0xcd, 0x0a, 0xa0, 0xa9, 0x9e, 0x84, 0xe3, 0x46, 0x67, 0x14, 0x2f, 0xb4, 0x47, 0x03,
	0x87, 0x13, 0xd6, 0xa1, 0x8e, 0x8c, 0xc2, 0x23, 0x21, 0x23, 0x46, 0x45, 0xe1, 0x8f, 0x0a, 0x0d,
	0xcd, 0xb5, 0xa3, 0xa9, 0xb6, 0x07, 0x2d, 0x24, 0x3a, 0xcc, 0x78, 0xac, 0xcf, 0x61, 0x4e, 0x73,
	0xe3, 0xc2, 0x0d, 0x1b, 0xf8, 0x22, 0xd4, 0x75, 0x05, 0x7c, 0x48, 0x07, 0x7a, 0xdc, 0xbf, 0x81,
	0x95, 0x3c, 0x13, 0x93, 0xc4, 0x67, 0xd4, 0x73, 0xf4, 0xfb, 0x93, 0x8f, 0xd1, 0xdf, 0x4e, 0x7a,
	0x7d, 0x48, 0x9a, 0x30, 0x3c, 0x51, 0x04, 0xd6, 0xaf, 0xc0, 0x1e, 0xd2, 0x8b, 0xae, 0x1f, 0xc7,
	0x43, 0xf2, 0x7a, 0x41, 0xf2, 0xe5, 0x94, 0xbc, 0xad, 0xf1, 0x9a, 0x7a, 0xfb, 0xd9, 0x8b, 0x7f,
	0x35, 0xae, 0xbc, 0x38, 0x6f, 0x94, 0xbe, 0x3a, 0x6f, 0x94, 0xbe, 0x3e, 0x6f, 0x94, 0xfe, 0x79,
	0xde, 0x28, 0x7d, 0xf9, 0xaa, 0x71, 0xe5, 0xab, 0x57, 0x8d, 0x2b, 0x5f, 0xbf, 0x6a, 0x5c, 0xf9,
	0xf5, 0x7b, 0x1d, 0x5f, 0x9e, 0xf4, 0x8e, 0x36, 0xdc, 0x28, 0xdc, 0xcc, 0x5e, 0xe2, 0x1d, 0x0d,
	0x7f, 0x6f, 0xc6, 0xdd, 0xce, 0xe6, 0xe8, 0xdf, 0x57, 0xdf, 0x04, 0x00, 0x00, 0xff, 0xff, 0x64,
	0x22, 0x28, 0x06, 0xcf, 0x1a, 0x00, 0x00,
}

func (this *SensitiveInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SensitiveInfo)
	if !ok {
		that2, ok := that.(SensitiveInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LastErr != that1.LastErr {
		return false
	}
	if !this.MostRecentPlanDescription.Equal(&that1.MostRecentPlanDescription) {
		return false
	}
	if !this.MostRecentPlanTimestamp.Equal(that1.MostRecentPlanTimestamp) {
		return false
	}
	return true
}
func (this *ExplainTreePlanNode) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExplainTreePlanNode)
	if !ok {
		that2, ok := that.(ExplainTreePlanNode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Attrs) != len(that1.Attrs) {
		return false
	}
	for i := range this.Attrs {
		if !this.Attrs[i].Equal(that1.Attrs[i]) {
			return false
		}
	}
	if len(this.Children) != len(that1.Children) {
		return false
	}
	for i := range this.Children {
		if !this.Children[i].Equal(that1.Children[i]) {
			return false
		}
	}
	return true
}
func (this *ExplainTreePlanNode_Attr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExplainTreePlanNode_Attr)
	if !ok {
		that2, ok := that.(ExplainTreePlanNode_Attr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (m *StatementStatistics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementStatistics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatementStatistics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintAppStats(dAtA, i, uint64(m.FailureCount))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x88
	i -= len(m.LastErrorCode)
	copy(dAtA[i:], m.LastErrorCode)
	i = encodeVarintAppStats(dAtA, i, uint64(len(m.LastErrorCode)))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x82
	{
		size, err := m.LatencyInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xfa
	if len(m.Indexes) > 0 {
		for iNdEx := len(m.Indexes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Indexes[iNdEx])
			copy(dAtA[i:], m.Indexes[iNdEx])
			i = encodeVarintAppStats(dAtA, i, uint64(len(m.Indexes[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xf2
		}
	}
	if len(m.Regions) > 0 {
		for iNdEx := len(m.Regions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Regions[iNdEx])
			copy(dAtA[i:], m.Regions[iNdEx])
			i = encodeVarintAppStats(dAtA, i, uint64(len(m.Regions[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xea
		}
	}
	{
		size, err := m.IdleLat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xe2
	if len(m.IndexRecommendations) > 0 {
		for iNdEx := len(m.IndexRecommendations) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IndexRecommendations[iNdEx])
			copy(dAtA[i:], m.IndexRecommendations[iNdEx])
			i = encodeVarintAppStats(dAtA, i, uint64(len(m.IndexRecommendations[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	if len(m.PlanGists) > 0 {
		for iNdEx := len(m.PlanGists) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PlanGists[iNdEx])
			copy(dAtA[i:], m.PlanGists[iNdEx])
			i = encodeVarintAppStats(dAtA, i, uint64(len(m.PlanGists[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	{
		size, err := m.RowsWritten.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xca
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintAppStats(dAtA, i, uint64(m.Nodes[iNdEx]))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc0
		}
	}
	n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastExecTimestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastExecTimestamp):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintAppStats(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xba
	i -= len(m.SQLType)
	copy(dAtA[i:], m.SQLType)
	i = encodeVarintAppStats(dAtA, i, uint64(len(m.SQLType)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb2
	{
		size, err := m.ExecStats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xaa
	{
		size, err := m.RowsRead.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	{
		size, err := m.BytesRead.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	{
		size, err := m.SensitiveInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	i -= len(m.LegacyLastErrRedacted)
	copy(dAtA[i:], m.LegacyLastErrRedacted)
	i = encodeVarintAppStats(dAtA, i, uint64(len(m.LegacyLastErrRedacted)))
	i--
	dAtA[i] = 0x5a
	{
		size, err := m.OverheadLat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size, err := m.ServiceLat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.RunLat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.PlanLat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.ParseLat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.NumRows.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	i -= len(m.LegacyLastErr)
	copy(dAtA[i:], m.LegacyLastErr)
	i = encodeVarintAppStats(dAtA, i, uint64(len(m.LegacyLastErr)))
	i--
	dAtA[i] = 0x22
	i = encodeVarintAppStats(dAtA, i, uint64(m.MaxRetries))
	i--
	dAtA[i] = 0x18
	i = encodeVarintAppStats(dAtA, i, uint64(m.FirstAttemptCount))
	i--
	dAtA[i] = 0x10
	i = encodeVarintAppStats(dAtA, i, uint64(m.Count))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *TransactionStatistics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionStatistics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionStatistics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.IdleLat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size, err := m.RowsWritten.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size, err := m.ExecStats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.RowsRead.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.BytesRead.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.CommitLat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.RetryLat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.ServiceLat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.NumRows.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	i = encodeVarintAppStats(dAtA, i, uint64(m.MaxRetries))
	i--
	dAtA[i] = 0x10
	i = encodeVarintAppStats(dAtA, i, uint64(m.Count))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *SensitiveInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SensitiveInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SensitiveInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n24, err24 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.MostRecentPlanTimestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.MostRecentPlanTimestamp):])
	if err24 != nil {
		return 0, err24
	}
	i -= n24
	i = encodeVarintAppStats(dAtA, i, uint64(n24))
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.MostRecentPlanDescription.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	i -= len(m.LastErr)
	copy(dAtA[i:], m.LastErr)
	i = encodeVarintAppStats(dAtA, i, uint64(len(m.LastErr)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *NumericStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NumericStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NumericStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SquaredDiffs))))
	i--
	dAtA[i] = 0x11
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Mean))))
	i--
	dAtA[i] = 0x9
	return len(dAtA) - i, nil
}

func (m *StatementStatisticsKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementStatisticsKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatementStatisticsKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.QuerySummary)
	copy(dAtA[i:], m.QuerySummary)
	i = encodeVarintAppStats(dAtA, i, uint64(len(m.QuerySummary)))
	i--
	dAtA[i] = 0x62
	i = encodeVarintAppStats(dAtA, i, uint64(m.TransactionFingerprintID))
	i--
	dAtA[i] = 0x58
	i = encodeVarintAppStats(dAtA, i, uint64(m.PlanHash))
	i--
	dAtA[i] = 0x50
	i -= len(m.Database)
	copy(dAtA[i:], m.Database)
	i = encodeVarintAppStats(dAtA, i, uint64(len(m.Database)))
	i--
	dAtA[i] = 0x4a
	i--
	if m.FullScan {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x40
	i--
	if m.Vec {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x38
	i--
	if m.ImplicitTxn {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x30
	i--
	if m.DistSQL {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	i -= len(m.App)
	copy(dAtA[i:], m.App)
	i = encodeVarintAppStats(dAtA, i, uint64(len(m.App)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Query)
	copy(dAtA[i:], m.Query)
	i = encodeVarintAppStats(dAtA, i, uint64(len(m.Query)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AggregatedStatementMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregatedStatementMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregatedStatementMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.FingerprintID)
	copy(dAtA[i:], m.FingerprintID)
	i = encodeVarintAppStats(dAtA, i, uint64(len(m.FingerprintID)))
	i--
	dAtA[i] = 0x6a
	i = encodeVarintAppStats(dAtA, i, uint64(m.TotalCount))
	i--
	dAtA[i] = 0x60
	i = encodeVarintAppStats(dAtA, i, uint64(m.VecCount))
	i--
	dAtA[i] = 0x58
	i = encodeVarintAppStats(dAtA, i, uint64(m.FullScanCount))
	i--
	dAtA[i] = 0x50
	i = encodeVarintAppStats(dAtA, i, uint64(m.DistSQLCount))
	i--
	dAtA[i] = 0x40
	i--
	if m.ImplicitTxn {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x38
	if len(m.Databases) > 0 {
		for iNdEx := len(m.Databases) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Databases[iNdEx])
			copy(dAtA[i:], m.Databases[iNdEx])
			i = encodeVarintAppStats(dAtA, i, uint64(len(m.Databases[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.AppNames) > 0 {
		for iNdEx := len(m.AppNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AppNames[iNdEx])
			copy(dAtA[i:], m.AppNames[iNdEx])
			i = encodeVarintAppStats(dAtA, i, uint64(len(m.AppNames[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	i -= len(m.StmtType)
	copy(dAtA[i:], m.StmtType)
	i = encodeVarintAppStats(dAtA, i, uint64(len(m.StmtType)))
	i--
	dAtA[i] = 0x22
	i -= len(m.QuerySummary)
	copy(dAtA[i:], m.QuerySummary)
	i = encodeVarintAppStats(dAtA, i, uint64(len(m.QuerySummary)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.FormattedQuery)
	copy(dAtA[i:], m.FormattedQuery)
	i = encodeVarintAppStats(dAtA, i, uint64(len(m.FormattedQuery)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Query)
	copy(dAtA[i:], m.Query)
	i = encodeVarintAppStats(dAtA, i, uint64(len(m.Query)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CollectedStatementStatistics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectedStatementStatistics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectedStatementStatistics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n26, err26 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.AggregationInterval, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.AggregationInterval):])
	if err26 != nil {
		return 0, err26
	}
	i -= n26
	i = encodeVarintAppStats(dAtA, i, uint64(n26))
	i--
	dAtA[i] = 0x2a
	n27, err27 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.AggregatedTs, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.AggregatedTs):])
	if err27 != nil {
		return 0, err27
	}
	i -= n27
	i = encodeVarintAppStats(dAtA, i, uint64(n27))
	i--
	dAtA[i] = 0x22
	i = encodeVarintAppStats(dAtA, i, uint64(m.ID))
	i--
	dAtA[i] = 0x18
	{
		size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CollectedTransactionStatistics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectedTransactionStatistics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectedTransactionStatistics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n30, err30 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.AggregationInterval, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.AggregationInterval):])
	if err30 != nil {
		return 0, err30
	}
	i -= n30
	i = encodeVarintAppStats(dAtA, i, uint64(n30))
	i--
	dAtA[i] = 0x32
	i = encodeVarintAppStats(dAtA, i, uint64(m.TransactionFingerprintID))
	i--
	dAtA[i] = 0x28
	n31, err31 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.AggregatedTs, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.AggregatedTs):])
	if err31 != nil {
		return 0, err31
	}
	i -= n31
	i = encodeVarintAppStats(dAtA, i, uint64(n31))
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	i -= len(m.App)
	copy(dAtA[i:], m.App)
	i = encodeVarintAppStats(dAtA, i, uint64(len(m.App)))
	i--
	dAtA[i] = 0x12
	if len(m.StatementFingerprintIDs) > 0 {
		for iNdEx := len(m.StatementFingerprintIDs) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintAppStats(dAtA, i, uint64(m.StatementFingerprintIDs[iNdEx]))
			i--
			dAtA[i] = 0x8
		}
	}
	return len(dAtA) - i, nil
}

func (m *ExplainTreePlanNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExplainTreePlanNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExplainTreePlanNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppStats(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Attrs) > 0 {
		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attrs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAppStats(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintAppStats(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ExplainTreePlanNode_Attr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExplainTreePlanNode_Attr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExplainTreePlanNode_Attr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Value)
	copy(dAtA[i:], m.Value)
	i = encodeVarintAppStats(dAtA, i, uint64(len(m.Value)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Key)
	copy(dAtA[i:], m.Key)
	i = encodeVarintAppStats(dAtA, i, uint64(len(m.Key)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TxnStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxnStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintAppStats(dAtA, i, uint64(m.ImplicitCount))
	i--
	dAtA[i] = 0x20
	i = encodeVarintAppStats(dAtA, i, uint64(m.CommittedCount))
	i--
	dAtA[i] = 0x18
	{
		size, err := m.TxnTimeSec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	i = encodeVarintAppStats(dAtA, i, uint64(m.TxnCount))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ExecStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MVCCIteratorStats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.CPUSQLNanos.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.MaxDiskUsage.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.NetworkMessages.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.ContentionTime.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.MaxMemUsage.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.NetworkBytes.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	i = encodeVarintAppStats(dAtA, i, uint64(m.Count))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *LatencyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LatencyInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LatencyInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.P99))))
	i--
	dAtA[i] = 0x29
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.P90))))
	i--
	dAtA[i] = 0x21
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.P50))))
	i--
	dAtA[i] = 0x19
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Max))))
	i--
	dAtA[i] = 0x11
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Min))))
	i--
	dAtA[i] = 0x9
	return len(dAtA) - i, nil
}

func (m *MVCCIteratorStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MVCCIteratorStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MVCCIteratorStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RangeKeySkippedPoints.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size, err := m.RangeKeyContainedPoints.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size, err := m.RangeKeyCount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size, err := m.PointsCoveredByRangeTombstones.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size, err := m.PointCount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.ValueBytes.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.KeyBytes.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.BlockBytesInCache.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.BlockBytes.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.SeekCountInternal.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.SeekCount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.StepCountInternal.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.StepCount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAppStats(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintAppStats(dAtA []byte, offset int, v uint64) int {
	offset -= sovAppStats(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StatementStatistics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovAppStats(uint64(m.Count))
	n += 1 + sovAppStats(uint64(m.FirstAttemptCount))
	n += 1 + sovAppStats(uint64(m.MaxRetries))
	l = len(m.LegacyLastErr)
	n += 1 + l + sovAppStats(uint64(l))
	l = m.NumRows.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.ParseLat.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.PlanLat.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.RunLat.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.ServiceLat.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.OverheadLat.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = len(m.LegacyLastErrRedacted)
	n += 1 + l + sovAppStats(uint64(l))
	l = m.SensitiveInfo.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.BytesRead.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.RowsRead.Size()
	n += 2 + l + sovAppStats(uint64(l))
	l = m.ExecStats.Size()
	n += 2 + l + sovAppStats(uint64(l))
	l = len(m.SQLType)
	n += 2 + l + sovAppStats(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastExecTimestamp)
	n += 2 + l + sovAppStats(uint64(l))
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			n += 2 + sovAppStats(uint64(e))
		}
	}
	l = m.RowsWritten.Size()
	n += 2 + l + sovAppStats(uint64(l))
	if len(m.PlanGists) > 0 {
		for _, s := range m.PlanGists {
			l = len(s)
			n += 2 + l + sovAppStats(uint64(l))
		}
	}
	if len(m.IndexRecommendations) > 0 {
		for _, s := range m.IndexRecommendations {
			l = len(s)
			n += 2 + l + sovAppStats(uint64(l))
		}
	}
	l = m.IdleLat.Size()
	n += 2 + l + sovAppStats(uint64(l))
	if len(m.Regions) > 0 {
		for _, s := range m.Regions {
			l = len(s)
			n += 2 + l + sovAppStats(uint64(l))
		}
	}
	if len(m.Indexes) > 0 {
		for _, s := range m.Indexes {
			l = len(s)
			n += 2 + l + sovAppStats(uint64(l))
		}
	}
	l = m.LatencyInfo.Size()
	n += 2 + l + sovAppStats(uint64(l))
	l = len(m.LastErrorCode)
	n += 2 + l + sovAppStats(uint64(l))
	n += 2 + sovAppStats(uint64(m.FailureCount))
	return n
}

func (m *TransactionStatistics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovAppStats(uint64(m.Count))
	n += 1 + sovAppStats(uint64(m.MaxRetries))
	l = m.NumRows.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.ServiceLat.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.RetryLat.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.CommitLat.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.BytesRead.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.RowsRead.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.ExecStats.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.RowsWritten.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.IdleLat.Size()
	n += 1 + l + sovAppStats(uint64(l))
	return n
}

func (m *SensitiveInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LastErr)
	n += 1 + l + sovAppStats(uint64(l))
	l = m.MostRecentPlanDescription.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.MostRecentPlanTimestamp)
	n += 1 + l + sovAppStats(uint64(l))
	return n
}

func (m *NumericStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	n += 9
	return n
}

func (m *StatementStatisticsKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	n += 1 + l + sovAppStats(uint64(l))
	l = len(m.App)
	n += 1 + l + sovAppStats(uint64(l))
	n += 2
	n += 2
	n += 2
	n += 2
	l = len(m.Database)
	n += 1 + l + sovAppStats(uint64(l))
	n += 1 + sovAppStats(uint64(m.PlanHash))
	n += 1 + sovAppStats(uint64(m.TransactionFingerprintID))
	l = len(m.QuerySummary)
	n += 1 + l + sovAppStats(uint64(l))
	return n
}

func (m *AggregatedStatementMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	n += 1 + l + sovAppStats(uint64(l))
	l = len(m.FormattedQuery)
	n += 1 + l + sovAppStats(uint64(l))
	l = len(m.QuerySummary)
	n += 1 + l + sovAppStats(uint64(l))
	l = len(m.StmtType)
	n += 1 + l + sovAppStats(uint64(l))
	if len(m.AppNames) > 0 {
		for _, s := range m.AppNames {
			l = len(s)
			n += 1 + l + sovAppStats(uint64(l))
		}
	}
	if len(m.Databases) > 0 {
		for _, s := range m.Databases {
			l = len(s)
			n += 1 + l + sovAppStats(uint64(l))
		}
	}
	n += 2
	n += 1 + sovAppStats(uint64(m.DistSQLCount))
	n += 1 + sovAppStats(uint64(m.FullScanCount))
	n += 1 + sovAppStats(uint64(m.VecCount))
	n += 1 + sovAppStats(uint64(m.TotalCount))
	l = len(m.FingerprintID)
	n += 1 + l + sovAppStats(uint64(l))
	return n
}

func (m *CollectedStatementStatistics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.Stats.Size()
	n += 1 + l + sovAppStats(uint64(l))
	n += 1 + sovAppStats(uint64(m.ID))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.AggregatedTs)
	n += 1 + l + sovAppStats(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.AggregationInterval)
	n += 1 + l + sovAppStats(uint64(l))
	return n
}

func (m *CollectedTransactionStatistics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StatementFingerprintIDs) > 0 {
		for _, e := range m.StatementFingerprintIDs {
			n += 1 + sovAppStats(uint64(e))
		}
	}
	l = len(m.App)
	n += 1 + l + sovAppStats(uint64(l))
	l = m.Stats.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.AggregatedTs)
	n += 1 + l + sovAppStats(uint64(l))
	n += 1 + sovAppStats(uint64(m.TransactionFingerprintID))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.AggregationInterval)
	n += 1 + l + sovAppStats(uint64(l))
	return n
}

func (m *ExplainTreePlanNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovAppStats(uint64(l))
	if len(m.Attrs) > 0 {
		for _, e := range m.Attrs {
			l = e.Size()
			n += 1 + l + sovAppStats(uint64(l))
		}
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovAppStats(uint64(l))
		}
	}
	return n
}

func (m *ExplainTreePlanNode_Attr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	n += 1 + l + sovAppStats(uint64(l))
	l = len(m.Value)
	n += 1 + l + sovAppStats(uint64(l))
	return n
}

func (m *TxnStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovAppStats(uint64(m.TxnCount))
	l = m.TxnTimeSec.Size()
	n += 1 + l + sovAppStats(uint64(l))
	n += 1 + sovAppStats(uint64(m.CommittedCount))
	n += 1 + sovAppStats(uint64(m.ImplicitCount))
	return n
}

func (m *ExecStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovAppStats(uint64(m.Count))
	l = m.NetworkBytes.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.MaxMemUsage.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.ContentionTime.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.NetworkMessages.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.MaxDiskUsage.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.CPUSQLNanos.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.MVCCIteratorStats.Size()
	n += 1 + l + sovAppStats(uint64(l))
	return n
}

func (m *LatencyInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	n += 9
	n += 9
	n += 9
	n += 9
	return n
}

func (m *MVCCIteratorStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StepCount.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.StepCountInternal.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.SeekCount.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.SeekCountInternal.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.BlockBytes.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.BlockBytesInCache.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.KeyBytes.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.ValueBytes.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.PointCount.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.PointsCoveredByRangeTombstones.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.RangeKeyCount.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.RangeKeyContainedPoints.Size()
	n += 1 + l + sovAppStats(uint64(l))
	l = m.RangeKeySkippedPoints.Size()
	n += 1 + l + sovAppStats(uint64(l))
	return n
}

func sovAppStats(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAppStats(x uint64) (n int) {
	return sovAppStats(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StatementStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatementStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatementStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstAttemptCount", wireType)
			}
			m.FirstAttemptCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstAttemptCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetries", wireType)
			}
			m.MaxRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRetries |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyLastErr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LegacyLastErr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NumRows.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseLat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ParseLat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanLat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PlanLat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunLat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RunLat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceLat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ServiceLat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverheadLat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OverheadLat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyLastErrRedacted", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LegacyLastErrRedacted = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SensitiveInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SensitiveInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BytesRead.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsRead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RowsRead.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExecStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SQLType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SQLType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastExecTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastExecTimestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppStats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Nodes = append(m.Nodes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppStats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAppStats
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAppStats
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Nodes) == 0 {
					m.Nodes = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppStats
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Nodes = append(m.Nodes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsWritten", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RowsWritten.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanGists", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlanGists = append(m.PlanGists, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexRecommendations", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexRecommendations = append(m.IndexRecommendations, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleLat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IdleLat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regions = append(m.Regions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Indexes = append(m.Indexes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LatencyInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastErrorCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastErrorCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureCount", wireType)
			}
			m.FailureCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FailureCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetries", wireType)
			}
			m.MaxRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRetries |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NumRows.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceLat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ServiceLat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryLat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RetryLat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitLat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommitLat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BytesRead.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsRead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RowsRead.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExecStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsWritten", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RowsWritten.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleLat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IdleLat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SensitiveInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SensitiveInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SensitiveInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastErr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastErr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MostRecentPlanDescription", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MostRecentPlanDescription.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MostRecentPlanTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.MostRecentPlanTimestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NumericStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NumericStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NumericStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mean", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Mean = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SquaredDiffs", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SquaredDiffs = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAppStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementStatisticsKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatementStatisticsKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatementStatisticsKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.App = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistSQL", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DistSQL = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImplicitTxn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ImplicitTxn = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vec", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Vec = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullScan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FullScan = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlanHash", wireType)
			}
			m.PlanHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlanHash |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionFingerprintID", wireType)
			}
			m.TransactionFingerprintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionFingerprintID |= TransactionFingerprintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuerySummary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuerySummary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregatedStatementMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregatedStatementMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregatedStatementMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FormattedQuery", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FormattedQuery = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuerySummary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuerySummary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StmtType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StmtType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppNames = append(m.AppNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Databases", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Databases = append(m.Databases, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImplicitTxn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ImplicitTxn = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistSQLCount", wireType)
			}
			m.DistSQLCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DistSQLCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullScanCount", wireType)
			}
			m.FullScanCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FullScanCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VecCount", wireType)
			}
			m.VecCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VecCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FingerprintID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FingerprintID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectedStatementStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectedStatementStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectedStatementStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= StmtFingerprintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregatedTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.AggregatedTs, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.AggregationInterval, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectedTransactionStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectedTransactionStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectedTransactionStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v StmtFingerprintID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppStats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= StmtFingerprintID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StatementFingerprintIDs = append(m.StatementFingerprintIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAppStats
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAppStats
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAppStats
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.StatementFingerprintIDs) == 0 {
					m.StatementFingerprintIDs = make([]StmtFingerprintID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v StmtFingerprintID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAppStats
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= StmtFingerprintID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StatementFingerprintIDs = append(m.StatementFingerprintIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementFingerprintIDs", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.App = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregatedTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.AggregatedTs, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionFingerprintID", wireType)
			}
			m.TransactionFingerprintID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionFingerprintID |= TransactionFingerprintID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.AggregationInterval, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExplainTreePlanNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExplainTreePlanNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExplainTreePlanNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, &ExplainTreePlanNode_Attr{})
			if err := m.Attrs[len(m.Attrs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &ExplainTreePlanNode{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExplainTreePlanNode_Attr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnCount", wireType)
			}
			m.TxnCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnTimeSec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnTimeSec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedCount", wireType)
			}
			m.CommittedCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommittedCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImplicitCount", wireType)
			}
			m.ImplicitCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImplicitCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NetworkBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMemUsage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxMemUsage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ContentionTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkMessages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NetworkMessages.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDiskUsage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxDiskUsage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPUSQLNanos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CPUSQLNanos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MVCCIteratorStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MVCCIteratorStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LatencyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LatencyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LatencyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Min = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Max = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field P50", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.P50 = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field P90", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.P90 = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field P99", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.P99 = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAppStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MVCCIteratorStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppStats
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MVCCIteratorStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MVCCIteratorStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepCount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StepCount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepCountInternal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StepCountInternal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeekCount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SeekCount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeekCountInternal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SeekCountInternal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BlockBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockBytesInCache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BlockBytesInCache.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.KeyBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ValueBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointCount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PointCount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointsCoveredByRangeTombstones", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PointsCoveredByRangeTombstones.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeKeyCount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RangeKeyCount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeKeyContainedPoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RangeKeyContainedPoints.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeKeySkippedPoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAppStats
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAppStats
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RangeKeySkippedPoints.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppStats(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppStats
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAppStats(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAppStats
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppStats
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAppStats
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAppStats
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAppStats
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAppStats        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAppStats          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAppStats = fmt.Errorf("proto: unexpected end of group")
)

