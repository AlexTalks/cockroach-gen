// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package exec

import (
	"bytes"
	"fmt"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/sql/distsqlpb"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/coldata"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/types"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/sql/sqlbase"
)

func (o *mergeJoinOp) probeBodyLSeltrueRSeltrue() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinOp) probeBodyLSeltrueRSelfalse() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
													break
												}
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[lSel[curLIdx]]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinOp) probeBodyLSelfalseRSeltrue() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinOp) probeBodyLSelfalseRSelfalse() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {
									if o.joinType == sqlbase.JoinType_LEFT_OUTER {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									}
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												if lVec.Nulls().NullAt64(uint64(curLIdx)) {
													break
												}
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = tree.CompareBools(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = bytes.Compare(newLVal, lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = tree.CompareDecimals(&newLVal, &lVal) == 0
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false
							if o.joinType == sqlbase.JoinType_LEFT_OUTER {
								if lGroup.unmatched {
									if curLIdx+1 != curLLength {
										panic("unexpectedly length of the left unmatched group is not 1")
									}
									// The row already does not have a match, so we don't need to do any
									// additional processing.
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									areGroupsProcessed = true
								}
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that
								// is either curLIdx or lSel[curLIdx] depending on whether we're in a
								// selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that
								// is either curRIdx or rSel[curRIdx] depending on whether we're in a
								// selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++
										if o.joinType == sqlbase.JoinType_LEFT_OUTER {
											// All the rows on the left within the current group will not get
											// a match on the right, so we're adding each of them as a left
											// outer group.
											o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
											for curLIdx < curLLength {
												newLVal := lKeys[curLIdx]
												match = newLVal == lVal
												if !match {
													break
												}
												o.groups.addLeftOuterGroup(curLIdx, curRIdx)
												curLIdx++
											}
										}
									} else {
										curRIdx++
									}

								}
							}
							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								if o.joinType == sqlbase.JoinType_LEFT_OUTER {
									// Any unprocessed row in the left group will not get a match, so
									// each one of them becomes a new unmatched group with a
									// corresponding null group.
									for curLIdx < curLLength {
										o.groups.addLeftOuterGroup(curLIdx, curRIdx)
										curLIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

// buildLeftGroups takes a []group and expands each group into the output by
// repeating each row in the group numRepeats times. For example, given an
// input table:
//  L1 |  L2
//  --------
//  1  |  a
//  1  |  b
// and leftGroups = [{startIdx: 0, endIdx: 2, numRepeats: 3}]
// then buildLeftGroups expands this to
//  L1 |  L2
//  --------
//  1  |  a
//  1  |  a
//  1  |  a
//  1  |  b
//  1  |  b
//  1  |  b
// Note: this is different from buildRightGroups in that each row of group is
// repeated numRepeats times, instead of a simple copy of the group as a whole.
// SIDE EFFECTS: writes into o.output.
func (o *mergeJoinOp) buildLeftGroups(
	leftGroups []group,
	colOffset int,
	input *mergeJoinInput,
	batch coldata.Batch,
	destStartIdx uint16,
) {
	sel := batch.Selection()
	initialBuilderState := o.builderState.left
	outputBatchSize := int(o.outputBatchSize)
	// Loop over every column.
LeftColLoop:
	for ; o.builderState.left.colIdx < len(input.outCols); o.builderState.left.colIdx++ {
		colIdx := input.outCols[o.builderState.left.colIdx]
		outStartIdx := int(destStartIdx)
		out := o.output.ColVec(int(colIdx))
		src := batch.ColVec(int(colIdx))
		colType := input.sourceTypes[colIdx]

		if sel != nil {
			if src.MaybeHasNulls() {

				switch colType {
				case types.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()
					var val bool
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool
							isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
							if isNull {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							}

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()
					var val []byte
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool
							isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
							if isNull {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							}

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()
					var val apd.Decimal
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool
							isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
							if isNull {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							}

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()
					var val int8
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool
							isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
							if isNull {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							}

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()
					var val int16
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool
							isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
							if isNull {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							}

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()
					var val int32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool
							isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
							if isNull {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							}

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()
					var val int64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool
							isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
							if isNull {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							}

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()
					var val float32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool
							isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
							if isNull {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							}

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()
					var val float64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool
							isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
							if isNull {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							}

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case types.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()
					var val bool
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()
					var val []byte
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()
					var val apd.Decimal
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()
					var val int8
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()
					var val int16
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()
					var val int32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()
					var val int64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()
					var val float32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()
					var val float64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		} else {
			if src.MaybeHasNulls() {

				switch colType {
				case types.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()
					var val bool
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool
							isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
							if isNull {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							}

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()
					var val []byte
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool
							isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
							if isNull {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							}

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()
					var val apd.Decimal
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool
							isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
							if isNull {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							}

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()
					var val int8
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool
							isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
							if isNull {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							}

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()
					var val int16
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool
							isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
							if isNull {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							}

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()
					var val int32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool
							isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
							if isNull {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							}

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()
					var val int64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool
							isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
							if isNull {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							}

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()
					var val float32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool
							isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
							if isNull {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							}

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()
					var val float64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool
							isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
							if isNull {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							}

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case types.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()
					var val bool
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()
					var val []byte
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()
					var val apd.Decimal
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()
					var val int8
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()
					var val int16
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()
					var val int32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()
					var val int64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()
					var val float32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()
					var val float64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							var isNull bool

							if !isNull {
								val = srcCol[srcStartIdx]
								for i := 0; i < toAppend; i++ {
									outCol[outStartIdx] = val
									outStartIdx++
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		}
		o.builderState.left.setBuilderColumnState(initialBuilderState)
	}
	o.builderState.left.reset()
}

// buildRightGroups takes a []group and repeats each group numRepeats times.
// For example, given an input table:
//  R1 |  R2
//  --------
//  1  |  a
//  1  |  b
// and rightGroups = [{startIdx: 0, endIdx: 2, numRepeats: 3}]
// then buildRightGroups expands this to
//  R1 |  R2
//  --------
//  1  |  a
//  1  |  b
//  1  |  a
//  1  |  b
//  1  |  a
//  1  |  b
// Note: this is different from buildLeftGroups in that each group is not
// expanded but directly copied numRepeats times.
// SIDE EFFECTS: writes into o.output.
func (o *mergeJoinOp) buildRightGroups(
	rightGroups []group,
	colOffset int,
	input *mergeJoinInput,
	batch coldata.Batch,
	destStartIdx uint16,
) {
	initialBuilderState := o.builderState.right
	sel := batch.Selection()
	outputBatchSize := int(o.outputBatchSize)

	// Loop over every column.
RightColLoop:
	for ; o.builderState.right.colIdx < len(input.outCols); o.builderState.right.colIdx++ {
		colIdx := input.outCols[o.builderState.right.colIdx]
		outStartIdx := int(destStartIdx)
		out := o.output.ColVec(int(colIdx) + colOffset)
		src := batch.ColVec(int(colIdx))
		colType := input.sourceTypes[colIdx]

		if sel != nil {
			if src.MaybeHasNulls() {

				switch colType {
				case types.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case types.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		} else {
			if src.MaybeHasNulls() {

				switch colType {
				case types.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case types.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		}

		o.builderState.right.setBuilderColumnState(initialBuilderState)
	}
	o.builderState.right.reset()
}

// isBufferedGroupFinished checks to see whether or not the buffered group
// corresponding to input continues in batch.
func (o *mergeJoinOp) isBufferedGroupFinished(
	input *mergeJoinInput, batch coldata.Batch, rowIdx int,
) bool {
	if batch.Length() == 0 {
		return true
	}
	sel := batch.Selection()
	bufferedGroup := o.proberState.lBufferedGroup
	if input == &o.right {
		bufferedGroup = o.proberState.rBufferedGroup
	}
	lastBufferedTupleIdx := bufferedGroup.length - 1

	// Check all equality columns in the first row of batch to make sure we're in
	// the same group.
	for _, colIdx := range input.eqCols[:len(input.eqCols)] {
		colTyp := input.sourceTypes[colIdx]

		switch colTyp {
		case types.Bool:
			if input == &o.left {
				// Nulls only from the left input can be saved in the buffer, so we do
				// not perform this check on the right input.
				// TODO(yuzefovich): update this when new join types are supported.
				if o.joinType == sqlbase.LeftOuterJoin {
					if bufferedGroup.ColVec(int(colIdx)).Nulls().NullAt64(uint64(lastBufferedTupleIdx)) {
						return true
					}
				}
			}
			prevVal := bufferedGroup.ColVec(int(colIdx)).Bool()[lastBufferedTupleIdx]
			var curVal bool
			if sel != nil {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(uint64(sel[rowIdx])) {
					return true
				}
				curVal = batch.ColVec(int(colIdx)).Bool()[sel[rowIdx]]
			} else {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(uint64(rowIdx)) {
					return true
				}
				curVal = batch.ColVec(int(colIdx)).Bool()[rowIdx]
			}
			var match bool
			match = tree.CompareBools(prevVal, curVal) == 0
			if !match {
				return true
			}
		case types.Bytes:
			if input == &o.left {
				// Nulls only from the left input can be saved in the buffer, so we do
				// not perform this check on the right input.
				// TODO(yuzefovich): update this when new join types are supported.
				if o.joinType == sqlbase.LeftOuterJoin {
					if bufferedGroup.ColVec(int(colIdx)).Nulls().NullAt64(uint64(lastBufferedTupleIdx)) {
						return true
					}
				}
			}
			prevVal := bufferedGroup.ColVec(int(colIdx)).Bytes()[lastBufferedTupleIdx]
			var curVal []byte
			if sel != nil {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(uint64(sel[rowIdx])) {
					return true
				}
				curVal = batch.ColVec(int(colIdx)).Bytes()[sel[rowIdx]]
			} else {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(uint64(rowIdx)) {
					return true
				}
				curVal = batch.ColVec(int(colIdx)).Bytes()[rowIdx]
			}
			var match bool
			match = bytes.Compare(prevVal, curVal) == 0
			if !match {
				return true
			}
		case types.Decimal:
			if input == &o.left {
				// Nulls only from the left input can be saved in the buffer, so we do
				// not perform this check on the right input.
				// TODO(yuzefovich): update this when new join types are supported.
				if o.joinType == sqlbase.LeftOuterJoin {
					if bufferedGroup.ColVec(int(colIdx)).Nulls().NullAt64(uint64(lastBufferedTupleIdx)) {
						return true
					}
				}
			}
			prevVal := bufferedGroup.ColVec(int(colIdx)).Decimal()[lastBufferedTupleIdx]
			var curVal apd.Decimal
			if sel != nil {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(uint64(sel[rowIdx])) {
					return true
				}
				curVal = batch.ColVec(int(colIdx)).Decimal()[sel[rowIdx]]
			} else {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(uint64(rowIdx)) {
					return true
				}
				curVal = batch.ColVec(int(colIdx)).Decimal()[rowIdx]
			}
			var match bool
			match = tree.CompareDecimals(&prevVal, &curVal) == 0
			if !match {
				return true
			}
		case types.Int8:
			if input == &o.left {
				// Nulls only from the left input can be saved in the buffer, so we do
				// not perform this check on the right input.
				// TODO(yuzefovich): update this when new join types are supported.
				if o.joinType == sqlbase.LeftOuterJoin {
					if bufferedGroup.ColVec(int(colIdx)).Nulls().NullAt64(uint64(lastBufferedTupleIdx)) {
						return true
					}
				}
			}
			prevVal := bufferedGroup.ColVec(int(colIdx)).Int8()[lastBufferedTupleIdx]
			var curVal int8
			if sel != nil {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(uint64(sel[rowIdx])) {
					return true
				}
				curVal = batch.ColVec(int(colIdx)).Int8()[sel[rowIdx]]
			} else {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(uint64(rowIdx)) {
					return true
				}
				curVal = batch.ColVec(int(colIdx)).Int8()[rowIdx]
			}
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Int16:
			if input == &o.left {
				// Nulls only from the left input can be saved in the buffer, so we do
				// not perform this check on the right input.
				// TODO(yuzefovich): update this when new join types are supported.
				if o.joinType == sqlbase.LeftOuterJoin {
					if bufferedGroup.ColVec(int(colIdx)).Nulls().NullAt64(uint64(lastBufferedTupleIdx)) {
						return true
					}
				}
			}
			prevVal := bufferedGroup.ColVec(int(colIdx)).Int16()[lastBufferedTupleIdx]
			var curVal int16
			if sel != nil {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(uint64(sel[rowIdx])) {
					return true
				}
				curVal = batch.ColVec(int(colIdx)).Int16()[sel[rowIdx]]
			} else {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(uint64(rowIdx)) {
					return true
				}
				curVal = batch.ColVec(int(colIdx)).Int16()[rowIdx]
			}
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Int32:
			if input == &o.left {
				// Nulls only from the left input can be saved in the buffer, so we do
				// not perform this check on the right input.
				// TODO(yuzefovich): update this when new join types are supported.
				if o.joinType == sqlbase.LeftOuterJoin {
					if bufferedGroup.ColVec(int(colIdx)).Nulls().NullAt64(uint64(lastBufferedTupleIdx)) {
						return true
					}
				}
			}
			prevVal := bufferedGroup.ColVec(int(colIdx)).Int32()[lastBufferedTupleIdx]
			var curVal int32
			if sel != nil {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(uint64(sel[rowIdx])) {
					return true
				}
				curVal = batch.ColVec(int(colIdx)).Int32()[sel[rowIdx]]
			} else {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(uint64(rowIdx)) {
					return true
				}
				curVal = batch.ColVec(int(colIdx)).Int32()[rowIdx]
			}
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Int64:
			if input == &o.left {
				// Nulls only from the left input can be saved in the buffer, so we do
				// not perform this check on the right input.
				// TODO(yuzefovich): update this when new join types are supported.
				if o.joinType == sqlbase.LeftOuterJoin {
					if bufferedGroup.ColVec(int(colIdx)).Nulls().NullAt64(uint64(lastBufferedTupleIdx)) {
						return true
					}
				}
			}
			prevVal := bufferedGroup.ColVec(int(colIdx)).Int64()[lastBufferedTupleIdx]
			var curVal int64
			if sel != nil {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(uint64(sel[rowIdx])) {
					return true
				}
				curVal = batch.ColVec(int(colIdx)).Int64()[sel[rowIdx]]
			} else {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(uint64(rowIdx)) {
					return true
				}
				curVal = batch.ColVec(int(colIdx)).Int64()[rowIdx]
			}
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Float32:
			if input == &o.left {
				// Nulls only from the left input can be saved in the buffer, so we do
				// not perform this check on the right input.
				// TODO(yuzefovich): update this when new join types are supported.
				if o.joinType == sqlbase.LeftOuterJoin {
					if bufferedGroup.ColVec(int(colIdx)).Nulls().NullAt64(uint64(lastBufferedTupleIdx)) {
						return true
					}
				}
			}
			prevVal := bufferedGroup.ColVec(int(colIdx)).Float32()[lastBufferedTupleIdx]
			var curVal float32
			if sel != nil {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(uint64(sel[rowIdx])) {
					return true
				}
				curVal = batch.ColVec(int(colIdx)).Float32()[sel[rowIdx]]
			} else {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(uint64(rowIdx)) {
					return true
				}
				curVal = batch.ColVec(int(colIdx)).Float32()[rowIdx]
			}
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Float64:
			if input == &o.left {
				// Nulls only from the left input can be saved in the buffer, so we do
				// not perform this check on the right input.
				// TODO(yuzefovich): update this when new join types are supported.
				if o.joinType == sqlbase.LeftOuterJoin {
					if bufferedGroup.ColVec(int(colIdx)).Nulls().NullAt64(uint64(lastBufferedTupleIdx)) {
						return true
					}
				}
			}
			prevVal := bufferedGroup.ColVec(int(colIdx)).Float64()[lastBufferedTupleIdx]
			var curVal float64
			if sel != nil {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(uint64(sel[rowIdx])) {
					return true
				}
				curVal = batch.ColVec(int(colIdx)).Float64()[sel[rowIdx]]
			} else {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(uint64(rowIdx)) {
					return true
				}
				curVal = batch.ColVec(int(colIdx)).Float64()[rowIdx]
			}
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		default:
			panic(fmt.Sprintf("unhandled type %d", colTyp))
		}
	}
	return false
}
