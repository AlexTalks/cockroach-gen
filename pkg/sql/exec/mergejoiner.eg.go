// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//     http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

package exec

import (
	"fmt"

	"github.com/cockroachdb/cockroach/pkg/sql/exec/coldata"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/types"
)

// buildLeftGroups takes a []group and expands each group into the output by repeating
// each row in the group numRepeats times. For example, given an input table:
//  L1 |  L2
//  --------
//  1  |  a
//  1  |  b
// and leftGroups = [{startIdx: 0, endIdx: 2, numRepeats: 3}]
// then buildLeftGroups expands this to
//  L1 |  L2
//  --------
//  1  |  a
//  1  |  a
//  1  |  a
//  1  |  b
//  1  |  b
//  1  |  b
// Note: this is different from buildRightGroups in that each row of group is repeated
// numRepeats times, instead of a simple copy of the group as a whole.
// buildLeftGroups returns the first available index of the output buffer as outStartIdx.
// SIDE EFFECTS: writes into o.output.
func (o *mergeJoinOp) buildLeftGroups(
	leftGroups []group,
	groupsLen int,
	colOffset int,
	input *mergeJoinInput,
	bat coldata.Batch,
	destStartIdx uint16,
) (outStartIdx uint16) {
	o.builderState.left.finished = false
	sel := bat.Selection()
	outStartIdx = destStartIdx
	initialBuilderState := o.builderState.left
	// Loop over every column.
LeftColLoop:
	for ; o.builderState.left.colIdx < len(input.outCols); o.builderState.left.colIdx++ {
		colIdx := input.outCols[o.builderState.left.colIdx]
		outStartIdx = destStartIdx
		out := o.output.ColVec(int(colIdx))
		src := bat.ColVec(int(colIdx))
		colType := input.sourceTypes[colIdx]

		switch colType {
		case types.Bool:
			srcCol := src.Bool()
			outCol := out.Bool()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							srcEndIdx := srcStartIdx + 1
							if outStartIdx < o.outputBatchSize {

								// TODO (georgeutsin): update template language to automatically generate template function function parameter definitions from expressions passed in.
								t_dest := out
								t_destStartIdx := int(outStartIdx)
								t_src := src
								t_srcStartIdx := srcStartIdx
								t_srcEndIdx := srcEndIdx
								t_sel := sel

								batchSize := t_srcEndIdx - t_srcStartIdx
								for i := 0; i < batchSize; i++ {
									t_dest.Bool()[i+t_destStartIdx] = t_src.Bool()[t_sel[i+t_srcStartIdx]]
								}

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return outStartIdx
								}
								o.builderState.left = initialBuilderState
								continue LeftColLoop

							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							if outStartIdx < o.outputBatchSize {

								outCol[outStartIdx] = srcCol[srcStartIdx]

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return outStartIdx
								}
								o.builderState.left = initialBuilderState

								continue LeftColLoop
							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Bytes:
			srcCol := src.Bytes()
			outCol := out.Bytes()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							srcEndIdx := srcStartIdx + 1
							if outStartIdx < o.outputBatchSize {

								// TODO (georgeutsin): update template language to automatically generate template function function parameter definitions from expressions passed in.
								t_dest := out
								t_destStartIdx := int(outStartIdx)
								t_src := src
								t_srcStartIdx := srcStartIdx
								t_srcEndIdx := srcEndIdx
								t_sel := sel

								batchSize := t_srcEndIdx - t_srcStartIdx
								for i := 0; i < batchSize; i++ {
									t_dest.Bytes()[i+t_destStartIdx] = t_src.Bytes()[t_sel[i+t_srcStartIdx]]
								}

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return outStartIdx
								}
								o.builderState.left = initialBuilderState
								continue LeftColLoop

							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							if outStartIdx < o.outputBatchSize {

								outCol[outStartIdx] = srcCol[srcStartIdx]

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return outStartIdx
								}
								o.builderState.left = initialBuilderState

								continue LeftColLoop
							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Decimal:
			srcCol := src.Decimal()
			outCol := out.Decimal()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							srcEndIdx := srcStartIdx + 1
							if outStartIdx < o.outputBatchSize {

								// TODO (georgeutsin): update template language to automatically generate template function function parameter definitions from expressions passed in.
								t_dest := out
								t_destStartIdx := int(outStartIdx)
								t_src := src
								t_srcStartIdx := srcStartIdx
								t_srcEndIdx := srcEndIdx
								t_sel := sel

								batchSize := t_srcEndIdx - t_srcStartIdx
								for i := 0; i < batchSize; i++ {
									t_dest.Decimal()[i+t_destStartIdx] = t_src.Decimal()[t_sel[i+t_srcStartIdx]]
								}

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return outStartIdx
								}
								o.builderState.left = initialBuilderState
								continue LeftColLoop

							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							if outStartIdx < o.outputBatchSize {

								outCol[outStartIdx] = srcCol[srcStartIdx]

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return outStartIdx
								}
								o.builderState.left = initialBuilderState

								continue LeftColLoop
							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Int8:
			srcCol := src.Int8()
			outCol := out.Int8()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							srcEndIdx := srcStartIdx + 1
							if outStartIdx < o.outputBatchSize {

								// TODO (georgeutsin): update template language to automatically generate template function function parameter definitions from expressions passed in.
								t_dest := out
								t_destStartIdx := int(outStartIdx)
								t_src := src
								t_srcStartIdx := srcStartIdx
								t_srcEndIdx := srcEndIdx
								t_sel := sel

								batchSize := t_srcEndIdx - t_srcStartIdx
								for i := 0; i < batchSize; i++ {
									t_dest.Int8()[i+t_destStartIdx] = t_src.Int8()[t_sel[i+t_srcStartIdx]]
								}

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return outStartIdx
								}
								o.builderState.left = initialBuilderState
								continue LeftColLoop

							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							if outStartIdx < o.outputBatchSize {

								outCol[outStartIdx] = srcCol[srcStartIdx]

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return outStartIdx
								}
								o.builderState.left = initialBuilderState

								continue LeftColLoop
							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Int16:
			srcCol := src.Int16()
			outCol := out.Int16()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							srcEndIdx := srcStartIdx + 1
							if outStartIdx < o.outputBatchSize {

								// TODO (georgeutsin): update template language to automatically generate template function function parameter definitions from expressions passed in.
								t_dest := out
								t_destStartIdx := int(outStartIdx)
								t_src := src
								t_srcStartIdx := srcStartIdx
								t_srcEndIdx := srcEndIdx
								t_sel := sel

								batchSize := t_srcEndIdx - t_srcStartIdx
								for i := 0; i < batchSize; i++ {
									t_dest.Int16()[i+t_destStartIdx] = t_src.Int16()[t_sel[i+t_srcStartIdx]]
								}

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return outStartIdx
								}
								o.builderState.left = initialBuilderState
								continue LeftColLoop

							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							if outStartIdx < o.outputBatchSize {

								outCol[outStartIdx] = srcCol[srcStartIdx]

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return outStartIdx
								}
								o.builderState.left = initialBuilderState

								continue LeftColLoop
							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Int32:
			srcCol := src.Int32()
			outCol := out.Int32()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							srcEndIdx := srcStartIdx + 1
							if outStartIdx < o.outputBatchSize {

								// TODO (georgeutsin): update template language to automatically generate template function function parameter definitions from expressions passed in.
								t_dest := out
								t_destStartIdx := int(outStartIdx)
								t_src := src
								t_srcStartIdx := srcStartIdx
								t_srcEndIdx := srcEndIdx
								t_sel := sel

								batchSize := t_srcEndIdx - t_srcStartIdx
								for i := 0; i < batchSize; i++ {
									t_dest.Int32()[i+t_destStartIdx] = t_src.Int32()[t_sel[i+t_srcStartIdx]]
								}

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return outStartIdx
								}
								o.builderState.left = initialBuilderState
								continue LeftColLoop

							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							if outStartIdx < o.outputBatchSize {

								outCol[outStartIdx] = srcCol[srcStartIdx]

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return outStartIdx
								}
								o.builderState.left = initialBuilderState

								continue LeftColLoop
							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Int64:
			srcCol := src.Int64()
			outCol := out.Int64()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							srcEndIdx := srcStartIdx + 1
							if outStartIdx < o.outputBatchSize {

								// TODO (georgeutsin): update template language to automatically generate template function function parameter definitions from expressions passed in.
								t_dest := out
								t_destStartIdx := int(outStartIdx)
								t_src := src
								t_srcStartIdx := srcStartIdx
								t_srcEndIdx := srcEndIdx
								t_sel := sel

								batchSize := t_srcEndIdx - t_srcStartIdx
								for i := 0; i < batchSize; i++ {
									t_dest.Int64()[i+t_destStartIdx] = t_src.Int64()[t_sel[i+t_srcStartIdx]]
								}

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return outStartIdx
								}
								o.builderState.left = initialBuilderState
								continue LeftColLoop

							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							if outStartIdx < o.outputBatchSize {

								outCol[outStartIdx] = srcCol[srcStartIdx]

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return outStartIdx
								}
								o.builderState.left = initialBuilderState

								continue LeftColLoop
							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Float32:
			srcCol := src.Float32()
			outCol := out.Float32()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							srcEndIdx := srcStartIdx + 1
							if outStartIdx < o.outputBatchSize {

								// TODO (georgeutsin): update template language to automatically generate template function function parameter definitions from expressions passed in.
								t_dest := out
								t_destStartIdx := int(outStartIdx)
								t_src := src
								t_srcStartIdx := srcStartIdx
								t_srcEndIdx := srcEndIdx
								t_sel := sel

								batchSize := t_srcEndIdx - t_srcStartIdx
								for i := 0; i < batchSize; i++ {
									t_dest.Float32()[i+t_destStartIdx] = t_src.Float32()[t_sel[i+t_srcStartIdx]]
								}

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return outStartIdx
								}
								o.builderState.left = initialBuilderState
								continue LeftColLoop

							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							if outStartIdx < o.outputBatchSize {

								outCol[outStartIdx] = srcCol[srcStartIdx]

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return outStartIdx
								}
								o.builderState.left = initialBuilderState

								continue LeftColLoop
							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Float64:
			srcCol := src.Float64()
			outCol := out.Float64()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							srcEndIdx := srcStartIdx + 1
							if outStartIdx < o.outputBatchSize {

								// TODO (georgeutsin): update template language to automatically generate template function function parameter definitions from expressions passed in.
								t_dest := out
								t_destStartIdx := int(outStartIdx)
								t_src := src
								t_srcStartIdx := srcStartIdx
								t_srcEndIdx := srcEndIdx
								t_sel := sel

								batchSize := t_srcEndIdx - t_srcStartIdx
								for i := 0; i < batchSize; i++ {
									t_dest.Float64()[i+t_destStartIdx] = t_src.Float64()[t_sel[i+t_srcStartIdx]]
								}

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return outStartIdx
								}
								o.builderState.left = initialBuilderState
								continue LeftColLoop

							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							if outStartIdx < o.outputBatchSize {

								outCol[outStartIdx] = srcCol[srcStartIdx]

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return outStartIdx
								}
								o.builderState.left = initialBuilderState

								continue LeftColLoop
							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			}
		default:
			panic(fmt.Sprintf("unhandled type %d", colType))
		}
		o.builderState.left.setBuilderColumnState(initialBuilderState)
	}

	if len(input.outCols) == 0 {
		outStartIdx = o.calculateOutputCount(leftGroups, groupsLen, outStartIdx)
	}

	o.builderState.left.reset()
	return outStartIdx
}

// buildRightGroups takes a []group and repeats each group numRepeats times.
// For example, given an input table:
//  R1 |  R2
//  --------
//  1  |  a
//  1  |  b
// and rightGroups = [{startIdx: 0, endIdx: 2, numRepeats: 3}]
// then buildRightGroups expands this to
//  R1 |  R2
//  --------
//  1  |  a
//  1  |  b
//  1  |  a
//  1  |  b
//  1  |  a
//  1  |  b
// Note: this is different from buildLeftGroups in that each group is not expanded,
// but directly copied numRepeats times.
// SIDE EFFECTS: writes into o.output.
func (o *mergeJoinOp) buildRightGroups(
	rightGroups []group,
	groupsLen int,
	colOffset int,
	input *mergeJoinInput,
	bat coldata.Batch,
	destStartIdx uint16,
) {
	o.builderState.right.finished = false
	initialBuilderState := o.builderState.right
	sel := bat.Selection()

	// Loop over every column.
RightColLoop:
	for ; o.builderState.right.colIdx < len(input.outCols); o.builderState.right.colIdx++ {
		colIdx := input.outCols[o.builderState.right.colIdx]
		outStartIdx := int(destStartIdx)
		out := o.output.ColVec(int(colIdx) + colOffset)
		src := bat.ColVec(int(colIdx))
		colType := input.sourceTypes[colIdx]

		switch colType {
		case types.Bool:
			srcCol := src.Bool()
			outCol := out.Bool()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						t_dest := out
						t_destStartIdx := outStartIdx
						t_src := src
						t_srcStartIdx := o.builderState.right.curSrcStartIdx
						t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
						t_sel := sel

						batchSize := t_srcEndIdx - t_srcStartIdx
						for i := 0; i < batchSize; i++ {
							t_dest.Bool()[i+t_destStartIdx] = t_src.Bool()[t_sel[i+t_srcStartIdx]]
						}

						outStartIdx += toAppend

						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							o.builderState.right = initialBuilderState
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						// Optimization to use assignment in the case that only 1 element is being appended.
						if toAppend == 1 {
							outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
						} else {
							copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
						}

						outStartIdx += toAppend

						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							o.builderState.right = initialBuilderState
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Bytes:
			srcCol := src.Bytes()
			outCol := out.Bytes()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						t_dest := out
						t_destStartIdx := outStartIdx
						t_src := src
						t_srcStartIdx := o.builderState.right.curSrcStartIdx
						t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
						t_sel := sel

						batchSize := t_srcEndIdx - t_srcStartIdx
						for i := 0; i < batchSize; i++ {
							t_dest.Bytes()[i+t_destStartIdx] = t_src.Bytes()[t_sel[i+t_srcStartIdx]]
						}

						outStartIdx += toAppend

						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							o.builderState.right = initialBuilderState
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						// Optimization to use assignment in the case that only 1 element is being appended.
						if toAppend == 1 {
							outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
						} else {
							copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
						}

						outStartIdx += toAppend

						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							o.builderState.right = initialBuilderState
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Decimal:
			srcCol := src.Decimal()
			outCol := out.Decimal()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						t_dest := out
						t_destStartIdx := outStartIdx
						t_src := src
						t_srcStartIdx := o.builderState.right.curSrcStartIdx
						t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
						t_sel := sel

						batchSize := t_srcEndIdx - t_srcStartIdx
						for i := 0; i < batchSize; i++ {
							t_dest.Decimal()[i+t_destStartIdx] = t_src.Decimal()[t_sel[i+t_srcStartIdx]]
						}

						outStartIdx += toAppend

						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							o.builderState.right = initialBuilderState
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						// Optimization to use assignment in the case that only 1 element is being appended.
						if toAppend == 1 {
							outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
						} else {
							copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
						}

						outStartIdx += toAppend

						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							o.builderState.right = initialBuilderState
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Int8:
			srcCol := src.Int8()
			outCol := out.Int8()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						t_dest := out
						t_destStartIdx := outStartIdx
						t_src := src
						t_srcStartIdx := o.builderState.right.curSrcStartIdx
						t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
						t_sel := sel

						batchSize := t_srcEndIdx - t_srcStartIdx
						for i := 0; i < batchSize; i++ {
							t_dest.Int8()[i+t_destStartIdx] = t_src.Int8()[t_sel[i+t_srcStartIdx]]
						}

						outStartIdx += toAppend

						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							o.builderState.right = initialBuilderState
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						// Optimization to use assignment in the case that only 1 element is being appended.
						if toAppend == 1 {
							outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
						} else {
							copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
						}

						outStartIdx += toAppend

						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							o.builderState.right = initialBuilderState
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Int16:
			srcCol := src.Int16()
			outCol := out.Int16()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						t_dest := out
						t_destStartIdx := outStartIdx
						t_src := src
						t_srcStartIdx := o.builderState.right.curSrcStartIdx
						t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
						t_sel := sel

						batchSize := t_srcEndIdx - t_srcStartIdx
						for i := 0; i < batchSize; i++ {
							t_dest.Int16()[i+t_destStartIdx] = t_src.Int16()[t_sel[i+t_srcStartIdx]]
						}

						outStartIdx += toAppend

						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							o.builderState.right = initialBuilderState
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						// Optimization to use assignment in the case that only 1 element is being appended.
						if toAppend == 1 {
							outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
						} else {
							copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
						}

						outStartIdx += toAppend

						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							o.builderState.right = initialBuilderState
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Int32:
			srcCol := src.Int32()
			outCol := out.Int32()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						t_dest := out
						t_destStartIdx := outStartIdx
						t_src := src
						t_srcStartIdx := o.builderState.right.curSrcStartIdx
						t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
						t_sel := sel

						batchSize := t_srcEndIdx - t_srcStartIdx
						for i := 0; i < batchSize; i++ {
							t_dest.Int32()[i+t_destStartIdx] = t_src.Int32()[t_sel[i+t_srcStartIdx]]
						}

						outStartIdx += toAppend

						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							o.builderState.right = initialBuilderState
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						// Optimization to use assignment in the case that only 1 element is being appended.
						if toAppend == 1 {
							outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
						} else {
							copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
						}

						outStartIdx += toAppend

						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							o.builderState.right = initialBuilderState
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Int64:
			srcCol := src.Int64()
			outCol := out.Int64()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						t_dest := out
						t_destStartIdx := outStartIdx
						t_src := src
						t_srcStartIdx := o.builderState.right.curSrcStartIdx
						t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
						t_sel := sel

						batchSize := t_srcEndIdx - t_srcStartIdx
						for i := 0; i < batchSize; i++ {
							t_dest.Int64()[i+t_destStartIdx] = t_src.Int64()[t_sel[i+t_srcStartIdx]]
						}

						outStartIdx += toAppend

						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							o.builderState.right = initialBuilderState
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						// Optimization to use assignment in the case that only 1 element is being appended.
						if toAppend == 1 {
							outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
						} else {
							copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
						}

						outStartIdx += toAppend

						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							o.builderState.right = initialBuilderState
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Float32:
			srcCol := src.Float32()
			outCol := out.Float32()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						t_dest := out
						t_destStartIdx := outStartIdx
						t_src := src
						t_srcStartIdx := o.builderState.right.curSrcStartIdx
						t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
						t_sel := sel

						batchSize := t_srcEndIdx - t_srcStartIdx
						for i := 0; i < batchSize; i++ {
							t_dest.Float32()[i+t_destStartIdx] = t_src.Float32()[t_sel[i+t_srcStartIdx]]
						}

						outStartIdx += toAppend

						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							o.builderState.right = initialBuilderState
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						// Optimization to use assignment in the case that only 1 element is being appended.
						if toAppend == 1 {
							outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
						} else {
							copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
						}

						outStartIdx += toAppend

						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							o.builderState.right = initialBuilderState
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Float64:
			srcCol := src.Float64()
			outCol := out.Float64()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						t_dest := out
						t_destStartIdx := outStartIdx
						t_src := src
						t_srcStartIdx := o.builderState.right.curSrcStartIdx
						t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
						t_sel := sel

						batchSize := t_srcEndIdx - t_srcStartIdx
						for i := 0; i < batchSize; i++ {
							t_dest.Float64()[i+t_destStartIdx] = t_src.Float64()[t_sel[i+t_srcStartIdx]]
						}

						outStartIdx += toAppend

						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							o.builderState.right = initialBuilderState
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						// Optimization to use assignment in the case that only 1 element is being appended.
						if toAppend == 1 {
							outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
						} else {
							copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
						}

						outStartIdx += toAppend

						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							o.builderState.right = initialBuilderState
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			}
		default:
			panic(fmt.Sprintf("unhandled type %d", colType))
		}
		o.builderState.right.setBuilderColumnState(initialBuilderState)
	}

	o.builderState.right.reset()
}
