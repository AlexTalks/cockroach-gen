// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package exec

import (
	"bytes"
	"context"
	"fmt"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/sql/distsqlpb"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/coldata"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/types"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
)

type mergeJoinInnerOp struct {
	mergeJoinBase
}

type mergeJoinLeftOuterOp struct {
	mergeJoinBase
}

type mergeJoinRightOuterOp struct {
	mergeJoinBase
}

func (o *mergeJoinInnerOp) probeBodyLSeltrueRSeltrue() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinInnerOp) probeBodyLSeltrueRSelfalse() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinInnerOp) probeBodyLSelfalseRSeltrue() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinInnerOp) probeBodyLSelfalseRSelfalse() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

									}

								}
							}

							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinLeftOuterOp) probeBodyLSeltrueRSeltrue() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinLeftOuterOp) probeBodyLSeltrueRSelfalse() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinLeftOuterOp) probeBodyLSelfalseRSeltrue() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinLeftOuterOp) probeBodyLSelfalseRSelfalse() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if lGroup.unmatched {
								if curLIdx+1 != curLLength {
									panic(fmt.Sprintf("unexpectedly length %d of the left unmatched group is not 1", curLLength-curLIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addLeftOuterGroup(curLIdx, curRIdx)
								curLIdx++
								areGroupsProcessed = true
							}

							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

										// All the rows on the left within the current group will not get
										// a match on the right, so we're adding each of them as a left
										// outer group.
										o.groups.addLeftOuterGroup(curLIdx-1, curRIdx)
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												break
											}
											o.groups.addLeftOuterGroup(curLIdx, curRIdx)
											curLIdx++
										}
									} else {
										curRIdx++

									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the left group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curLIdx < curLLength {
									o.groups.addLeftOuterGroup(curLIdx, curRIdx)
									curLIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinRightOuterOp) probeBodyLSeltrueRSeltrue() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinRightOuterOp) probeBodyLSeltrueRSelfalse() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {

									curLIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[lSel[curLIdx]]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinRightOuterOp) probeBodyLSelfalseRSeltrue() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(rSel[curRIdx])) {
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

func (o *mergeJoinRightOuterOp) probeBodyLSelfalseRSelfalse() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.MaybeHasNulls() {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if lVec.Nulls().NullAt64(uint64(curLIdx)) {

									curLIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											if lVec.Nulls().NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.MaybeHasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {
								if rVec.Nulls().NullAt64(uint64(curRIdx)) {

									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
									continue
								}

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											if rVec.Nulls().NullAt64(uint64(curRIdx)) {
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareBools(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareBools(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareBools(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Compare(lVal, rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = bytes.Compare(newLVal, lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = bytes.Compare(newRVal, rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							areGroupsProcessed := false

							if rGroup.unmatched {
								if curRIdx+1 != curRLength {
									panic(fmt.Sprintf("unexpectedly length %d of the right unmatched group is not 1", curRLength-curRIdx))
								}
								// The row already does not have a match, so we don't need to do any
								// additional processing.
								o.groups.addRightOuterGroup(curLIdx, curRIdx)
								curRIdx++
								areGroupsProcessed = true
							}
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength && !areGroupsProcessed {

								lVal := lKeys[curLIdx]
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 1, 1
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										curLIdx++
										for curLIdx < curLLength {
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										curRIdx++
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state
									// and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.appendToBufferedGroup(&o.left, o.proberState.lBatch, lSel, beginLIdx, lGroupLength)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.appendToBufferedGroup(&o.right, o.proberState.rBatch, rSel, beginRIdx, rGroupLength)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch, so add the group to the
									// circular buffer.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal
									if incrementLeft {
										curLIdx++

									} else {
										curRIdx++

										// All the rows on the right within the current group will not get a match on
										// the left, so we're adding each of them as a right outer group.
										o.groups.addRightOuterGroup(curLIdx, curRIdx-1)
										for curRIdx < curRLength {
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												break
											}
											o.groups.addRightOuterGroup(curLIdx, curRIdx)
											curRIdx++
										}
									}

								}
							}

							if !o.groups.isLastGroupInCol() && !areGroupsProcessed {
								// The current group is not the last one within the column, so it
								// cannot be extended into the next batch, and we need to process it
								// right now.
								// Any unprocessed row in the right group will not get a match, so
								// each one of them becomes a new unmatched group with a
								// corresponding null group.
								for curRIdx < curRLength {
									o.groups.addRightOuterGroup(curLIdx, curRIdx)
									curRIdx++
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the
							// last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving
		// the circular buffer pointer up.
		o.groups.finishedCol()
	}
}

// buildLeftGroups takes a []group and expands each group into the output by
// repeating each row in the group numRepeats times. For example, given an
// input table:
//  L1 |  L2
//  --------
//  1  |  a
//  1  |  b
// and leftGroups = [{startIdx: 0, endIdx: 2, numRepeats: 3}]
// then buildLeftGroups expands this to
//  L1 |  L2
//  --------
//  1  |  a
//  1  |  a
//  1  |  a
//  1  |  b
//  1  |  b
//  1  |  b
// Note: this is different from buildRightGroups in that each row of group is
// repeated numRepeats times, instead of a simple copy of the group as a whole.
// SIDE EFFECTS: writes into o.output.
func (o *mergeJoinBase) buildLeftGroups(
	leftGroups []group,
	colOffset int,
	input *mergeJoinInput,
	batch coldata.Batch,
	destStartIdx uint16,
) {
	sel := batch.Selection()
	initialBuilderState := o.builderState.left
	outputBatchSize := int(o.outputBatchSize)
	// Loop over every column.
LeftColLoop:
	for ; o.builderState.left.colIdx < len(input.outCols); o.builderState.left.colIdx++ {
		colIdx := input.outCols[o.builderState.left.colIdx]
		outStartIdx := int(destStartIdx)
		out := o.output.ColVec(int(colIdx))
		src := batch.ColVec(int(colIdx))
		colType := input.sourceTypes[colIdx]

		if sel != nil {
			if src.MaybeHasNulls() {

				switch colType {
				case types.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()
					var val bool
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()
					var val []byte
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()
					var val apd.Decimal
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()
					var val int8
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()
					var val int16
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()
					var val int32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()
					var val int64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()
					var val float32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()
					var val float64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case types.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()
					var val bool
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()
					var val []byte
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()
					var val apd.Decimal
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()
					var val int8
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()
					var val int16
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()
					var val int32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()
					var val int64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()
					var val float32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()
					var val float64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx
							srcStartIdx = int(sel[srcStartIdx])

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		} else {
			if src.MaybeHasNulls() {

				switch colType {
				case types.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()
					var val bool
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()
					var val []byte
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()
					var val apd.Decimal
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()
					var val int8
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()
					var val int16
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()
					var val int32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()
					var val int64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()
					var val float32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()
					var val float64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool
								isNull = src.Nulls().NullAt64(uint64(srcStartIdx))
								if isNull {
									out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
									outStartIdx += toAppend
								}

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case types.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()
					var val bool
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()
					var val []byte
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()
					var val apd.Decimal
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()
					var val int8
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()
					var val int16
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()
					var val int32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()
					var val int64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()
					var val float32
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				case types.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()
					var val float64
					var srcStartIdx int

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < len(leftGroups); o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx.
						// Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							// Repeat each row numRepeats times.
							srcStartIdx = o.builderState.left.curSrcStartIdx

							repeatsLeft := leftGroup.numRepeats - o.builderState.left.numRepeatsIdx
							toAppend := repeatsLeft
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if leftGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
								outStartIdx += toAppend
							} else {
								var isNull bool

								if !isNull {
									val = srcCol[srcStartIdx]
									for i := 0; i < toAppend; i++ {
										outCol[outStartIdx] = val
										outStartIdx++
									}
								}
							}

							if toAppend < repeatsLeft {
								// We didn't materialize all the rows in the group so save state and
								// move to the next column.
								o.builderState.left.numRepeatsIdx += toAppend
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPColIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop
							}

							o.builderState.left.numRepeatsIdx = zeroMJCPNumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPCurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPGroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		}
		o.builderState.left.setBuilderColumnState(initialBuilderState)
	}
	o.builderState.left.reset()
}

// buildRightGroups takes a []group and repeats each group numRepeats times.
// For example, given an input table:
//  R1 |  R2
//  --------
//  1  |  a
//  1  |  b
// and rightGroups = [{startIdx: 0, endIdx: 2, numRepeats: 3}]
// then buildRightGroups expands this to
//  R1 |  R2
//  --------
//  1  |  a
//  1  |  b
//  1  |  a
//  1  |  b
//  1  |  a
//  1  |  b
// Note: this is different from buildLeftGroups in that each group is not
// expanded but directly copied numRepeats times.
// SIDE EFFECTS: writes into o.output.
func (o *mergeJoinBase) buildRightGroups(
	rightGroups []group,
	colOffset int,
	input *mergeJoinInput,
	batch coldata.Batch,
	destStartIdx uint16,
) {
	initialBuilderState := o.builderState.right
	sel := batch.Selection()
	outputBatchSize := int(o.outputBatchSize)

	// Loop over every column.
RightColLoop:
	for ; o.builderState.right.colIdx < len(input.outCols); o.builderState.right.colIdx++ {
		colIdx := input.outCols[o.builderState.right.colIdx]
		outStartIdx := int(destStartIdx)
		out := o.output.ColVec(int(colIdx) + colOffset)
		src := batch.ColVec(int(colIdx))
		colType := input.sourceTypes[colIdx]

		if sel != nil {
			if src.MaybeHasNulls() {

				switch colType {
				case types.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().ExtendWithSel(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend), sel)

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case types.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[sel[o.builderState.right.curSrcStartIdx]]
								} else {
									for i := 0; i < toAppend; i++ {
										outCol[i+outStartIdx] = srcCol[sel[i+o.builderState.right.curSrcStartIdx]]
									}
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		} else {
			if src.MaybeHasNulls() {

				switch colType {
				case types.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {
								out.Nulls().Extend(src.Nulls(), uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case types.Bool:
					srcCol := src.Bool()
					outCol := out.Bool()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Bytes:
					srcCol := src.Bytes()
					outCol := out.Bytes()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Decimal:
					srcCol := src.Decimal()
					outCol := out.Decimal()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Int8:
					srcCol := src.Int8()
					outCol := out.Int8()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Int16:
					srcCol := src.Int16()
					outCol := out.Int16()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Int32:
					srcCol := src.Int32()
					outCol := out.Int32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Int64:
					srcCol := src.Int64()
					outCol := out.Int64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Float32:
					srcCol := src.Float32()
					outCol := out.Float32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				case types.Float64:
					srcCol := src.Float64()
					outCol := out.Float64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < len(rightGroups); o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPCurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > outputBatchSize {
								toAppend = outputBatchSize - outStartIdx
							}

							if rightGroup.nullGroup {
								out.Nulls().SetNullRange(uint64(outStartIdx), uint64(outStartIdx+toAppend))
							} else {

								// Optimization in the case that group length is 1, use assign
								// instead of copy.
								if toAppend == 1 {
									outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
								} else {
									copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
								}
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are
							// done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPColIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPCurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPNumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPGroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		}

		o.builderState.right.setBuilderColumnState(initialBuilderState)
	}
	o.builderState.right.reset()
}

// isBufferedGroupFinished checks to see whether or not the buffered group
// corresponding to input continues in batch.
func (o *mergeJoinBase) isBufferedGroupFinished(
	input *mergeJoinInput, batch coldata.Batch, rowIdx int,
) bool {
	if batch.Length() == 0 {
		return true
	}
	bufferedGroup := o.proberState.lBufferedGroup
	if input == &o.right {
		bufferedGroup = o.proberState.rBufferedGroup
	}
	lastBufferedTupleIdx := bufferedGroup.length - 1
	tupleToLookAtIdx := uint64(rowIdx)
	sel := batch.Selection()
	if sel != nil {
		tupleToLookAtIdx = uint64(sel[rowIdx])
	}

	// Check all equality columns in the first row of batch to make sure we're in
	// the same group.
	for _, colIdx := range input.eqCols[:len(input.eqCols)] {
		colTyp := input.sourceTypes[colIdx]

		switch colTyp {
		case types.Bool:
			// We perform this null check on every equality column of the last
			// buffered tuple regardless of the join type since it is done only once
			// per batch. In some cases (like INNER JOIN, or LEFT OUTER JOIN with the
			// right side being an input) this check will always return false since
			// nulls couldn't be buffered up though.
			if bufferedGroup.ColVec(int(colIdx)).Nulls().NullAt64(uint64(lastBufferedTupleIdx)) {
				return true
			}
			prevVal := bufferedGroup.ColVec(int(colIdx)).Bool()[lastBufferedTupleIdx]
			var curVal bool
			if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(tupleToLookAtIdx) {
				return true
			}
			curVal = batch.ColVec(int(colIdx)).Bool()[tupleToLookAtIdx]
			var match bool
			match = tree.CompareBools(prevVal, curVal) == 0
			if !match {
				return true
			}
		case types.Bytes:
			// We perform this null check on every equality column of the last
			// buffered tuple regardless of the join type since it is done only once
			// per batch. In some cases (like INNER JOIN, or LEFT OUTER JOIN with the
			// right side being an input) this check will always return false since
			// nulls couldn't be buffered up though.
			if bufferedGroup.ColVec(int(colIdx)).Nulls().NullAt64(uint64(lastBufferedTupleIdx)) {
				return true
			}
			prevVal := bufferedGroup.ColVec(int(colIdx)).Bytes()[lastBufferedTupleIdx]
			var curVal []byte
			if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(tupleToLookAtIdx) {
				return true
			}
			curVal = batch.ColVec(int(colIdx)).Bytes()[tupleToLookAtIdx]
			var match bool
			match = bytes.Compare(prevVal, curVal) == 0
			if !match {
				return true
			}
		case types.Decimal:
			// We perform this null check on every equality column of the last
			// buffered tuple regardless of the join type since it is done only once
			// per batch. In some cases (like INNER JOIN, or LEFT OUTER JOIN with the
			// right side being an input) this check will always return false since
			// nulls couldn't be buffered up though.
			if bufferedGroup.ColVec(int(colIdx)).Nulls().NullAt64(uint64(lastBufferedTupleIdx)) {
				return true
			}
			prevVal := bufferedGroup.ColVec(int(colIdx)).Decimal()[lastBufferedTupleIdx]
			var curVal apd.Decimal
			if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(tupleToLookAtIdx) {
				return true
			}
			curVal = batch.ColVec(int(colIdx)).Decimal()[tupleToLookAtIdx]
			var match bool
			match = tree.CompareDecimals(&prevVal, &curVal) == 0
			if !match {
				return true
			}
		case types.Int8:
			// We perform this null check on every equality column of the last
			// buffered tuple regardless of the join type since it is done only once
			// per batch. In some cases (like INNER JOIN, or LEFT OUTER JOIN with the
			// right side being an input) this check will always return false since
			// nulls couldn't be buffered up though.
			if bufferedGroup.ColVec(int(colIdx)).Nulls().NullAt64(uint64(lastBufferedTupleIdx)) {
				return true
			}
			prevVal := bufferedGroup.ColVec(int(colIdx)).Int8()[lastBufferedTupleIdx]
			var curVal int8
			if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(tupleToLookAtIdx) {
				return true
			}
			curVal = batch.ColVec(int(colIdx)).Int8()[tupleToLookAtIdx]
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Int16:
			// We perform this null check on every equality column of the last
			// buffered tuple regardless of the join type since it is done only once
			// per batch. In some cases (like INNER JOIN, or LEFT OUTER JOIN with the
			// right side being an input) this check will always return false since
			// nulls couldn't be buffered up though.
			if bufferedGroup.ColVec(int(colIdx)).Nulls().NullAt64(uint64(lastBufferedTupleIdx)) {
				return true
			}
			prevVal := bufferedGroup.ColVec(int(colIdx)).Int16()[lastBufferedTupleIdx]
			var curVal int16
			if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(tupleToLookAtIdx) {
				return true
			}
			curVal = batch.ColVec(int(colIdx)).Int16()[tupleToLookAtIdx]
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Int32:
			// We perform this null check on every equality column of the last
			// buffered tuple regardless of the join type since it is done only once
			// per batch. In some cases (like INNER JOIN, or LEFT OUTER JOIN with the
			// right side being an input) this check will always return false since
			// nulls couldn't be buffered up though.
			if bufferedGroup.ColVec(int(colIdx)).Nulls().NullAt64(uint64(lastBufferedTupleIdx)) {
				return true
			}
			prevVal := bufferedGroup.ColVec(int(colIdx)).Int32()[lastBufferedTupleIdx]
			var curVal int32
			if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(tupleToLookAtIdx) {
				return true
			}
			curVal = batch.ColVec(int(colIdx)).Int32()[tupleToLookAtIdx]
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Int64:
			// We perform this null check on every equality column of the last
			// buffered tuple regardless of the join type since it is done only once
			// per batch. In some cases (like INNER JOIN, or LEFT OUTER JOIN with the
			// right side being an input) this check will always return false since
			// nulls couldn't be buffered up though.
			if bufferedGroup.ColVec(int(colIdx)).Nulls().NullAt64(uint64(lastBufferedTupleIdx)) {
				return true
			}
			prevVal := bufferedGroup.ColVec(int(colIdx)).Int64()[lastBufferedTupleIdx]
			var curVal int64
			if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(tupleToLookAtIdx) {
				return true
			}
			curVal = batch.ColVec(int(colIdx)).Int64()[tupleToLookAtIdx]
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Float32:
			// We perform this null check on every equality column of the last
			// buffered tuple regardless of the join type since it is done only once
			// per batch. In some cases (like INNER JOIN, or LEFT OUTER JOIN with the
			// right side being an input) this check will always return false since
			// nulls couldn't be buffered up though.
			if bufferedGroup.ColVec(int(colIdx)).Nulls().NullAt64(uint64(lastBufferedTupleIdx)) {
				return true
			}
			prevVal := bufferedGroup.ColVec(int(colIdx)).Float32()[lastBufferedTupleIdx]
			var curVal float32
			if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(tupleToLookAtIdx) {
				return true
			}
			curVal = batch.ColVec(int(colIdx)).Float32()[tupleToLookAtIdx]
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Float64:
			// We perform this null check on every equality column of the last
			// buffered tuple regardless of the join type since it is done only once
			// per batch. In some cases (like INNER JOIN, or LEFT OUTER JOIN with the
			// right side being an input) this check will always return false since
			// nulls couldn't be buffered up though.
			if bufferedGroup.ColVec(int(colIdx)).Nulls().NullAt64(uint64(lastBufferedTupleIdx)) {
				return true
			}
			prevVal := bufferedGroup.ColVec(int(colIdx)).Float64()[lastBufferedTupleIdx]
			var curVal float64
			if batch.ColVec(int(colIdx)).MaybeHasNulls() && batch.ColVec(int(colIdx)).Nulls().NullAt64(tupleToLookAtIdx) {
				return true
			}
			curVal = batch.ColVec(int(colIdx)).Float64()[tupleToLookAtIdx]
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		default:
			panic(fmt.Sprintf("unhandled type %d", colTyp))
		}
	}
	return false
}

// probe is where we generate the groups slices that are used in the build
// phase. We do this by first assuming that every row in both batches
// contributes to the cross product. Then, with every equality column, we
// filter out the rows that don't contribute to the cross product (i.e. they
// don't have a matching row on the other side in the case of an inner join),
// and set the correct cardinality.
// Note that in this phase, we do this for every group, except the last group
// in the batch.
func (o *mergeJoinInnerOp) probe() {
	o.groups.reset(o.proberState.lIdx, o.proberState.lLength, o.proberState.rIdx, o.proberState.rLength)
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
	if lSel != nil {
		if rSel != nil {
			o.probeBodyLSeltrueRSeltrue()
		} else {
			o.probeBodyLSeltrueRSelfalse()
		}
	} else {
		if rSel != nil {
			o.probeBodyLSelfalseRSeltrue()
		} else {
			o.probeBodyLSelfalseRSelfalse()
		}
	}
}

// probe is where we generate the groups slices that are used in the build
// phase. We do this by first assuming that every row in both batches
// contributes to the cross product. Then, with every equality column, we
// filter out the rows that don't contribute to the cross product (i.e. they
// don't have a matching row on the other side in the case of an inner join),
// and set the correct cardinality.
// Note that in this phase, we do this for every group, except the last group
// in the batch.
func (o *mergeJoinLeftOuterOp) probe() {
	o.groups.reset(o.proberState.lIdx, o.proberState.lLength, o.proberState.rIdx, o.proberState.rLength)
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
	if lSel != nil {
		if rSel != nil {
			o.probeBodyLSeltrueRSeltrue()
		} else {
			o.probeBodyLSeltrueRSelfalse()
		}
	} else {
		if rSel != nil {
			o.probeBodyLSelfalseRSeltrue()
		} else {
			o.probeBodyLSelfalseRSelfalse()
		}
	}
}

// probe is where we generate the groups slices that are used in the build
// phase. We do this by first assuming that every row in both batches
// contributes to the cross product. Then, with every equality column, we
// filter out the rows that don't contribute to the cross product (i.e. they
// don't have a matching row on the other side in the case of an inner join),
// and set the correct cardinality.
// Note that in this phase, we do this for every group, except the last group
// in the batch.
func (o *mergeJoinRightOuterOp) probe() {
	o.groups.reset(o.proberState.lIdx, o.proberState.lLength, o.proberState.rIdx, o.proberState.rLength)
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
	if lSel != nil {
		if rSel != nil {
			o.probeBodyLSeltrueRSeltrue()
		} else {
			o.probeBodyLSeltrueRSelfalse()
		}
	} else {
		if rSel != nil {
			o.probeBodyLSelfalseRSeltrue()
		} else {
			o.probeBodyLSelfalseRSelfalse()
		}
	}
}

// exhaustLeftSource sets up the builder to process any remaining tuples from
// the left source. It should only be called when the right source has been
// exhausted.
func (o *mergeJoinInnerOp) exhaustLeftSource() {
}

// exhaustLeftSource sets up the builder to process any remaining tuples from
// the left source. It should only be called when the right source has been
// exhausted.
func (o *mergeJoinLeftOuterOp) exhaustLeftSource() {
	// The capacity of builder state lGroups and rGroups is always at least 1
	// given the init.
	o.builderState.lGroups = o.builderState.lGroups[:1]
	o.builderState.lGroups[0] = group{
		rowStartIdx: o.proberState.lIdx,
		rowEndIdx:   o.proberState.lLength,
		numRepeats:  1,
		toBuild:     o.proberState.lLength - o.proberState.lIdx,
		unmatched:   true,
	}
	o.builderState.rGroups = o.builderState.rGroups[:1]
	o.builderState.rGroups[0] = group{
		rowStartIdx: o.proberState.lIdx,
		rowEndIdx:   o.proberState.lLength,
		numRepeats:  1,
		toBuild:     o.proberState.lLength - o.proberState.lIdx,
		nullGroup:   true,
	}
	o.builderState.lBatch = o.proberState.lBatch
	o.builderState.rBatch = o.proberState.rBatch

	o.proberState.lIdx = o.proberState.lLength
}

// exhaustLeftSource sets up the builder to process any remaining tuples from
// the left source. It should only be called when the right source has been
// exhausted.
func (o *mergeJoinRightOuterOp) exhaustLeftSource() {
}

// exhaustRightSource sets up the builder to process any remaining tuples from
// the right source. It should only be called when the left source has been
// exhausted.
func (o *mergeJoinInnerOp) exhaustRightSource() {
}

// exhaustRightSource sets up the builder to process any remaining tuples from
// the right source. It should only be called when the left source has been
// exhausted.
func (o *mergeJoinLeftOuterOp) exhaustRightSource() {
}

// exhaustRightSource sets up the builder to process any remaining tuples from
// the right source. It should only be called when the left source has been
// exhausted.
func (o *mergeJoinRightOuterOp) exhaustRightSource() {
	// The capacity of builder state lGroups and rGroups is always at least 1
	// given the init.
	o.builderState.lGroups = o.builderState.lGroups[:1]
	o.builderState.lGroups[0] = group{
		rowStartIdx: o.proberState.rIdx,
		rowEndIdx:   o.proberState.rLength,
		numRepeats:  1,
		toBuild:     o.proberState.rLength - o.proberState.rIdx,
		nullGroup:   true,
	}
	o.builderState.rGroups = o.builderState.rGroups[:1]
	o.builderState.rGroups[0] = group{
		rowStartIdx: o.proberState.rIdx,
		rowEndIdx:   o.proberState.rLength,
		numRepeats:  1,
		toBuild:     o.proberState.rLength - o.proberState.rIdx,
		unmatched:   true,
	}
	o.builderState.lBatch = o.proberState.lBatch
	o.builderState.rBatch = o.proberState.rBatch

	o.proberState.rIdx = o.proberState.rLength
}

func (o *mergeJoinInnerOp) Next(ctx context.Context) coldata.Batch {
	for {
		switch o.state {
		case mjEntry:
			if o.needToResetOutput {
				o.needToResetOutput = false
				for _, vec := range o.output.ColVecs() {
					// We only need to explicitly reset nulls since the values will be
					// copied over and the correct length will be set.
					vec.Nulls().UnsetNulls()
				}
			}
			o.initProberState(ctx)

			if o.nonEmptyBufferedGroup() {
				o.state = mjFinishBufferedGroup
				break
			}

			if o.sourceFinished() {
				o.state = mjSourceFinished
				break
			}

			o.state = mjProbe
		case mjSourceFinished:

			o.setBuilderSourceToBufferedGroup()
			o.outputReady = true
			o.state = mjBuild
		case mjFinishBufferedGroup:
			o.finishProbe(ctx)
			o.setBuilderSourceToBufferedGroup()
			o.state = mjBuild
		case mjProbe:
			o.probe()
			o.setBuilderSourceToBatch()
			o.state = mjBuild
		case mjBuild:
			o.build()

			if o.builderState.outFinished {
				o.state = mjEntry
				o.builderState.outFinished = false
			}

			if o.outputReady || o.builderState.outCount == o.outputBatchSize {
				o.output.SetSelection(false)
				o.output.SetLength(o.builderState.outCount)
				// Reset builder out count.
				o.builderState.outCount = uint16(0)
				o.needToResetOutput = true
				o.outputReady = false
				return o.output
			}
		default:
			panic(fmt.Sprintf("unexpected merge joiner state in Next: %v", o.state))
		}
	}
}

func (o *mergeJoinLeftOuterOp) Next(ctx context.Context) coldata.Batch {
	for {
		switch o.state {
		case mjEntry:
			if o.needToResetOutput {
				o.needToResetOutput = false
				for _, vec := range o.output.ColVecs() {
					// We only need to explicitly reset nulls since the values will be
					// copied over and the correct length will be set.
					vec.Nulls().UnsetNulls()
				}
			}
			o.initProberState(ctx)

			if o.nonEmptyBufferedGroup() {
				o.state = mjFinishBufferedGroup
				break
			}

			if o.sourceFinished() {
				o.state = mjSourceFinished
				break
			}

			o.state = mjProbe
		case mjSourceFinished:

			// At least one of the sources is finished. If it was the right one,
			// then we need to emit remaining tuples from the left source with
			// nulls corresponding to the right one. But if the left source is
			// finished, then there is nothing left to do.
			if o.proberState.lIdx < o.proberState.lLength {
				o.exhaustLeftSource()
				// We do not set outputReady here to true because we want to put as
				// many unmatched tuples from the left into the output batch. Once
				// outCount reaches the desired output batch size, the output will be
				// returned.
			} else {
				o.outputReady = true
			}
			o.state = mjBuild
		case mjFinishBufferedGroup:
			o.finishProbe(ctx)
			o.setBuilderSourceToBufferedGroup()
			o.state = mjBuild
		case mjProbe:
			o.probe()
			o.setBuilderSourceToBatch()
			o.state = mjBuild
		case mjBuild:
			o.build()

			if o.builderState.outFinished {
				o.state = mjEntry
				o.builderState.outFinished = false
			}

			if o.outputReady || o.builderState.outCount == o.outputBatchSize {
				o.output.SetSelection(false)
				o.output.SetLength(o.builderState.outCount)
				// Reset builder out count.
				o.builderState.outCount = uint16(0)
				o.needToResetOutput = true
				o.outputReady = false
				return o.output
			}
		default:
			panic(fmt.Sprintf("unexpected merge joiner state in Next: %v", o.state))
		}
	}
}

func (o *mergeJoinRightOuterOp) Next(ctx context.Context) coldata.Batch {
	for {
		switch o.state {
		case mjEntry:
			if o.needToResetOutput {
				o.needToResetOutput = false
				for _, vec := range o.output.ColVecs() {
					// We only need to explicitly reset nulls since the values will be
					// copied over and the correct length will be set.
					vec.Nulls().UnsetNulls()
				}
			}
			o.initProberState(ctx)

			if o.nonEmptyBufferedGroup() {
				o.state = mjFinishBufferedGroup
				break
			}

			if o.sourceFinished() {
				o.state = mjSourceFinished
				break
			}

			o.state = mjProbe
		case mjSourceFinished:

			// At least one of the sources is finished. If it was the left one,
			// then we need to emit remaining tuples from the right source with
			// nulls corresponding to the left one. But if the right source is
			// finished, then there is nothing left to do.
			if o.proberState.rIdx < o.proberState.rLength {
				o.exhaustRightSource()
				// We do not set outputReady here to true because we want to put as
				// many unmatched tuples from the right into the output batch. Once
				// outCount reaches the desired output batch size, the output will be
				// returned.
			} else {
				o.outputReady = true
			}
			o.state = mjBuild
		case mjFinishBufferedGroup:
			o.finishProbe(ctx)
			o.setBuilderSourceToBufferedGroup()
			o.state = mjBuild
		case mjProbe:
			o.probe()
			o.setBuilderSourceToBatch()
			o.state = mjBuild
		case mjBuild:
			o.build()

			if o.builderState.outFinished {
				o.state = mjEntry
				o.builderState.outFinished = false
			}

			if o.outputReady || o.builderState.outCount == o.outputBatchSize {
				o.output.SetSelection(false)
				o.output.SetLength(o.builderState.outCount)
				// Reset builder out count.
				o.builderState.outCount = uint16(0)
				o.needToResetOutput = true
				o.outputReady = false
				return o.output
			}
		default:
			panic(fmt.Sprintf("unexpected merge joiner state in Next: %v", o.state))
		}
	}
}
