// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//     http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

package exec

import (
	"bytes"
	"fmt"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/sql/distsqlpb"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/coldata"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/types"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
)

func (o *mergeJoinOp) probeBodyLSeltrueRSeltrue() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.HasNulls() {
			if rVec.HasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.HasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving the circular buffer pointer up.
		o.groups.finishedCol()
	}

}

func (o *mergeJoinOp) probeBodyLSeltrueRSelfalse() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.HasNulls() {
			if rVec.HasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(lSel[curLIdx])) {
									curLIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(lSel[curLIdx])) {
												lComplete = true
												break
											}
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.HasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// lSel[curLIdx] is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[lSel[curLIdx]]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[lSel[curLIdx]]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving the circular buffer pointer up.
		o.groups.finishedCol()
	}

}

func (o *mergeJoinOp) probeBodyLSelfalseRSeltrue() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.HasNulls() {
			if rVec.HasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.HasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(rSel[curRIdx])) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(rSel[curRIdx])) {
												rComplete = true
												break
											}
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// rSel[curRIdx] is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[rSel[curRIdx]]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[rSel[curRIdx]]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving the circular buffer pointer up.
		o.groups.finishedCol()
	}

}

func (o *mergeJoinOp) probeBodyLSelfalseRSelfalse() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		lVec := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx]))
		rVec := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx]))
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		if lVec.HasNulls() {
			if rVec.HasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if lVec.NullAt64(uint64(curLIdx)) {
									curLIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if lVec.NullAt64(uint64(curLIdx)) {
												lComplete = true
												break
											}
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		} else {
			if rVec.HasNulls() {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.
								if rVec.NullAt64(uint64(curRIdx)) {
									curRIdx++
									continue
								}

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											if rVec.NullAt64(uint64(curRIdx)) {
												rComplete = true
												break
											}
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			} else {
				if o.left.directions[eqColIdx] == distsqlpb.Ordering_Column_ASC {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) < 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal < rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				} else {

					switch colType {
					case types.Bool:
						lKeys := lVec.Bool()
						rKeys := rVec.Bool()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareBools(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Bytes:
						lKeys := lVec.Bytes()
						rKeys := rVec.Bytes()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = bytes.Equal(lVal, rVal)
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = bytes.Equal(newLVal, lVal)
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = bytes.Equal(newRVal, rVal)
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = bytes.Compare(lVal, rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Decimal:
						lKeys := lVec.Decimal()
						rKeys := rVec.Decimal()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = tree.CompareDecimals(&lVal, &rVal) == 0
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = tree.CompareDecimals(&newLVal, &lVal) == 0
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = tree.CompareDecimals(&newRVal, &rVal) == 0
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = tree.CompareDecimals(&lVal, &rVal) > 0

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int8:
						lKeys := lVec.Int8()
						rKeys := rVec.Int8()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int16:
						lKeys := lVec.Int16()
						rKeys := rVec.Int16()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int32:
						lKeys := lVec.Int32()
						rKeys := rVec.Int32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Int64:
						lKeys := lVec.Int64()
						rKeys := rVec.Int64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float32:
						lKeys := lVec.Float32()
						rKeys := rVec.Float32()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					case types.Float64:
						lKeys := lVec.Float64()
						rKeys := rVec.Float64()
						var lGroup, rGroup group
						for o.groups.nextGroupInCol(&lGroup, &rGroup) {
							curLIdx := lGroup.rowStartIdx
							curRIdx := rGroup.rowStartIdx
							curLLength := lGroup.rowEndIdx
							curRLength := rGroup.rowEndIdx
							// Expand or filter each group based on the current equality column.
							for curLIdx < curLLength && curRIdx < curRLength {
								// TODO(georgeutsin): change null check logic for non INNER joins.

								// curLIdx is the template type variable for the loop variable that's either
								// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
								lVal := lKeys[curLIdx]
								// curRIdx is the template type variable for the loop variable that's either
								// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
								rVal := rKeys[curRIdx]

								var match bool
								match = lVal == rVal
								if match {
									// Find the length of the groups on each side.
									lGroupLength, rGroupLength := 0, 0
									lComplete, rComplete := false, false
									beginLIdx, beginRIdx := curLIdx, curRIdx

									// Find the length of the group on the left.
									if curLLength == 0 {
										lGroupLength, lComplete = 0, true
									} else {
										for curLIdx < curLLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newLVal := lKeys[curLIdx]
											match = newLVal == lVal
											if !match {
												lComplete = true
												break
											}
											lGroupLength++
											curLIdx++
										}
									}

									// Find the length of the group on the right.
									if curRLength == 0 {
										rGroupLength, rComplete = 0, true
									} else {
										for curRIdx < curRLength {
											// TODO(georgeutsin): change null check logic for non INNER joins.
											newRVal := rKeys[curRIdx]
											match = newRVal == rVal
											if !match {
												rComplete = true
												break
											}
											rGroupLength++
											curRIdx++
										}
									}

									// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
									if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
										o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
										o.proberState.lIdx = lGroupLength + beginLIdx
										o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
										o.proberState.rIdx = rGroupLength + beginRIdx

										o.groups.finishedCol()
										break EqLoop
									}

									// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
									o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
								} else { // mismatch
									var incrementLeft bool
									incrementLeft = lVal > rVal

									if incrementLeft {
										curLIdx++
									} else {
										curRIdx++
									}
								}
							}
							// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
							o.proberState.lIdx = curLIdx
							o.proberState.rIdx = curRIdx
						}
					default:
						panic(fmt.Sprintf("unhandled type %d", colType))
					}
				}
			}
		}
		// Look at the groups associated with the next equality column by moving the circular buffer pointer up.
		o.groups.finishedCol()
	}

}

// buildLeftGroups takes a []group and expands each group into the output by repeating
// each row in the group numRepeats times. For example, given an input table:
//  L1 |  L2
//  --------
//  1  |  a
//  1  |  b
// and leftGroups = [{startIdx: 0, endIdx: 2, numRepeats: 3}]
// then buildLeftGroups expands this to
//  L1 |  L2
//  --------
//  1  |  a
//  1  |  a
//  1  |  a
//  1  |  b
//  1  |  b
//  1  |  b
// Note: this is different from buildRightGroups in that each row of group is repeated
// numRepeats times, instead of a simple copy of the group as a whole.
// SIDE EFFECTS: writes into o.output.
func (o *mergeJoinOp) buildLeftGroups(
	leftGroups []group,
	groupsLen int,
	colOffset int,
	input *mergeJoinInput,
	bat coldata.Batch,
	destStartIdx uint16,
) {
	o.builderState.left.finished = false
	sel := bat.Selection()
	outStartIdx := destStartIdx
	initialBuilderState := o.builderState.left
	// Loop over every column.
LeftColLoop:
	for ; o.builderState.left.colIdx < len(input.outCols); o.builderState.left.colIdx++ {
		colIdx := input.outCols[o.builderState.left.colIdx]
		outStartIdx = destStartIdx
		out := o.output.ColVec(int(colIdx))
		src := bat.ColVec(int(colIdx))
		colType := input.sourceTypes[colIdx]

		if sel != nil {
			if src.HasNulls() {

				switch colType {
				case types.Bool:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): create a SetNullRange(start, end) function in coldata.Nulls,
									//  and place this outside the tight loop.
									if src.NullAt64(uint64(srcStartIdx)) {
										out.SetNull64(uint64(outStartIdx))
									}

									// TODO (georgeutsin): update template language to automatically generate template
									//  function parameter definitions from expressions passed in.
									t_dest := out
									t_destStartIdx := int(outStartIdx)
									t_src := src
									t_srcStartIdx := srcStartIdx
									t_srcEndIdx := srcStartIdx + 1
									t_sel := sel

									batchSize := t_srcEndIdx - t_srcStartIdx
									for i := 0; i < batchSize; i++ {
										t_dest.Bool()[i+t_destStartIdx] = t_src.Bool()[t_sel[i+t_srcStartIdx]]
									}

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Bytes:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): create a SetNullRange(start, end) function in coldata.Nulls,
									//  and place this outside the tight loop.
									if src.NullAt64(uint64(srcStartIdx)) {
										out.SetNull64(uint64(outStartIdx))
									}

									// TODO (georgeutsin): update template language to automatically generate template
									//  function parameter definitions from expressions passed in.
									t_dest := out
									t_destStartIdx := int(outStartIdx)
									t_src := src
									t_srcStartIdx := srcStartIdx
									t_srcEndIdx := srcStartIdx + 1
									t_sel := sel

									batchSize := t_srcEndIdx - t_srcStartIdx
									for i := 0; i < batchSize; i++ {
										t_dest.Bytes()[i+t_destStartIdx] = t_src.Bytes()[t_sel[i+t_srcStartIdx]]
									}

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Decimal:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): create a SetNullRange(start, end) function in coldata.Nulls,
									//  and place this outside the tight loop.
									if src.NullAt64(uint64(srcStartIdx)) {
										out.SetNull64(uint64(outStartIdx))
									}

									// TODO (georgeutsin): update template language to automatically generate template
									//  function parameter definitions from expressions passed in.
									t_dest := out
									t_destStartIdx := int(outStartIdx)
									t_src := src
									t_srcStartIdx := srcStartIdx
									t_srcEndIdx := srcStartIdx + 1
									t_sel := sel

									batchSize := t_srcEndIdx - t_srcStartIdx
									for i := 0; i < batchSize; i++ {
										t_dest.Decimal()[i+t_destStartIdx] = t_src.Decimal()[t_sel[i+t_srcStartIdx]]
									}

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int8:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): create a SetNullRange(start, end) function in coldata.Nulls,
									//  and place this outside the tight loop.
									if src.NullAt64(uint64(srcStartIdx)) {
										out.SetNull64(uint64(outStartIdx))
									}

									// TODO (georgeutsin): update template language to automatically generate template
									//  function parameter definitions from expressions passed in.
									t_dest := out
									t_destStartIdx := int(outStartIdx)
									t_src := src
									t_srcStartIdx := srcStartIdx
									t_srcEndIdx := srcStartIdx + 1
									t_sel := sel

									batchSize := t_srcEndIdx - t_srcStartIdx
									for i := 0; i < batchSize; i++ {
										t_dest.Int8()[i+t_destStartIdx] = t_src.Int8()[t_sel[i+t_srcStartIdx]]
									}

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int16:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): create a SetNullRange(start, end) function in coldata.Nulls,
									//  and place this outside the tight loop.
									if src.NullAt64(uint64(srcStartIdx)) {
										out.SetNull64(uint64(outStartIdx))
									}

									// TODO (georgeutsin): update template language to automatically generate template
									//  function parameter definitions from expressions passed in.
									t_dest := out
									t_destStartIdx := int(outStartIdx)
									t_src := src
									t_srcStartIdx := srcStartIdx
									t_srcEndIdx := srcStartIdx + 1
									t_sel := sel

									batchSize := t_srcEndIdx - t_srcStartIdx
									for i := 0; i < batchSize; i++ {
										t_dest.Int16()[i+t_destStartIdx] = t_src.Int16()[t_sel[i+t_srcStartIdx]]
									}

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int32:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): create a SetNullRange(start, end) function in coldata.Nulls,
									//  and place this outside the tight loop.
									if src.NullAt64(uint64(srcStartIdx)) {
										out.SetNull64(uint64(outStartIdx))
									}

									// TODO (georgeutsin): update template language to automatically generate template
									//  function parameter definitions from expressions passed in.
									t_dest := out
									t_destStartIdx := int(outStartIdx)
									t_src := src
									t_srcStartIdx := srcStartIdx
									t_srcEndIdx := srcStartIdx + 1
									t_sel := sel

									batchSize := t_srcEndIdx - t_srcStartIdx
									for i := 0; i < batchSize; i++ {
										t_dest.Int32()[i+t_destStartIdx] = t_src.Int32()[t_sel[i+t_srcStartIdx]]
									}

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int64:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): create a SetNullRange(start, end) function in coldata.Nulls,
									//  and place this outside the tight loop.
									if src.NullAt64(uint64(srcStartIdx)) {
										out.SetNull64(uint64(outStartIdx))
									}

									// TODO (georgeutsin): update template language to automatically generate template
									//  function parameter definitions from expressions passed in.
									t_dest := out
									t_destStartIdx := int(outStartIdx)
									t_src := src
									t_srcStartIdx := srcStartIdx
									t_srcEndIdx := srcStartIdx + 1
									t_sel := sel

									batchSize := t_srcEndIdx - t_srcStartIdx
									for i := 0; i < batchSize; i++ {
										t_dest.Int64()[i+t_destStartIdx] = t_src.Int64()[t_sel[i+t_srcStartIdx]]
									}

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Float32:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): create a SetNullRange(start, end) function in coldata.Nulls,
									//  and place this outside the tight loop.
									if src.NullAt64(uint64(srcStartIdx)) {
										out.SetNull64(uint64(outStartIdx))
									}

									// TODO (georgeutsin): update template language to automatically generate template
									//  function parameter definitions from expressions passed in.
									t_dest := out
									t_destStartIdx := int(outStartIdx)
									t_src := src
									t_srcStartIdx := srcStartIdx
									t_srcEndIdx := srcStartIdx + 1
									t_sel := sel

									batchSize := t_srcEndIdx - t_srcStartIdx
									for i := 0; i < batchSize; i++ {
										t_dest.Float32()[i+t_destStartIdx] = t_src.Float32()[t_sel[i+t_srcStartIdx]]
									}

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Float64:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): create a SetNullRange(start, end) function in coldata.Nulls,
									//  and place this outside the tight loop.
									if src.NullAt64(uint64(srcStartIdx)) {
										out.SetNull64(uint64(outStartIdx))
									}

									// TODO (georgeutsin): update template language to automatically generate template
									//  function parameter definitions from expressions passed in.
									t_dest := out
									t_destStartIdx := int(outStartIdx)
									t_src := src
									t_srcStartIdx := srcStartIdx
									t_srcEndIdx := srcStartIdx + 1
									t_sel := sel

									batchSize := t_srcEndIdx - t_srcStartIdx
									for i := 0; i < batchSize; i++ {
										t_dest.Float64()[i+t_destStartIdx] = t_src.Float64()[t_sel[i+t_srcStartIdx]]
									}

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case types.Bool:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): update template language to automatically generate template
									//  function parameter definitions from expressions passed in.
									t_dest := out
									t_destStartIdx := int(outStartIdx)
									t_src := src
									t_srcStartIdx := srcStartIdx
									t_srcEndIdx := srcStartIdx + 1
									t_sel := sel

									batchSize := t_srcEndIdx - t_srcStartIdx
									for i := 0; i < batchSize; i++ {
										t_dest.Bool()[i+t_destStartIdx] = t_src.Bool()[t_sel[i+t_srcStartIdx]]
									}

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Bytes:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): update template language to automatically generate template
									//  function parameter definitions from expressions passed in.
									t_dest := out
									t_destStartIdx := int(outStartIdx)
									t_src := src
									t_srcStartIdx := srcStartIdx
									t_srcEndIdx := srcStartIdx + 1
									t_sel := sel

									batchSize := t_srcEndIdx - t_srcStartIdx
									for i := 0; i < batchSize; i++ {
										t_dest.Bytes()[i+t_destStartIdx] = t_src.Bytes()[t_sel[i+t_srcStartIdx]]
									}

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Decimal:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): update template language to automatically generate template
									//  function parameter definitions from expressions passed in.
									t_dest := out
									t_destStartIdx := int(outStartIdx)
									t_src := src
									t_srcStartIdx := srcStartIdx
									t_srcEndIdx := srcStartIdx + 1
									t_sel := sel

									batchSize := t_srcEndIdx - t_srcStartIdx
									for i := 0; i < batchSize; i++ {
										t_dest.Decimal()[i+t_destStartIdx] = t_src.Decimal()[t_sel[i+t_srcStartIdx]]
									}

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int8:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): update template language to automatically generate template
									//  function parameter definitions from expressions passed in.
									t_dest := out
									t_destStartIdx := int(outStartIdx)
									t_src := src
									t_srcStartIdx := srcStartIdx
									t_srcEndIdx := srcStartIdx + 1
									t_sel := sel

									batchSize := t_srcEndIdx - t_srcStartIdx
									for i := 0; i < batchSize; i++ {
										t_dest.Int8()[i+t_destStartIdx] = t_src.Int8()[t_sel[i+t_srcStartIdx]]
									}

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int16:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): update template language to automatically generate template
									//  function parameter definitions from expressions passed in.
									t_dest := out
									t_destStartIdx := int(outStartIdx)
									t_src := src
									t_srcStartIdx := srcStartIdx
									t_srcEndIdx := srcStartIdx + 1
									t_sel := sel

									batchSize := t_srcEndIdx - t_srcStartIdx
									for i := 0; i < batchSize; i++ {
										t_dest.Int16()[i+t_destStartIdx] = t_src.Int16()[t_sel[i+t_srcStartIdx]]
									}

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int32:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): update template language to automatically generate template
									//  function parameter definitions from expressions passed in.
									t_dest := out
									t_destStartIdx := int(outStartIdx)
									t_src := src
									t_srcStartIdx := srcStartIdx
									t_srcEndIdx := srcStartIdx + 1
									t_sel := sel

									batchSize := t_srcEndIdx - t_srcStartIdx
									for i := 0; i < batchSize; i++ {
										t_dest.Int32()[i+t_destStartIdx] = t_src.Int32()[t_sel[i+t_srcStartIdx]]
									}

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int64:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): update template language to automatically generate template
									//  function parameter definitions from expressions passed in.
									t_dest := out
									t_destStartIdx := int(outStartIdx)
									t_src := src
									t_srcStartIdx := srcStartIdx
									t_srcEndIdx := srcStartIdx + 1
									t_sel := sel

									batchSize := t_srcEndIdx - t_srcStartIdx
									for i := 0; i < batchSize; i++ {
										t_dest.Int64()[i+t_destStartIdx] = t_src.Int64()[t_sel[i+t_srcStartIdx]]
									}

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Float32:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): update template language to automatically generate template
									//  function parameter definitions from expressions passed in.
									t_dest := out
									t_destStartIdx := int(outStartIdx)
									t_src := src
									t_srcStartIdx := srcStartIdx
									t_srcEndIdx := srcStartIdx + 1
									t_sel := sel

									batchSize := t_srcEndIdx - t_srcStartIdx
									for i := 0; i < batchSize; i++ {
										t_dest.Float32()[i+t_destStartIdx] = t_src.Float32()[t_sel[i+t_srcStartIdx]]
									}

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Float64:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): update template language to automatically generate template
									//  function parameter definitions from expressions passed in.
									t_dest := out
									t_destStartIdx := int(outStartIdx)
									t_src := src
									t_srcStartIdx := srcStartIdx
									t_srcEndIdx := srcStartIdx + 1
									t_sel := sel

									batchSize := t_srcEndIdx - t_srcStartIdx
									for i := 0; i < batchSize; i++ {
										t_dest.Float64()[i+t_destStartIdx] = t_src.Float64()[t_sel[i+t_srcStartIdx]]
									}

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		} else {
			if src.HasNulls() {

				switch colType {
				case types.Bool:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Bool()
					outCol := out.Bool()

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): create a SetNullRange(start, end) function in coldata.Nulls,
									//  and place this outside the tight loop.
									if src.NullAt64(uint64(srcStartIdx)) {
										out.SetNull64(uint64(outStartIdx))
									}

									outCol[outStartIdx] = srcCol[srcStartIdx]

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Bytes:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Bytes()
					outCol := out.Bytes()

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): create a SetNullRange(start, end) function in coldata.Nulls,
									//  and place this outside the tight loop.
									if src.NullAt64(uint64(srcStartIdx)) {
										out.SetNull64(uint64(outStartIdx))
									}

									outCol[outStartIdx] = srcCol[srcStartIdx]

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Decimal:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Decimal()
					outCol := out.Decimal()

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): create a SetNullRange(start, end) function in coldata.Nulls,
									//  and place this outside the tight loop.
									if src.NullAt64(uint64(srcStartIdx)) {
										out.SetNull64(uint64(outStartIdx))
									}

									outCol[outStartIdx] = srcCol[srcStartIdx]

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int8:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Int8()
					outCol := out.Int8()

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): create a SetNullRange(start, end) function in coldata.Nulls,
									//  and place this outside the tight loop.
									if src.NullAt64(uint64(srcStartIdx)) {
										out.SetNull64(uint64(outStartIdx))
									}

									outCol[outStartIdx] = srcCol[srcStartIdx]

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int16:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Int16()
					outCol := out.Int16()

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): create a SetNullRange(start, end) function in coldata.Nulls,
									//  and place this outside the tight loop.
									if src.NullAt64(uint64(srcStartIdx)) {
										out.SetNull64(uint64(outStartIdx))
									}

									outCol[outStartIdx] = srcCol[srcStartIdx]

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int32:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Int32()
					outCol := out.Int32()

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): create a SetNullRange(start, end) function in coldata.Nulls,
									//  and place this outside the tight loop.
									if src.NullAt64(uint64(srcStartIdx)) {
										out.SetNull64(uint64(outStartIdx))
									}

									outCol[outStartIdx] = srcCol[srcStartIdx]

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int64:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Int64()
					outCol := out.Int64()

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): create a SetNullRange(start, end) function in coldata.Nulls,
									//  and place this outside the tight loop.
									if src.NullAt64(uint64(srcStartIdx)) {
										out.SetNull64(uint64(outStartIdx))
									}

									outCol[outStartIdx] = srcCol[srcStartIdx]

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Float32:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Float32()
					outCol := out.Float32()

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): create a SetNullRange(start, end) function in coldata.Nulls,
									//  and place this outside the tight loop.
									if src.NullAt64(uint64(srcStartIdx)) {
										out.SetNull64(uint64(outStartIdx))
									}

									outCol[outStartIdx] = srcCol[srcStartIdx]

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Float64:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Float64()
					outCol := out.Float64()

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									// TODO (georgeutsin): create a SetNullRange(start, end) function in coldata.Nulls,
									//  and place this outside the tight loop.
									if src.NullAt64(uint64(srcStartIdx)) {
										out.SetNull64(uint64(outStartIdx))
									}

									outCol[outStartIdx] = srcCol[srcStartIdx]

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case types.Bool:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Bool()
					outCol := out.Bool()

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									outCol[outStartIdx] = srcCol[srcStartIdx]

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Bytes:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Bytes()
					outCol := out.Bytes()

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									outCol[outStartIdx] = srcCol[srcStartIdx]

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Decimal:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Decimal()
					outCol := out.Decimal()

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									outCol[outStartIdx] = srcCol[srcStartIdx]

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int8:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Int8()
					outCol := out.Int8()

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									outCol[outStartIdx] = srcCol[srcStartIdx]

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int16:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Int16()
					outCol := out.Int16()

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									outCol[outStartIdx] = srcCol[srcStartIdx]

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int32:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Int32()
					outCol := out.Int32()

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									outCol[outStartIdx] = srcCol[srcStartIdx]

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Int64:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Int64()
					outCol := out.Int64()

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									outCol[outStartIdx] = srcCol[srcStartIdx]

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Float32:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Float32()
					outCol := out.Float32()

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									outCol[outStartIdx] = srcCol[srcStartIdx]

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				case types.Float64:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Float64()
					outCol := out.Float64()

					// Loop over every group.
					for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
						leftGroup := &leftGroups[o.builderState.left.groupsIdx]
						// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
						if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
						}
						// Loop over every row in the group.
						for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							// Repeat each row numRepeats times.
							for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
								if outStartIdx < o.outputBatchSize {

									outCol[outStartIdx] = srcCol[srcStartIdx]

									outStartIdx++
								} else {
									if o.builderState.left.colIdx == len(input.outCols)-1 {
										o.builderState.left.colIdx = zeroMJCPcolIdx
										return
									}
									o.builderState.left.setBuilderColumnState(initialBuilderState)
									continue LeftColLoop

								}
							}
							o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
						}
						o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		}

		o.builderState.left.setBuilderColumnState(initialBuilderState)
	}

	o.builderState.left.reset()
}

// buildRightGroups takes a []group and repeats each group numRepeats times.
// For example, given an input table:
//  R1 |  R2
//  --------
//  1  |  a
//  1  |  b
// and rightGroups = [{startIdx: 0, endIdx: 2, numRepeats: 3}]
// then buildRightGroups expands this to
//  R1 |  R2
//  --------
//  1  |  a
//  1  |  b
//  1  |  a
//  1  |  b
//  1  |  a
//  1  |  b
// Note: this is different from buildLeftGroups in that each group is not expanded,
// but directly copied numRepeats times.
// SIDE EFFECTS: writes into o.output.
func (o *mergeJoinOp) buildRightGroups(
	rightGroups []group,
	groupsLen int,
	colOffset int,
	input *mergeJoinInput,
	bat coldata.Batch,
	destStartIdx uint16,
) {
	o.builderState.right.finished = false
	initialBuilderState := o.builderState.right
	sel := bat.Selection()

	// Loop over every column.
RightColLoop:
	for ; o.builderState.right.colIdx < len(input.outCols); o.builderState.right.colIdx++ {
		colIdx := input.outCols[o.builderState.right.colIdx]
		outStartIdx := int(destStartIdx)
		out := o.output.ColVec(int(colIdx) + colOffset)
		src := bat.ColVec(int(colIdx))
		colType := input.sourceTypes[colIdx]

		if sel != nil {
			if src.HasNulls() {

				switch colType {
				case types.Bool:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							out.ExtendNulls(src, uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

							// TODO (georgeutsin): update template language to automatically generate template
							//  function parameter definitions from expressions passed in.
							t_dest := out
							t_destStartIdx := outStartIdx
							t_src := src
							t_srcStartIdx := o.builderState.right.curSrcStartIdx
							t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
							t_sel := sel

							batchSize := t_srcEndIdx - t_srcStartIdx
							for i := 0; i < batchSize; i++ {
								t_dest.Bool()[i+t_destStartIdx] = t_src.Bool()[t_sel[i+t_srcStartIdx]]
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Bytes:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							out.ExtendNulls(src, uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

							// TODO (georgeutsin): update template language to automatically generate template
							//  function parameter definitions from expressions passed in.
							t_dest := out
							t_destStartIdx := outStartIdx
							t_src := src
							t_srcStartIdx := o.builderState.right.curSrcStartIdx
							t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
							t_sel := sel

							batchSize := t_srcEndIdx - t_srcStartIdx
							for i := 0; i < batchSize; i++ {
								t_dest.Bytes()[i+t_destStartIdx] = t_src.Bytes()[t_sel[i+t_srcStartIdx]]
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Decimal:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							out.ExtendNulls(src, uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

							// TODO (georgeutsin): update template language to automatically generate template
							//  function parameter definitions from expressions passed in.
							t_dest := out
							t_destStartIdx := outStartIdx
							t_src := src
							t_srcStartIdx := o.builderState.right.curSrcStartIdx
							t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
							t_sel := sel

							batchSize := t_srcEndIdx - t_srcStartIdx
							for i := 0; i < batchSize; i++ {
								t_dest.Decimal()[i+t_destStartIdx] = t_src.Decimal()[t_sel[i+t_srcStartIdx]]
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int8:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							out.ExtendNulls(src, uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

							// TODO (georgeutsin): update template language to automatically generate template
							//  function parameter definitions from expressions passed in.
							t_dest := out
							t_destStartIdx := outStartIdx
							t_src := src
							t_srcStartIdx := o.builderState.right.curSrcStartIdx
							t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
							t_sel := sel

							batchSize := t_srcEndIdx - t_srcStartIdx
							for i := 0; i < batchSize; i++ {
								t_dest.Int8()[i+t_destStartIdx] = t_src.Int8()[t_sel[i+t_srcStartIdx]]
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int16:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							out.ExtendNulls(src, uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

							// TODO (georgeutsin): update template language to automatically generate template
							//  function parameter definitions from expressions passed in.
							t_dest := out
							t_destStartIdx := outStartIdx
							t_src := src
							t_srcStartIdx := o.builderState.right.curSrcStartIdx
							t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
							t_sel := sel

							batchSize := t_srcEndIdx - t_srcStartIdx
							for i := 0; i < batchSize; i++ {
								t_dest.Int16()[i+t_destStartIdx] = t_src.Int16()[t_sel[i+t_srcStartIdx]]
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int32:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							out.ExtendNulls(src, uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

							// TODO (georgeutsin): update template language to automatically generate template
							//  function parameter definitions from expressions passed in.
							t_dest := out
							t_destStartIdx := outStartIdx
							t_src := src
							t_srcStartIdx := o.builderState.right.curSrcStartIdx
							t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
							t_sel := sel

							batchSize := t_srcEndIdx - t_srcStartIdx
							for i := 0; i < batchSize; i++ {
								t_dest.Int32()[i+t_destStartIdx] = t_src.Int32()[t_sel[i+t_srcStartIdx]]
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int64:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							out.ExtendNulls(src, uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

							// TODO (georgeutsin): update template language to automatically generate template
							//  function parameter definitions from expressions passed in.
							t_dest := out
							t_destStartIdx := outStartIdx
							t_src := src
							t_srcStartIdx := o.builderState.right.curSrcStartIdx
							t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
							t_sel := sel

							batchSize := t_srcEndIdx - t_srcStartIdx
							for i := 0; i < batchSize; i++ {
								t_dest.Int64()[i+t_destStartIdx] = t_src.Int64()[t_sel[i+t_srcStartIdx]]
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Float32:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							out.ExtendNulls(src, uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

							// TODO (georgeutsin): update template language to automatically generate template
							//  function parameter definitions from expressions passed in.
							t_dest := out
							t_destStartIdx := outStartIdx
							t_src := src
							t_srcStartIdx := o.builderState.right.curSrcStartIdx
							t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
							t_sel := sel

							batchSize := t_srcEndIdx - t_srcStartIdx
							for i := 0; i < batchSize; i++ {
								t_dest.Float32()[i+t_destStartIdx] = t_src.Float32()[t_sel[i+t_srcStartIdx]]
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Float64:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							out.ExtendNulls(src, uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

							// TODO (georgeutsin): update template language to automatically generate template
							//  function parameter definitions from expressions passed in.
							t_dest := out
							t_destStartIdx := outStartIdx
							t_src := src
							t_srcStartIdx := o.builderState.right.curSrcStartIdx
							t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
							t_sel := sel

							batchSize := t_srcEndIdx - t_srcStartIdx
							for i := 0; i < batchSize; i++ {
								t_dest.Float64()[i+t_destStartIdx] = t_src.Float64()[t_sel[i+t_srcStartIdx]]
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case types.Bool:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							// TODO (georgeutsin): update template language to automatically generate template
							//  function parameter definitions from expressions passed in.
							t_dest := out
							t_destStartIdx := outStartIdx
							t_src := src
							t_srcStartIdx := o.builderState.right.curSrcStartIdx
							t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
							t_sel := sel

							batchSize := t_srcEndIdx - t_srcStartIdx
							for i := 0; i < batchSize; i++ {
								t_dest.Bool()[i+t_destStartIdx] = t_src.Bool()[t_sel[i+t_srcStartIdx]]
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Bytes:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							// TODO (georgeutsin): update template language to automatically generate template
							//  function parameter definitions from expressions passed in.
							t_dest := out
							t_destStartIdx := outStartIdx
							t_src := src
							t_srcStartIdx := o.builderState.right.curSrcStartIdx
							t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
							t_sel := sel

							batchSize := t_srcEndIdx - t_srcStartIdx
							for i := 0; i < batchSize; i++ {
								t_dest.Bytes()[i+t_destStartIdx] = t_src.Bytes()[t_sel[i+t_srcStartIdx]]
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Decimal:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							// TODO (georgeutsin): update template language to automatically generate template
							//  function parameter definitions from expressions passed in.
							t_dest := out
							t_destStartIdx := outStartIdx
							t_src := src
							t_srcStartIdx := o.builderState.right.curSrcStartIdx
							t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
							t_sel := sel

							batchSize := t_srcEndIdx - t_srcStartIdx
							for i := 0; i < batchSize; i++ {
								t_dest.Decimal()[i+t_destStartIdx] = t_src.Decimal()[t_sel[i+t_srcStartIdx]]
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int8:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							// TODO (georgeutsin): update template language to automatically generate template
							//  function parameter definitions from expressions passed in.
							t_dest := out
							t_destStartIdx := outStartIdx
							t_src := src
							t_srcStartIdx := o.builderState.right.curSrcStartIdx
							t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
							t_sel := sel

							batchSize := t_srcEndIdx - t_srcStartIdx
							for i := 0; i < batchSize; i++ {
								t_dest.Int8()[i+t_destStartIdx] = t_src.Int8()[t_sel[i+t_srcStartIdx]]
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int16:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							// TODO (georgeutsin): update template language to automatically generate template
							//  function parameter definitions from expressions passed in.
							t_dest := out
							t_destStartIdx := outStartIdx
							t_src := src
							t_srcStartIdx := o.builderState.right.curSrcStartIdx
							t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
							t_sel := sel

							batchSize := t_srcEndIdx - t_srcStartIdx
							for i := 0; i < batchSize; i++ {
								t_dest.Int16()[i+t_destStartIdx] = t_src.Int16()[t_sel[i+t_srcStartIdx]]
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int32:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							// TODO (georgeutsin): update template language to automatically generate template
							//  function parameter definitions from expressions passed in.
							t_dest := out
							t_destStartIdx := outStartIdx
							t_src := src
							t_srcStartIdx := o.builderState.right.curSrcStartIdx
							t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
							t_sel := sel

							batchSize := t_srcEndIdx - t_srcStartIdx
							for i := 0; i < batchSize; i++ {
								t_dest.Int32()[i+t_destStartIdx] = t_src.Int32()[t_sel[i+t_srcStartIdx]]
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int64:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							// TODO (georgeutsin): update template language to automatically generate template
							//  function parameter definitions from expressions passed in.
							t_dest := out
							t_destStartIdx := outStartIdx
							t_src := src
							t_srcStartIdx := o.builderState.right.curSrcStartIdx
							t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
							t_sel := sel

							batchSize := t_srcEndIdx - t_srcStartIdx
							for i := 0; i < batchSize; i++ {
								t_dest.Int64()[i+t_destStartIdx] = t_src.Int64()[t_sel[i+t_srcStartIdx]]
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Float32:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							// TODO (georgeutsin): update template language to automatically generate template
							//  function parameter definitions from expressions passed in.
							t_dest := out
							t_destStartIdx := outStartIdx
							t_src := src
							t_srcStartIdx := o.builderState.right.curSrcStartIdx
							t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
							t_sel := sel

							batchSize := t_srcEndIdx - t_srcStartIdx
							for i := 0; i < batchSize; i++ {
								t_dest.Float32()[i+t_destStartIdx] = t_src.Float32()[t_sel[i+t_srcStartIdx]]
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Float64:
					// If there isn't a selection vector, create local variables outside the tight loop.

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							// TODO (georgeutsin): update template language to automatically generate template
							//  function parameter definitions from expressions passed in.
							t_dest := out
							t_destStartIdx := outStartIdx
							t_src := src
							t_srcStartIdx := o.builderState.right.curSrcStartIdx
							t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
							t_sel := sel

							batchSize := t_srcEndIdx - t_srcStartIdx
							for i := 0; i < batchSize; i++ {
								t_dest.Float64()[i+t_destStartIdx] = t_src.Float64()[t_sel[i+t_srcStartIdx]]
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		} else {
			if src.HasNulls() {

				switch colType {
				case types.Bool:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Bool()
					outCol := out.Bool()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							out.ExtendNulls(src, uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

							if toAppend == 1 {
								outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
							} else {
								copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Bytes:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Bytes()
					outCol := out.Bytes()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							out.ExtendNulls(src, uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

							if toAppend == 1 {
								outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
							} else {
								copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Decimal:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Decimal()
					outCol := out.Decimal()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							out.ExtendNulls(src, uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

							if toAppend == 1 {
								outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
							} else {
								copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int8:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Int8()
					outCol := out.Int8()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							out.ExtendNulls(src, uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

							if toAppend == 1 {
								outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
							} else {
								copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int16:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Int16()
					outCol := out.Int16()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							out.ExtendNulls(src, uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

							if toAppend == 1 {
								outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
							} else {
								copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int32:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Int32()
					outCol := out.Int32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							out.ExtendNulls(src, uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

							if toAppend == 1 {
								outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
							} else {
								copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int64:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Int64()
					outCol := out.Int64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							out.ExtendNulls(src, uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

							if toAppend == 1 {
								outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
							} else {
								copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Float32:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Float32()
					outCol := out.Float32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							out.ExtendNulls(src, uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

							if toAppend == 1 {
								outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
							} else {
								copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Float64:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Float64()
					outCol := out.Float64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							out.ExtendNulls(src, uint64(outStartIdx), uint16(o.builderState.right.curSrcStartIdx), uint16(toAppend))

							if toAppend == 1 {
								outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
							} else {
								copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			} else {

				switch colType {
				case types.Bool:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Bool()
					outCol := out.Bool()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							if toAppend == 1 {
								outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
							} else {
								copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Bytes:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Bytes()
					outCol := out.Bytes()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							if toAppend == 1 {
								outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
							} else {
								copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Decimal:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Decimal()
					outCol := out.Decimal()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							if toAppend == 1 {
								outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
							} else {
								copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int8:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Int8()
					outCol := out.Int8()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							if toAppend == 1 {
								outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
							} else {
								copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int16:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Int16()
					outCol := out.Int16()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							if toAppend == 1 {
								outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
							} else {
								copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int32:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Int32()
					outCol := out.Int32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							if toAppend == 1 {
								outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
							} else {
								copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Int64:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Int64()
					outCol := out.Int64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							if toAppend == 1 {
								outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
							} else {
								copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Float32:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Float32()
					outCol := out.Float32()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							if toAppend == 1 {
								outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
							} else {
								copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				case types.Float64:
					// If there isn't a selection vector, create local variables outside the tight loop.
					srcCol := src.Float64()
					outCol := out.Float64()

					// Loop over every group.
					for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
						rightGroup := &rightGroups[o.builderState.right.groupsIdx]
						// Repeat every group numRepeats times.
						for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
							if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
								o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
							}
							toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
							if outStartIdx+toAppend > int(o.outputBatchSize) {
								toAppend = int(o.outputBatchSize) - outStartIdx
							}

							if toAppend == 1 {
								outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
							} else {
								copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
							}

							outStartIdx += toAppend

							// If we haven't materialized all the rows from the group, then we are done with the current column.
							if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
								// If it's the last column, save state and return.
								if o.builderState.right.colIdx == len(input.outCols)-1 {
									o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
									o.builderState.right.colIdx = zeroMJCPcolIdx
									return
								}
								// Otherwise, reset to the initial state and begin the next column.
								o.builderState.right.setBuilderColumnState(initialBuilderState)
								continue RightColLoop
							}
							o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
						}
						o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
				default:
					panic(fmt.Sprintf("unhandled type %d", colType))
				}
			}
		}

		o.builderState.right.setBuilderColumnState(initialBuilderState)
	}

	o.builderState.right.reset()
}

// isGroupFinished checks to see whether or not the savedGroup continues in bat.
func (o *mergeJoinOp) isGroupFinished(
	input *mergeJoinInput,
	savedGroup coldata.Batch,
	savedGroupIdx int,
	bat coldata.Batch,
	rowIdx int,
	sel []uint16,
) bool {
	if bat.Length() == 0 {
		return true
	}

	// Check all equality columns in the first row of the bat to make sure we're in the same group.
	for _, colIdx := range input.eqCols[:len(input.eqCols)] {
		colTyp := input.sourceTypes[colIdx]

		switch colTyp {
		case types.Bool:
			prevVal := savedGroup.ColVec(int(colIdx)).Bool()[savedGroupIdx-1]
			var curVal bool
			if sel != nil {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if bat.ColVec(int(colIdx)).HasNulls() && bat.ColVec(int(colIdx)).NullAt64(uint64(sel[rowIdx])) {
					return true
				}
				curVal = bat.ColVec(int(colIdx)).Bool()[sel[rowIdx]]
			} else {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if bat.ColVec(int(colIdx)).HasNulls() && bat.ColVec(int(colIdx)).NullAt64(uint64(rowIdx)) {
					return true
				}
				curVal = bat.ColVec(int(colIdx)).Bool()[rowIdx]
			}
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Bytes:
			prevVal := savedGroup.ColVec(int(colIdx)).Bytes()[savedGroupIdx-1]
			var curVal []byte
			if sel != nil {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if bat.ColVec(int(colIdx)).HasNulls() && bat.ColVec(int(colIdx)).NullAt64(uint64(sel[rowIdx])) {
					return true
				}
				curVal = bat.ColVec(int(colIdx)).Bytes()[sel[rowIdx]]
			} else {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if bat.ColVec(int(colIdx)).HasNulls() && bat.ColVec(int(colIdx)).NullAt64(uint64(rowIdx)) {
					return true
				}
				curVal = bat.ColVec(int(colIdx)).Bytes()[rowIdx]
			}
			var match bool
			match = bytes.Equal(prevVal, curVal)
			if !match {
				return true
			}
		case types.Decimal:
			prevVal := savedGroup.ColVec(int(colIdx)).Decimal()[savedGroupIdx-1]
			var curVal apd.Decimal
			if sel != nil {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if bat.ColVec(int(colIdx)).HasNulls() && bat.ColVec(int(colIdx)).NullAt64(uint64(sel[rowIdx])) {
					return true
				}
				curVal = bat.ColVec(int(colIdx)).Decimal()[sel[rowIdx]]
			} else {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if bat.ColVec(int(colIdx)).HasNulls() && bat.ColVec(int(colIdx)).NullAt64(uint64(rowIdx)) {
					return true
				}
				curVal = bat.ColVec(int(colIdx)).Decimal()[rowIdx]
			}
			var match bool
			match = tree.CompareDecimals(&prevVal, &curVal) == 0
			if !match {
				return true
			}
		case types.Int8:
			prevVal := savedGroup.ColVec(int(colIdx)).Int8()[savedGroupIdx-1]
			var curVal int8
			if sel != nil {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if bat.ColVec(int(colIdx)).HasNulls() && bat.ColVec(int(colIdx)).NullAt64(uint64(sel[rowIdx])) {
					return true
				}
				curVal = bat.ColVec(int(colIdx)).Int8()[sel[rowIdx]]
			} else {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if bat.ColVec(int(colIdx)).HasNulls() && bat.ColVec(int(colIdx)).NullAt64(uint64(rowIdx)) {
					return true
				}
				curVal = bat.ColVec(int(colIdx)).Int8()[rowIdx]
			}
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Int16:
			prevVal := savedGroup.ColVec(int(colIdx)).Int16()[savedGroupIdx-1]
			var curVal int16
			if sel != nil {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if bat.ColVec(int(colIdx)).HasNulls() && bat.ColVec(int(colIdx)).NullAt64(uint64(sel[rowIdx])) {
					return true
				}
				curVal = bat.ColVec(int(colIdx)).Int16()[sel[rowIdx]]
			} else {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if bat.ColVec(int(colIdx)).HasNulls() && bat.ColVec(int(colIdx)).NullAt64(uint64(rowIdx)) {
					return true
				}
				curVal = bat.ColVec(int(colIdx)).Int16()[rowIdx]
			}
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Int32:
			prevVal := savedGroup.ColVec(int(colIdx)).Int32()[savedGroupIdx-1]
			var curVal int32
			if sel != nil {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if bat.ColVec(int(colIdx)).HasNulls() && bat.ColVec(int(colIdx)).NullAt64(uint64(sel[rowIdx])) {
					return true
				}
				curVal = bat.ColVec(int(colIdx)).Int32()[sel[rowIdx]]
			} else {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if bat.ColVec(int(colIdx)).HasNulls() && bat.ColVec(int(colIdx)).NullAt64(uint64(rowIdx)) {
					return true
				}
				curVal = bat.ColVec(int(colIdx)).Int32()[rowIdx]
			}
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Int64:
			prevVal := savedGroup.ColVec(int(colIdx)).Int64()[savedGroupIdx-1]
			var curVal int64
			if sel != nil {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if bat.ColVec(int(colIdx)).HasNulls() && bat.ColVec(int(colIdx)).NullAt64(uint64(sel[rowIdx])) {
					return true
				}
				curVal = bat.ColVec(int(colIdx)).Int64()[sel[rowIdx]]
			} else {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if bat.ColVec(int(colIdx)).HasNulls() && bat.ColVec(int(colIdx)).NullAt64(uint64(rowIdx)) {
					return true
				}
				curVal = bat.ColVec(int(colIdx)).Int64()[rowIdx]
			}
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Float32:
			prevVal := savedGroup.ColVec(int(colIdx)).Float32()[savedGroupIdx-1]
			var curVal float32
			if sel != nil {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if bat.ColVec(int(colIdx)).HasNulls() && bat.ColVec(int(colIdx)).NullAt64(uint64(sel[rowIdx])) {
					return true
				}
				curVal = bat.ColVec(int(colIdx)).Float32()[sel[rowIdx]]
			} else {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if bat.ColVec(int(colIdx)).HasNulls() && bat.ColVec(int(colIdx)).NullAt64(uint64(rowIdx)) {
					return true
				}
				curVal = bat.ColVec(int(colIdx)).Float32()[rowIdx]
			}
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Float64:
			prevVal := savedGroup.ColVec(int(colIdx)).Float64()[savedGroupIdx-1]
			var curVal float64
			if sel != nil {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if bat.ColVec(int(colIdx)).HasNulls() && bat.ColVec(int(colIdx)).NullAt64(uint64(sel[rowIdx])) {
					return true
				}
				curVal = bat.ColVec(int(colIdx)).Float64()[sel[rowIdx]]
			} else {
				// TODO (georgeutsin): Potentially update this logic for non INNER joins.
				if bat.ColVec(int(colIdx)).HasNulls() && bat.ColVec(int(colIdx)).NullAt64(uint64(rowIdx)) {
					return true
				}
				curVal = bat.ColVec(int(colIdx)).Float64()[rowIdx]
			}
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		default:
			panic(fmt.Sprintf("unhandled type %d", colTyp))
		}
	}
	return false
}
