// Code generated by execgen; DO NOT EDIT.
// Copyright 2019 The Cockroach Authors.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//     http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

package exec

import (
	"bytes"
	"fmt"

	"github.com/cockroachdb/apd"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/coldata"
	"github.com/cockroachdb/cockroach/pkg/sql/exec/types"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
)

func (o *mergeJoinOp) probeBodyLSeltrueRSeltrue() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		switch colType {
		case types.Bool:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Bool()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Bool()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// lSel[curLIdx] is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[lSel[curLIdx]]
					// rSel[curRIdx] is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[rSel[curRIdx]]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[lSel[curLIdx]]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[rSel[curRIdx]]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = tree.CompareBools(lVal, rVal) < 0
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Bytes:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Bytes()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Bytes()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// lSel[curLIdx] is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[lSel[curLIdx]]
					// rSel[curRIdx] is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[rSel[curRIdx]]

					var match bool
					match = bytes.Equal(lVal, rVal)
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[lSel[curLIdx]]
								match = bytes.Equal(newLVal, lVal)
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[rSel[curRIdx]]
								match = bytes.Equal(newRVal, rVal)
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = bytes.Compare(lVal, rVal) < 0
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Decimal:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Decimal()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Decimal()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// lSel[curLIdx] is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[lSel[curLIdx]]
					// rSel[curRIdx] is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[rSel[curRIdx]]

					var match bool
					match = tree.CompareDecimals(&lVal, &rVal) == 0
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[lSel[curLIdx]]
								match = tree.CompareDecimals(&newLVal, &lVal) == 0
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[rSel[curRIdx]]
								match = tree.CompareDecimals(&newRVal, &rVal) == 0
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = tree.CompareDecimals(&lVal, &rVal) < 0
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Int8:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Int8()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Int8()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// lSel[curLIdx] is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[lSel[curLIdx]]
					// rSel[curRIdx] is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[rSel[curRIdx]]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[lSel[curLIdx]]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[rSel[curRIdx]]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Int16:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Int16()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Int16()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// lSel[curLIdx] is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[lSel[curLIdx]]
					// rSel[curRIdx] is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[rSel[curRIdx]]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[lSel[curLIdx]]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[rSel[curRIdx]]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Int32:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Int32()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Int32()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// lSel[curLIdx] is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[lSel[curLIdx]]
					// rSel[curRIdx] is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[rSel[curRIdx]]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[lSel[curLIdx]]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[rSel[curRIdx]]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Int64:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Int64()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Int64()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// lSel[curLIdx] is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[lSel[curLIdx]]
					// rSel[curRIdx] is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[rSel[curRIdx]]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[lSel[curLIdx]]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[rSel[curRIdx]]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Float32:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Float32()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Float32()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// lSel[curLIdx] is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[lSel[curLIdx]]
					// rSel[curRIdx] is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[rSel[curRIdx]]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[lSel[curLIdx]]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[rSel[curRIdx]]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Float64:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Float64()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Float64()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// lSel[curLIdx] is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[lSel[curLIdx]]
					// rSel[curRIdx] is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[rSel[curRIdx]]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[lSel[curLIdx]]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[rSel[curRIdx]]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		default:
			panic(fmt.Sprintf("unhandled type %d", colType))
		}
		// Look at the groups associated with the next equality column by moving the circular buffer pointer up.
		o.groups.finishedCol()
	}

}

func (o *mergeJoinOp) probeBodyLSeltrueRSelfalse() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		switch colType {
		case types.Bool:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Bool()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Bool()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// lSel[curLIdx] is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[lSel[curLIdx]]
					// curRIdx is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[curRIdx]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[lSel[curLIdx]]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[curRIdx]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = tree.CompareBools(lVal, rVal) < 0
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Bytes:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Bytes()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Bytes()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// lSel[curLIdx] is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[lSel[curLIdx]]
					// curRIdx is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[curRIdx]

					var match bool
					match = bytes.Equal(lVal, rVal)
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[lSel[curLIdx]]
								match = bytes.Equal(newLVal, lVal)
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[curRIdx]
								match = bytes.Equal(newRVal, rVal)
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = bytes.Compare(lVal, rVal) < 0
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Decimal:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Decimal()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Decimal()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// lSel[curLIdx] is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[lSel[curLIdx]]
					// curRIdx is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[curRIdx]

					var match bool
					match = tree.CompareDecimals(&lVal, &rVal) == 0
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[lSel[curLIdx]]
								match = tree.CompareDecimals(&newLVal, &lVal) == 0
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[curRIdx]
								match = tree.CompareDecimals(&newRVal, &rVal) == 0
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = tree.CompareDecimals(&lVal, &rVal) < 0
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Int8:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Int8()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Int8()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// lSel[curLIdx] is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[lSel[curLIdx]]
					// curRIdx is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[curRIdx]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[lSel[curLIdx]]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[curRIdx]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Int16:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Int16()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Int16()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// lSel[curLIdx] is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[lSel[curLIdx]]
					// curRIdx is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[curRIdx]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[lSel[curLIdx]]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[curRIdx]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Int32:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Int32()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Int32()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// lSel[curLIdx] is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[lSel[curLIdx]]
					// curRIdx is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[curRIdx]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[lSel[curLIdx]]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[curRIdx]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Int64:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Int64()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Int64()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// lSel[curLIdx] is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[lSel[curLIdx]]
					// curRIdx is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[curRIdx]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[lSel[curLIdx]]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[curRIdx]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Float32:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Float32()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Float32()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// lSel[curLIdx] is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[lSel[curLIdx]]
					// curRIdx is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[curRIdx]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[lSel[curLIdx]]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[curRIdx]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Float64:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Float64()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Float64()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// lSel[curLIdx] is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[lSel[curLIdx]]
					// curRIdx is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[curRIdx]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[lSel[curLIdx]]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[curRIdx]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		default:
			panic(fmt.Sprintf("unhandled type %d", colType))
		}
		// Look at the groups associated with the next equality column by moving the circular buffer pointer up.
		o.groups.finishedCol()
	}

}

func (o *mergeJoinOp) probeBodyLSelfalseRSeltrue() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		switch colType {
		case types.Bool:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Bool()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Bool()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// curLIdx is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[curLIdx]
					// rSel[curRIdx] is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[rSel[curRIdx]]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[curLIdx]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[rSel[curRIdx]]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = tree.CompareBools(lVal, rVal) < 0
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Bytes:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Bytes()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Bytes()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// curLIdx is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[curLIdx]
					// rSel[curRIdx] is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[rSel[curRIdx]]

					var match bool
					match = bytes.Equal(lVal, rVal)
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[curLIdx]
								match = bytes.Equal(newLVal, lVal)
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[rSel[curRIdx]]
								match = bytes.Equal(newRVal, rVal)
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = bytes.Compare(lVal, rVal) < 0
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Decimal:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Decimal()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Decimal()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// curLIdx is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[curLIdx]
					// rSel[curRIdx] is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[rSel[curRIdx]]

					var match bool
					match = tree.CompareDecimals(&lVal, &rVal) == 0
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[curLIdx]
								match = tree.CompareDecimals(&newLVal, &lVal) == 0
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[rSel[curRIdx]]
								match = tree.CompareDecimals(&newRVal, &rVal) == 0
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = tree.CompareDecimals(&lVal, &rVal) < 0
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Int8:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Int8()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Int8()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// curLIdx is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[curLIdx]
					// rSel[curRIdx] is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[rSel[curRIdx]]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[curLIdx]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[rSel[curRIdx]]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Int16:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Int16()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Int16()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// curLIdx is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[curLIdx]
					// rSel[curRIdx] is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[rSel[curRIdx]]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[curLIdx]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[rSel[curRIdx]]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Int32:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Int32()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Int32()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// curLIdx is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[curLIdx]
					// rSel[curRIdx] is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[rSel[curRIdx]]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[curLIdx]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[rSel[curRIdx]]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Int64:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Int64()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Int64()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// curLIdx is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[curLIdx]
					// rSel[curRIdx] is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[rSel[curRIdx]]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[curLIdx]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[rSel[curRIdx]]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Float32:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Float32()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Float32()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// curLIdx is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[curLIdx]
					// rSel[curRIdx] is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[rSel[curRIdx]]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[curLIdx]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[rSel[curRIdx]]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Float64:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Float64()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Float64()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// curLIdx is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[curLIdx]
					// rSel[curRIdx] is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[rSel[curRIdx]]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[curLIdx]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[rSel[curRIdx]]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		default:
			panic(fmt.Sprintf("unhandled type %d", colType))
		}
		// Look at the groups associated with the next equality column by moving the circular buffer pointer up.
		o.groups.finishedCol()
	}

}

func (o *mergeJoinOp) probeBodyLSelfalseRSelfalse() {
	lSel := o.proberState.lBatch.Selection()
	rSel := o.proberState.rBatch.Selection()
EqLoop:
	for eqColIdx := 0; eqColIdx < len(o.left.eqCols); eqColIdx++ {
		colType := o.left.sourceTypes[int(o.left.eqCols[eqColIdx])]
		switch colType {
		case types.Bool:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Bool()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Bool()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// curLIdx is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[curLIdx]
					// curRIdx is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[curRIdx]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[curLIdx]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[curRIdx]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = tree.CompareBools(lVal, rVal) < 0
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Bytes:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Bytes()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Bytes()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// curLIdx is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[curLIdx]
					// curRIdx is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[curRIdx]

					var match bool
					match = bytes.Equal(lVal, rVal)
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[curLIdx]
								match = bytes.Equal(newLVal, lVal)
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[curRIdx]
								match = bytes.Equal(newRVal, rVal)
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = bytes.Compare(lVal, rVal) < 0
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Decimal:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Decimal()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Decimal()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// curLIdx is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[curLIdx]
					// curRIdx is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[curRIdx]

					var match bool
					match = tree.CompareDecimals(&lVal, &rVal) == 0
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[curLIdx]
								match = tree.CompareDecimals(&newLVal, &lVal) == 0
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[curRIdx]
								match = tree.CompareDecimals(&newRVal, &rVal) == 0
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = tree.CompareDecimals(&lVal, &rVal) < 0
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Int8:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Int8()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Int8()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// curLIdx is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[curLIdx]
					// curRIdx is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[curRIdx]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[curLIdx]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[curRIdx]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Int16:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Int16()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Int16()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// curLIdx is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[curLIdx]
					// curRIdx is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[curRIdx]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[curLIdx]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[curRIdx]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Int32:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Int32()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Int32()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// curLIdx is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[curLIdx]
					// curRIdx is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[curRIdx]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[curLIdx]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[curRIdx]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Int64:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Int64()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Int64()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// curLIdx is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[curLIdx]
					// curRIdx is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[curRIdx]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[curLIdx]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[curRIdx]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Float32:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Float32()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Float32()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// curLIdx is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[curLIdx]
					// curRIdx is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[curRIdx]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[curLIdx]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[curRIdx]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		case types.Float64:
			lKeys := o.proberState.lBatch.ColVec(int(o.left.eqCols[eqColIdx])).Float64()
			rKeys := o.proberState.rBatch.ColVec(int(o.right.eqCols[eqColIdx])).Float64()
			var lGroup, rGroup group
			for o.groups.nextGroupInCol(&lGroup, &rGroup) {
				curLIdx := lGroup.rowStartIdx
				curRIdx := rGroup.rowStartIdx
				curLLength := lGroup.rowEndIdx
				curRLength := rGroup.rowEndIdx
				// Expand or filter each group based on the current equality column.
				for curLIdx < curLLength && curRIdx < curRLength {
					// curLIdx is the template type variable for the loop variable that's either
					// curLIdx or lSel[curLIdx] depending on whether we're in a selection or not.
					lVal := lKeys[curLIdx]
					// curRIdx is the template type variable for the loop variable that's either
					// curRIdx or rSel[curRIdx] depending on whether we're in a selection or not.
					rVal := rKeys[curRIdx]

					var match bool
					match = lVal == rVal
					if match {
						// Find the length of the groups on each side.
						lGroupLength, rGroupLength := 0, 0
						lComplete, rComplete := false, false
						beginLIdx, beginRIdx := curLIdx, curRIdx

						// Find the length of the group on the left.
						if curLLength == 0 {
							lGroupLength, lComplete = 0, true
						} else {
							for curLIdx < curLLength {
								newLVal := lKeys[curLIdx]
								match = newLVal == lVal
								if !match {
									lComplete = true
									break
								}
								lGroupLength++
								curLIdx++
							}
						}

						// Find the length of the group on the right.
						if curRLength == 0 {
							rGroupLength, rComplete = 0, true
						} else {
							for curRIdx < curRLength {
								newRVal := rKeys[curRIdx]
								match = newRVal == rVal
								if !match {
									rComplete = true
									break
								}
								rGroupLength++
								curRIdx++
							}
						}

						// Last equality column and either group is incomplete. Save state and have it handled in the next iteration.
						if eqColIdx == len(o.left.eqCols)-1 && (!lComplete || !rComplete) {
							o.saveGroupToState(beginLIdx, lGroupLength, o.proberState.lBatch, lSel, &o.left, o.proberState.lGroup, &o.proberState.lGroupEndIdx)
							o.proberState.lIdx = lGroupLength + beginLIdx
							o.saveGroupToState(beginRIdx, rGroupLength, o.proberState.rBatch, rSel, &o.right, o.proberState.rGroup, &o.proberState.rGroupEndIdx)
							o.proberState.rIdx = rGroupLength + beginRIdx

							o.groups.finishedCol()
							break EqLoop
						}

						// Neither group ends with the batch so add the group to the circular buffer and increment the indices.
						o.groups.addGroupsToNextCol(beginLIdx, lGroupLength, beginRIdx, rGroupLength)
					} else { // mismatch
						var lSmaller bool
						lSmaller = lVal < rVal
						if lSmaller {
							curLIdx++
						} else {
							curRIdx++
						}
					}
				}
				// Both o.proberState.lIdx and o.proberState.rIdx should point to the last elements processed in their respective batches.
				o.proberState.lIdx = curLIdx
				o.proberState.rIdx = curRIdx
			}
		default:
			panic(fmt.Sprintf("unhandled type %d", colType))
		}
		// Look at the groups associated with the next equality column by moving the circular buffer pointer up.
		o.groups.finishedCol()
	}

}

// buildLeftGroups takes a []group and expands each group into the output by repeating
// each row in the group numRepeats times. For example, given an input table:
//  L1 |  L2
//  --------
//  1  |  a
//  1  |  b
// and leftGroups = [{startIdx: 0, endIdx: 2, numRepeats: 3}]
// then buildLeftGroups expands this to
//  L1 |  L2
//  --------
//  1  |  a
//  1  |  a
//  1  |  a
//  1  |  b
//  1  |  b
//  1  |  b
// Note: this is different from buildRightGroups in that each row of group is repeated
// numRepeats times, instead of a simple copy of the group as a whole.
// SIDE EFFECTS: writes into o.output.
func (o *mergeJoinOp) buildLeftGroups(
	leftGroups []group,
	groupsLen int,
	colOffset int,
	input *mergeJoinInput,
	bat coldata.Batch,
	destStartIdx uint16,
) {
	o.builderState.left.finished = false
	sel := bat.Selection()
	outStartIdx := destStartIdx
	initialBuilderState := o.builderState.left
	// Loop over every column.
LeftColLoop:
	for ; o.builderState.left.colIdx < len(input.outCols); o.builderState.left.colIdx++ {
		colIdx := input.outCols[o.builderState.left.colIdx]
		outStartIdx = destStartIdx
		out := o.output.ColVec(int(colIdx))
		src := bat.ColVec(int(colIdx))
		colType := input.sourceTypes[colIdx]

		switch colType {
		case types.Bool:
			srcCol := src.Bool()
			outCol := out.Bool()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := &leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							srcEndIdx := srcStartIdx + 1
							if outStartIdx < o.outputBatchSize {

								// TODO (georgeutsin): update template language to automatically generate template function function parameter definitions from expressions passed in.
								t_dest := out
								t_destStartIdx := int(outStartIdx)
								t_src := src
								t_srcStartIdx := srcStartIdx
								t_srcEndIdx := srcEndIdx
								t_sel := sel

								batchSize := t_srcEndIdx - t_srcStartIdx
								for i := 0; i < batchSize; i++ {
									t_dest.Bool()[i+t_destStartIdx] = t_src.Bool()[t_sel[i+t_srcStartIdx]]
								}

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop

							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := &leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							if outStartIdx < o.outputBatchSize {

								outCol[outStartIdx] = srcCol[srcStartIdx]

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)

								continue LeftColLoop
							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Bytes:
			srcCol := src.Bytes()
			outCol := out.Bytes()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := &leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							srcEndIdx := srcStartIdx + 1
							if outStartIdx < o.outputBatchSize {

								// TODO (georgeutsin): update template language to automatically generate template function function parameter definitions from expressions passed in.
								t_dest := out
								t_destStartIdx := int(outStartIdx)
								t_src := src
								t_srcStartIdx := srcStartIdx
								t_srcEndIdx := srcEndIdx
								t_sel := sel

								batchSize := t_srcEndIdx - t_srcStartIdx
								for i := 0; i < batchSize; i++ {
									t_dest.Bytes()[i+t_destStartIdx] = t_src.Bytes()[t_sel[i+t_srcStartIdx]]
								}

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop

							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := &leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							if outStartIdx < o.outputBatchSize {

								outCol[outStartIdx] = srcCol[srcStartIdx]

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)

								continue LeftColLoop
							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Decimal:
			srcCol := src.Decimal()
			outCol := out.Decimal()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := &leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							srcEndIdx := srcStartIdx + 1
							if outStartIdx < o.outputBatchSize {

								// TODO (georgeutsin): update template language to automatically generate template function function parameter definitions from expressions passed in.
								t_dest := out
								t_destStartIdx := int(outStartIdx)
								t_src := src
								t_srcStartIdx := srcStartIdx
								t_srcEndIdx := srcEndIdx
								t_sel := sel

								batchSize := t_srcEndIdx - t_srcStartIdx
								for i := 0; i < batchSize; i++ {
									t_dest.Decimal()[i+t_destStartIdx] = t_src.Decimal()[t_sel[i+t_srcStartIdx]]
								}

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop

							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := &leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							if outStartIdx < o.outputBatchSize {

								outCol[outStartIdx] = srcCol[srcStartIdx]

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)

								continue LeftColLoop
							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Int8:
			srcCol := src.Int8()
			outCol := out.Int8()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := &leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							srcEndIdx := srcStartIdx + 1
							if outStartIdx < o.outputBatchSize {

								// TODO (georgeutsin): update template language to automatically generate template function function parameter definitions from expressions passed in.
								t_dest := out
								t_destStartIdx := int(outStartIdx)
								t_src := src
								t_srcStartIdx := srcStartIdx
								t_srcEndIdx := srcEndIdx
								t_sel := sel

								batchSize := t_srcEndIdx - t_srcStartIdx
								for i := 0; i < batchSize; i++ {
									t_dest.Int8()[i+t_destStartIdx] = t_src.Int8()[t_sel[i+t_srcStartIdx]]
								}

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop

							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := &leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							if outStartIdx < o.outputBatchSize {

								outCol[outStartIdx] = srcCol[srcStartIdx]

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)

								continue LeftColLoop
							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Int16:
			srcCol := src.Int16()
			outCol := out.Int16()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := &leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							srcEndIdx := srcStartIdx + 1
							if outStartIdx < o.outputBatchSize {

								// TODO (georgeutsin): update template language to automatically generate template function function parameter definitions from expressions passed in.
								t_dest := out
								t_destStartIdx := int(outStartIdx)
								t_src := src
								t_srcStartIdx := srcStartIdx
								t_srcEndIdx := srcEndIdx
								t_sel := sel

								batchSize := t_srcEndIdx - t_srcStartIdx
								for i := 0; i < batchSize; i++ {
									t_dest.Int16()[i+t_destStartIdx] = t_src.Int16()[t_sel[i+t_srcStartIdx]]
								}

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop

							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := &leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							if outStartIdx < o.outputBatchSize {

								outCol[outStartIdx] = srcCol[srcStartIdx]

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)

								continue LeftColLoop
							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Int32:
			srcCol := src.Int32()
			outCol := out.Int32()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := &leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							srcEndIdx := srcStartIdx + 1
							if outStartIdx < o.outputBatchSize {

								// TODO (georgeutsin): update template language to automatically generate template function function parameter definitions from expressions passed in.
								t_dest := out
								t_destStartIdx := int(outStartIdx)
								t_src := src
								t_srcStartIdx := srcStartIdx
								t_srcEndIdx := srcEndIdx
								t_sel := sel

								batchSize := t_srcEndIdx - t_srcStartIdx
								for i := 0; i < batchSize; i++ {
									t_dest.Int32()[i+t_destStartIdx] = t_src.Int32()[t_sel[i+t_srcStartIdx]]
								}

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop

							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := &leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							if outStartIdx < o.outputBatchSize {

								outCol[outStartIdx] = srcCol[srcStartIdx]

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)

								continue LeftColLoop
							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Int64:
			srcCol := src.Int64()
			outCol := out.Int64()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := &leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							srcEndIdx := srcStartIdx + 1
							if outStartIdx < o.outputBatchSize {

								// TODO (georgeutsin): update template language to automatically generate template function function parameter definitions from expressions passed in.
								t_dest := out
								t_destStartIdx := int(outStartIdx)
								t_src := src
								t_srcStartIdx := srcStartIdx
								t_srcEndIdx := srcEndIdx
								t_sel := sel

								batchSize := t_srcEndIdx - t_srcStartIdx
								for i := 0; i < batchSize; i++ {
									t_dest.Int64()[i+t_destStartIdx] = t_src.Int64()[t_sel[i+t_srcStartIdx]]
								}

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop

							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := &leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							if outStartIdx < o.outputBatchSize {

								outCol[outStartIdx] = srcCol[srcStartIdx]

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)

								continue LeftColLoop
							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Float32:
			srcCol := src.Float32()
			outCol := out.Float32()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := &leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							srcEndIdx := srcStartIdx + 1
							if outStartIdx < o.outputBatchSize {

								// TODO (georgeutsin): update template language to automatically generate template function function parameter definitions from expressions passed in.
								t_dest := out
								t_destStartIdx := int(outStartIdx)
								t_src := src
								t_srcStartIdx := srcStartIdx
								t_srcEndIdx := srcEndIdx
								t_sel := sel

								batchSize := t_srcEndIdx - t_srcStartIdx
								for i := 0; i < batchSize; i++ {
									t_dest.Float32()[i+t_destStartIdx] = t_src.Float32()[t_sel[i+t_srcStartIdx]]
								}

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop

							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := &leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							if outStartIdx < o.outputBatchSize {

								outCol[outStartIdx] = srcCol[srcStartIdx]

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)

								continue LeftColLoop
							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Float64:
			srcCol := src.Float64()
			outCol := out.Float64()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := &leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							srcEndIdx := srcStartIdx + 1
							if outStartIdx < o.outputBatchSize {

								// TODO (georgeutsin): update template language to automatically generate template function function parameter definitions from expressions passed in.
								t_dest := out
								t_destStartIdx := int(outStartIdx)
								t_src := src
								t_srcStartIdx := srcStartIdx
								t_srcEndIdx := srcEndIdx
								t_sel := sel

								batchSize := t_srcEndIdx - t_srcStartIdx
								for i := 0; i < batchSize; i++ {
									t_dest.Float64()[i+t_destStartIdx] = t_src.Float64()[t_sel[i+t_srcStartIdx]]
								}

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)
								continue LeftColLoop

							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.left.groupsIdx < groupsLen; o.builderState.left.groupsIdx++ {
					leftGroup := &leftGroups[o.builderState.left.groupsIdx]
					// If curSrcStartIdx is uninitialized, start it at the group's start idx. Otherwise continue where we left off.
					if o.builderState.left.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
						o.builderState.left.curSrcStartIdx = leftGroup.rowStartIdx
					}
					// Loop over every row in the group.
					for ; o.builderState.left.curSrcStartIdx < leftGroup.rowEndIdx; o.builderState.left.curSrcStartIdx++ {
						// Repeat each row numRepeats times.
						for ; o.builderState.left.numRepeatsIdx < leftGroup.numRepeats; o.builderState.left.numRepeatsIdx++ {
							srcStartIdx := o.builderState.left.curSrcStartIdx
							if outStartIdx < o.outputBatchSize {

								outCol[outStartIdx] = srcCol[srcStartIdx]

								outStartIdx++
							} else {
								if o.builderState.left.colIdx == len(input.outCols)-1 {
									o.builderState.left.colIdx = zeroMJCPcolIdx
									return
								}
								o.builderState.left.setBuilderColumnState(initialBuilderState)

								continue LeftColLoop
							}
						}
						o.builderState.left.numRepeatsIdx = zeroMJCPnumRepeatsIdx
					}
					o.builderState.left.curSrcStartIdx = zeroMJCPcurSrcStartIdx
				}
				o.builderState.left.groupsIdx = zeroMJCPgroupsIdx
			}
		default:
			panic(fmt.Sprintf("unhandled type %d", colType))
		}
		o.builderState.left.setBuilderColumnState(initialBuilderState)
	}

	o.builderState.left.reset()
}

// buildRightGroups takes a []group and repeats each group numRepeats times.
// For example, given an input table:
//  R1 |  R2
//  --------
//  1  |  a
//  1  |  b
// and rightGroups = [{startIdx: 0, endIdx: 2, numRepeats: 3}]
// then buildRightGroups expands this to
//  R1 |  R2
//  --------
//  1  |  a
//  1  |  b
//  1  |  a
//  1  |  b
//  1  |  a
//  1  |  b
// Note: this is different from buildLeftGroups in that each group is not expanded,
// but directly copied numRepeats times.
// SIDE EFFECTS: writes into o.output.
func (o *mergeJoinOp) buildRightGroups(
	rightGroups []group,
	groupsLen int,
	colOffset int,
	input *mergeJoinInput,
	bat coldata.Batch,
	destStartIdx uint16,
) {
	o.builderState.right.finished = false
	initialBuilderState := o.builderState.right
	sel := bat.Selection()

	// Loop over every column.
RightColLoop:
	for ; o.builderState.right.colIdx < len(input.outCols); o.builderState.right.colIdx++ {
		colIdx := input.outCols[o.builderState.right.colIdx]
		outStartIdx := int(destStartIdx)
		out := o.output.ColVec(int(colIdx) + colOffset)
		src := bat.ColVec(int(colIdx))
		colType := input.sourceTypes[colIdx]

		switch colType {
		case types.Bool:
			srcCol := src.Bool()
			outCol := out.Bool()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := &rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						t_dest := out
						t_destStartIdx := outStartIdx
						t_src := src
						t_srcStartIdx := o.builderState.right.curSrcStartIdx
						t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
						t_sel := sel

						batchSize := t_srcEndIdx - t_srcStartIdx
						for i := 0; i < batchSize; i++ {
							t_dest.Bool()[i+t_destStartIdx] = t_src.Bool()[t_sel[i+t_srcStartIdx]]
						}

						outStartIdx += toAppend

						// If we haven't materialized all the rows from the group, then we are done with the current column.
						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							// If it's the last column, save state and return.
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							// Otherwise, reset to the initial state and begin the next column.
							o.builderState.right.setBuilderColumnState(initialBuilderState)
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := &rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						// Optimization to use assignment in the case that only 1 element is being appended.
						if toAppend == 1 {
							outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
						} else {
							copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
						}

						outStartIdx += toAppend

						// If we haven't materialized all the rows from the group, then we are done with the current column.
						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							// If it's the last column, save state and return.
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							// Otherwise, reset to the initial state and begin the next column.
							o.builderState.right.setBuilderColumnState(initialBuilderState)
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Bytes:
			srcCol := src.Bytes()
			outCol := out.Bytes()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := &rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						t_dest := out
						t_destStartIdx := outStartIdx
						t_src := src
						t_srcStartIdx := o.builderState.right.curSrcStartIdx
						t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
						t_sel := sel

						batchSize := t_srcEndIdx - t_srcStartIdx
						for i := 0; i < batchSize; i++ {
							t_dest.Bytes()[i+t_destStartIdx] = t_src.Bytes()[t_sel[i+t_srcStartIdx]]
						}

						outStartIdx += toAppend

						// If we haven't materialized all the rows from the group, then we are done with the current column.
						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							// If it's the last column, save state and return.
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							// Otherwise, reset to the initial state and begin the next column.
							o.builderState.right.setBuilderColumnState(initialBuilderState)
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := &rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						// Optimization to use assignment in the case that only 1 element is being appended.
						if toAppend == 1 {
							outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
						} else {
							copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
						}

						outStartIdx += toAppend

						// If we haven't materialized all the rows from the group, then we are done with the current column.
						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							// If it's the last column, save state and return.
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							// Otherwise, reset to the initial state and begin the next column.
							o.builderState.right.setBuilderColumnState(initialBuilderState)
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Decimal:
			srcCol := src.Decimal()
			outCol := out.Decimal()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := &rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						t_dest := out
						t_destStartIdx := outStartIdx
						t_src := src
						t_srcStartIdx := o.builderState.right.curSrcStartIdx
						t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
						t_sel := sel

						batchSize := t_srcEndIdx - t_srcStartIdx
						for i := 0; i < batchSize; i++ {
							t_dest.Decimal()[i+t_destStartIdx] = t_src.Decimal()[t_sel[i+t_srcStartIdx]]
						}

						outStartIdx += toAppend

						// If we haven't materialized all the rows from the group, then we are done with the current column.
						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							// If it's the last column, save state and return.
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							// Otherwise, reset to the initial state and begin the next column.
							o.builderState.right.setBuilderColumnState(initialBuilderState)
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := &rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						// Optimization to use assignment in the case that only 1 element is being appended.
						if toAppend == 1 {
							outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
						} else {
							copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
						}

						outStartIdx += toAppend

						// If we haven't materialized all the rows from the group, then we are done with the current column.
						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							// If it's the last column, save state and return.
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							// Otherwise, reset to the initial state and begin the next column.
							o.builderState.right.setBuilderColumnState(initialBuilderState)
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Int8:
			srcCol := src.Int8()
			outCol := out.Int8()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := &rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						t_dest := out
						t_destStartIdx := outStartIdx
						t_src := src
						t_srcStartIdx := o.builderState.right.curSrcStartIdx
						t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
						t_sel := sel

						batchSize := t_srcEndIdx - t_srcStartIdx
						for i := 0; i < batchSize; i++ {
							t_dest.Int8()[i+t_destStartIdx] = t_src.Int8()[t_sel[i+t_srcStartIdx]]
						}

						outStartIdx += toAppend

						// If we haven't materialized all the rows from the group, then we are done with the current column.
						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							// If it's the last column, save state and return.
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							// Otherwise, reset to the initial state and begin the next column.
							o.builderState.right.setBuilderColumnState(initialBuilderState)
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := &rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						// Optimization to use assignment in the case that only 1 element is being appended.
						if toAppend == 1 {
							outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
						} else {
							copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
						}

						outStartIdx += toAppend

						// If we haven't materialized all the rows from the group, then we are done with the current column.
						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							// If it's the last column, save state and return.
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							// Otherwise, reset to the initial state and begin the next column.
							o.builderState.right.setBuilderColumnState(initialBuilderState)
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Int16:
			srcCol := src.Int16()
			outCol := out.Int16()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := &rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						t_dest := out
						t_destStartIdx := outStartIdx
						t_src := src
						t_srcStartIdx := o.builderState.right.curSrcStartIdx
						t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
						t_sel := sel

						batchSize := t_srcEndIdx - t_srcStartIdx
						for i := 0; i < batchSize; i++ {
							t_dest.Int16()[i+t_destStartIdx] = t_src.Int16()[t_sel[i+t_srcStartIdx]]
						}

						outStartIdx += toAppend

						// If we haven't materialized all the rows from the group, then we are done with the current column.
						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							// If it's the last column, save state and return.
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							// Otherwise, reset to the initial state and begin the next column.
							o.builderState.right.setBuilderColumnState(initialBuilderState)
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := &rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						// Optimization to use assignment in the case that only 1 element is being appended.
						if toAppend == 1 {
							outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
						} else {
							copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
						}

						outStartIdx += toAppend

						// If we haven't materialized all the rows from the group, then we are done with the current column.
						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							// If it's the last column, save state and return.
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							// Otherwise, reset to the initial state and begin the next column.
							o.builderState.right.setBuilderColumnState(initialBuilderState)
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Int32:
			srcCol := src.Int32()
			outCol := out.Int32()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := &rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						t_dest := out
						t_destStartIdx := outStartIdx
						t_src := src
						t_srcStartIdx := o.builderState.right.curSrcStartIdx
						t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
						t_sel := sel

						batchSize := t_srcEndIdx - t_srcStartIdx
						for i := 0; i < batchSize; i++ {
							t_dest.Int32()[i+t_destStartIdx] = t_src.Int32()[t_sel[i+t_srcStartIdx]]
						}

						outStartIdx += toAppend

						// If we haven't materialized all the rows from the group, then we are done with the current column.
						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							// If it's the last column, save state and return.
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							// Otherwise, reset to the initial state and begin the next column.
							o.builderState.right.setBuilderColumnState(initialBuilderState)
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := &rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						// Optimization to use assignment in the case that only 1 element is being appended.
						if toAppend == 1 {
							outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
						} else {
							copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
						}

						outStartIdx += toAppend

						// If we haven't materialized all the rows from the group, then we are done with the current column.
						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							// If it's the last column, save state and return.
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							// Otherwise, reset to the initial state and begin the next column.
							o.builderState.right.setBuilderColumnState(initialBuilderState)
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Int64:
			srcCol := src.Int64()
			outCol := out.Int64()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := &rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						t_dest := out
						t_destStartIdx := outStartIdx
						t_src := src
						t_srcStartIdx := o.builderState.right.curSrcStartIdx
						t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
						t_sel := sel

						batchSize := t_srcEndIdx - t_srcStartIdx
						for i := 0; i < batchSize; i++ {
							t_dest.Int64()[i+t_destStartIdx] = t_src.Int64()[t_sel[i+t_srcStartIdx]]
						}

						outStartIdx += toAppend

						// If we haven't materialized all the rows from the group, then we are done with the current column.
						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							// If it's the last column, save state and return.
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							// Otherwise, reset to the initial state and begin the next column.
							o.builderState.right.setBuilderColumnState(initialBuilderState)
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := &rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						// Optimization to use assignment in the case that only 1 element is being appended.
						if toAppend == 1 {
							outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
						} else {
							copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
						}

						outStartIdx += toAppend

						// If we haven't materialized all the rows from the group, then we are done with the current column.
						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							// If it's the last column, save state and return.
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							// Otherwise, reset to the initial state and begin the next column.
							o.builderState.right.setBuilderColumnState(initialBuilderState)
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Float32:
			srcCol := src.Float32()
			outCol := out.Float32()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := &rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						t_dest := out
						t_destStartIdx := outStartIdx
						t_src := src
						t_srcStartIdx := o.builderState.right.curSrcStartIdx
						t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
						t_sel := sel

						batchSize := t_srcEndIdx - t_srcStartIdx
						for i := 0; i < batchSize; i++ {
							t_dest.Float32()[i+t_destStartIdx] = t_src.Float32()[t_sel[i+t_srcStartIdx]]
						}

						outStartIdx += toAppend

						// If we haven't materialized all the rows from the group, then we are done with the current column.
						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							// If it's the last column, save state and return.
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							// Otherwise, reset to the initial state and begin the next column.
							o.builderState.right.setBuilderColumnState(initialBuilderState)
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := &rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						// Optimization to use assignment in the case that only 1 element is being appended.
						if toAppend == 1 {
							outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
						} else {
							copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
						}

						outStartIdx += toAppend

						// If we haven't materialized all the rows from the group, then we are done with the current column.
						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							// If it's the last column, save state and return.
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							// Otherwise, reset to the initial state and begin the next column.
							o.builderState.right.setBuilderColumnState(initialBuilderState)
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			}
		case types.Float64:
			srcCol := src.Float64()
			outCol := out.Float64()

			if sel != nil {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := &rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						t_dest := out
						t_destStartIdx := outStartIdx
						t_src := src
						t_srcStartIdx := o.builderState.right.curSrcStartIdx
						t_srcEndIdx := o.builderState.right.curSrcStartIdx + toAppend
						t_sel := sel

						batchSize := t_srcEndIdx - t_srcStartIdx
						for i := 0; i < batchSize; i++ {
							t_dest.Float64()[i+t_destStartIdx] = t_src.Float64()[t_sel[i+t_srcStartIdx]]
						}

						outStartIdx += toAppend

						// If we haven't materialized all the rows from the group, then we are done with the current column.
						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							// If it's the last column, save state and return.
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							// Otherwise, reset to the initial state and begin the next column.
							o.builderState.right.setBuilderColumnState(initialBuilderState)
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			} else {
				// Loop over every group.
				for ; o.builderState.right.groupsIdx < groupsLen; o.builderState.right.groupsIdx++ {
					rightGroup := &rightGroups[o.builderState.right.groupsIdx]
					// Repeat every group numRepeats times.
					for ; o.builderState.right.numRepeatsIdx < rightGroup.numRepeats; o.builderState.right.numRepeatsIdx++ {
						if o.builderState.right.curSrcStartIdx == zeroMJCPcurSrcStartIdx {
							o.builderState.right.curSrcStartIdx = rightGroup.rowStartIdx
						}
						toAppend := rightGroup.rowEndIdx - o.builderState.right.curSrcStartIdx
						if outStartIdx+toAppend > int(o.outputBatchSize) {
							toAppend = int(o.outputBatchSize) - outStartIdx
						}

						// Optimization to use assignment in the case that only 1 element is being appended.
						if toAppend == 1 {
							outCol[outStartIdx] = srcCol[o.builderState.right.curSrcStartIdx]
						} else {
							copy(outCol[outStartIdx:], srcCol[o.builderState.right.curSrcStartIdx:o.builderState.right.curSrcStartIdx+toAppend])
						}

						outStartIdx += toAppend

						// If we haven't materialized all the rows from the group, then we are done with the current column.
						if toAppend < rightGroup.rowEndIdx-o.builderState.right.curSrcStartIdx {
							// If it's the last column, save state and return.
							if o.builderState.right.colIdx == len(input.outCols)-1 {
								o.builderState.right.curSrcStartIdx = o.builderState.right.curSrcStartIdx + toAppend
								o.builderState.right.colIdx = zeroMJCPcolIdx
								return
							}
							// Otherwise, reset to the initial state and begin the next column.
							o.builderState.right.setBuilderColumnState(initialBuilderState)
							continue RightColLoop
						}
						o.builderState.right.curSrcStartIdx = zeroMJCPcurSrcStartIdx
					}
					o.builderState.right.numRepeatsIdx = zeroMJCPnumRepeatsIdx
				}
				o.builderState.right.groupsIdx = zeroMJCPgroupsIdx
			}
		default:
			panic(fmt.Sprintf("unhandled type %d", colType))
		}
		o.builderState.right.setBuilderColumnState(initialBuilderState)
	}

	o.builderState.right.reset()
}

// isGroupFinished checks to see whether or not the savedGroup continues in bat.
func (o *mergeJoinOp) isGroupFinished(
	input *mergeJoinInput,
	savedGroup coldata.Batch,
	savedGroupIdx int,
	bat coldata.Batch,
	rowIdx int,
	sel []uint16,
) bool {
	if bat.Length() == 0 {
		return true
	}

	// Check all equality columns in the first row of the bat to make sure we're in the same group.
	for _, colIdx := range input.eqCols[:len(input.eqCols)] {
		colTyp := input.sourceTypes[colIdx]

		switch colTyp {
		case types.Bool:
			prevVal := savedGroup.ColVec(int(colIdx)).Bool()[savedGroupIdx-1]
			var curVal bool
			if sel != nil {
				curVal = bat.ColVec(int(colIdx)).Bool()[sel[rowIdx]]
			} else {
				curVal = bat.ColVec(int(colIdx)).Bool()[rowIdx]
			}
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Bytes:
			prevVal := savedGroup.ColVec(int(colIdx)).Bytes()[savedGroupIdx-1]
			var curVal []byte
			if sel != nil {
				curVal = bat.ColVec(int(colIdx)).Bytes()[sel[rowIdx]]
			} else {
				curVal = bat.ColVec(int(colIdx)).Bytes()[rowIdx]
			}
			var match bool
			match = bytes.Equal(prevVal, curVal)
			if !match {
				return true
			}
		case types.Decimal:
			prevVal := savedGroup.ColVec(int(colIdx)).Decimal()[savedGroupIdx-1]
			var curVal apd.Decimal
			if sel != nil {
				curVal = bat.ColVec(int(colIdx)).Decimal()[sel[rowIdx]]
			} else {
				curVal = bat.ColVec(int(colIdx)).Decimal()[rowIdx]
			}
			var match bool
			match = tree.CompareDecimals(&prevVal, &curVal) == 0
			if !match {
				return true
			}
		case types.Int8:
			prevVal := savedGroup.ColVec(int(colIdx)).Int8()[savedGroupIdx-1]
			var curVal int8
			if sel != nil {
				curVal = bat.ColVec(int(colIdx)).Int8()[sel[rowIdx]]
			} else {
				curVal = bat.ColVec(int(colIdx)).Int8()[rowIdx]
			}
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Int16:
			prevVal := savedGroup.ColVec(int(colIdx)).Int16()[savedGroupIdx-1]
			var curVal int16
			if sel != nil {
				curVal = bat.ColVec(int(colIdx)).Int16()[sel[rowIdx]]
			} else {
				curVal = bat.ColVec(int(colIdx)).Int16()[rowIdx]
			}
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Int32:
			prevVal := savedGroup.ColVec(int(colIdx)).Int32()[savedGroupIdx-1]
			var curVal int32
			if sel != nil {
				curVal = bat.ColVec(int(colIdx)).Int32()[sel[rowIdx]]
			} else {
				curVal = bat.ColVec(int(colIdx)).Int32()[rowIdx]
			}
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Int64:
			prevVal := savedGroup.ColVec(int(colIdx)).Int64()[savedGroupIdx-1]
			var curVal int64
			if sel != nil {
				curVal = bat.ColVec(int(colIdx)).Int64()[sel[rowIdx]]
			} else {
				curVal = bat.ColVec(int(colIdx)).Int64()[rowIdx]
			}
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Float32:
			prevVal := savedGroup.ColVec(int(colIdx)).Float32()[savedGroupIdx-1]
			var curVal float32
			if sel != nil {
				curVal = bat.ColVec(int(colIdx)).Float32()[sel[rowIdx]]
			} else {
				curVal = bat.ColVec(int(colIdx)).Float32()[rowIdx]
			}
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		case types.Float64:
			prevVal := savedGroup.ColVec(int(colIdx)).Float64()[savedGroupIdx-1]
			var curVal float64
			if sel != nil {
				curVal = bat.ColVec(int(colIdx)).Float64()[sel[rowIdx]]
			} else {
				curVal = bat.ColVec(int(colIdx)).Float64()[rowIdx]
			}
			var match bool
			match = prevVal == curVal
			if !match {
				return true
			}
		default:
			panic(fmt.Sprintf("unhandled type %d", colTyp))
		}
	}
	return false
}
